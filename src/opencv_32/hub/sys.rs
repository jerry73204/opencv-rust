use crate::{mod_prelude::*, core};

mod core_sys {
    use super::*;

    pub type cv_return_value_DMatch = cv_return_value<core::DMatch>;
    pub type cv_return_value_KeyPoint = cv_return_value<core::KeyPoint>;
    pub type cv_return_value_Moments = cv_return_value<core::Moments>;
    pub type cv_return_value_Point2dWrapper = cv_return_value<core::Point2d>;
    pub type cv_return_value_Point2fWrapper = cv_return_value<core::Point2f>;
    pub type cv_return_value_Point3dWrapper = cv_return_value<core::Point3d>;
    pub type cv_return_value_Point3fWrapper = cv_return_value<core::Point3f>;
    pub type cv_return_value_Point3iWrapper = cv_return_value<core::Point3i>;
    pub type cv_return_value_PointWrapper = cv_return_value<core::Point>;
    pub type cv_return_value_Rect2fWrapper = cv_return_value<core::Rect2f>;
    pub type cv_return_value_RectWrapper = cv_return_value<core::Rect>;
    pub type cv_return_value_ScalarWrapper = cv_return_value<core::Scalar>;
    pub type cv_return_value_Size2fWrapper = cv_return_value<core::Size2f>;
    pub type cv_return_value_SizeWrapper = cv_return_value<core::Size>;
    pub type cv_return_value_Stitcher_Status = cv_return_value<crate::stitching::Stitcher_Status>;
    pub type cv_return_value_UMatUsageFlags = cv_return_value<core::UMatUsageFlags>;
    pub type cv_return_value_Vec2dWrapper = cv_return_value<core::Vec2d>;
    pub type cv_return_value_Vec3dWrapper = cv_return_value<core::Vec3d>;
    pub type cv_return_value_Vec4fWrapper = cv_return_value<core::Vec4f>;
    pub type cv_return_value_Vec4iWrapper = cv_return_value<core::Vec4i>;
    pub type cv_return_value_Vec6fWrapper = cv_return_value<core::Vec6f>;
    pub type cv_return_value_bool = cv_return_value<bool>;
    pub type cv_return_value_char = cv_return_value<i8>;
    pub type cv_return_value_char_X = cv_return_value<*mut c_char>;
    pub type cv_return_value_const_char_X = cv_return_value<*const c_char>;
    pub type cv_return_value_const_int_X = cv_return_value<*const i32>;
    pub type cv_return_value_const_unsigned_char_X = cv_return_value<*const u8>;
    pub type cv_return_value_const_void_X = cv_return_value<*mut c_void>;
    pub type cv_return_value_double = cv_return_value<f64>;
    pub type cv_return_value_float = cv_return_value<f32>;
    pub type cv_return_value_float_X = cv_return_value<*mut f32>;
    pub type cv_return_value_instr_FLAGS = cv_return_value<core::FLAGS>;
    pub type cv_return_value_int = cv_return_value<i32>;
    pub type cv_return_value_int64 = cv_return_value<i64>;
    pub type cv_return_value_int_X = cv_return_value<*mut i32>;
    pub type cv_return_value_std_ptrdiff_t = cv_return_value<ptrdiff_t>;
    pub type cv_return_value_std_size_t = cv_return_value<size_t>;
    pub type cv_return_value_uint64 = cv_return_value<u64>;
    pub type cv_return_value_unsigned_char = cv_return_value<u8>;
    pub type cv_return_value_unsigned_char_X = cv_return_value<*mut u8>;
    pub type cv_return_value_unsigned_int = cv_return_value<u32>;
    pub type cv_return_value_void = cv_return_value<crate::types::Unit, ()>;
    pub type cv_return_value_void_X = cv_return_value<*mut c_void>;
    extern "C" {
        pub fn cv_Cholesky_double_X_size_t_int_double_X_size_t_int(a: *mut f64, astep: size_t, m: i32, b: *mut f64, bstep: size_t, n: i32) -> cv_return_value_bool;
        pub fn cv_Cholesky_float_X_size_t_int_float_X_size_t_int(a: *mut f32, astep: size_t, m: i32, b: *mut f32, bstep: size_t, n: i32) -> cv_return_value_bool;
        pub fn cv_LUT__InputArray__InputArray__OutputArray(src: *mut c_void, lut: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_LU_double_X_size_t_int_double_X_size_t_int(a: *mut f64, astep: size_t, m: i32, b: *mut f64, bstep: size_t, n: i32) -> cv_return_value_int;
        pub fn cv_LU_float_X_size_t_int_float_X_size_t_int(a: *mut f32, astep: size_t, m: i32, b: *mut f32, bstep: size_t, n: i32) -> cv_return_value_int;
        pub fn cv_Mahalanobis__InputArray__InputArray__InputArray(v1: *mut c_void, v2: *mut c_void, icovar: *mut c_void) -> cv_return_value_double;
        pub fn cv_PCABackProject__InputArray__InputArray__InputArray__OutputArray(data: *mut c_void, mean: *mut c_void, eigenvectors: *mut c_void, result: *mut c_void) -> cv_return_value_void;
        pub fn cv_PCACompute__InputArray__InputOutputArray__OutputArray_double(data: *mut c_void, mean: *mut c_void, eigenvectors: *mut c_void, retained_variance: f64) -> cv_return_value_void;
        pub fn cv_PCACompute__InputArray__InputOutputArray__OutputArray_int(data: *mut c_void, mean: *mut c_void, eigenvectors: *mut c_void, max_components: i32) -> cv_return_value_void;
        pub fn cv_PCAProject__InputArray__InputArray__InputArray__OutputArray(data: *mut c_void, mean: *mut c_void, eigenvectors: *mut c_void, result: *mut c_void) -> cv_return_value_void;
        pub fn cv_PSNR__InputArray__InputArray(src1: *mut c_void, src2: *mut c_void) -> cv_return_value_double;
        pub fn cv_SVBackSubst__InputArray__InputArray__InputArray__InputArray__OutputArray(w: *mut c_void, u: *mut c_void, vt: *mut c_void, rhs: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_SVDecomp__InputArray__OutputArray__OutputArray__OutputArray_int(src: *mut c_void, w: *mut c_void, u: *mut c_void, vt: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_String_const() -> cv_return_value_void;
        pub fn cv_abs_Mat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_abs_MatExpr(e: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_absdiff__InputArray__InputArray__OutputArray(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_addWeighted__InputArray_double__InputArray_double_double__OutputArray_int(src1: *mut c_void, alpha: f64, src2: *mut c_void, beta: f64, gamma: f64, dst: *mut c_void, dtype: i32) -> cv_return_value_void;
        pub fn cv_add__InputArray__InputArray__OutputArray__InputArray_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void, dtype: i32) -> cv_return_value_void;
        pub fn cv_alignSize_size_t_int(sz: size_t, n: i32) -> cv_return_value_std_size_t;
        pub fn cv_batchDistance__InputArray__InputArray__OutputArray_int__OutputArray_int_int__InputArray_int_bool(src1: *mut c_void, src2: *mut c_void, dist: *mut c_void, dtype: i32, nidx: *mut c_void, norm_type: i32, k: i32, mask: *mut c_void, update: i32, crosscheck: bool) -> cv_return_value_void;
        pub fn cv_bitwise_and__InputArray__InputArray__OutputArray__InputArray(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_bitwise_not__InputArray__OutputArray__InputArray(src: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_bitwise_or__InputArray__InputArray__OutputArray__InputArray(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_bitwise_xor__InputArray__InputArray__OutputArray__InputArray(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_borderInterpolate_int_int_int(p: i32, len: i32, border_type: i32) -> cv_return_value_int;
        pub fn cv_calcCovarMatrix__InputArray__OutputArray__InputOutputArray_int_int(samples: *mut c_void, covar: *mut c_void, mean: *mut c_void, flags: i32, ctype: i32) -> cv_return_value_void;
        pub fn cv_cartToPolar__InputArray__InputArray__OutputArray__OutputArray_bool(x: *mut c_void, y: *mut c_void, magnitude: *mut c_void, angle: *mut c_void, angle_in_degrees: bool) -> cv_return_value_void;
        pub fn cv_checkHardwareSupport_int(feature: i32) -> cv_return_value_bool;
        pub fn cv_checkRange__InputArray_bool_Point_X_double_double(a: *mut c_void, quiet: bool, pos: *mut core::Point, min_val: f64, max_val: f64) -> cv_return_value_bool;
        pub fn cv_compare__InputArray__InputArray__OutputArray_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, cmpop: i32) -> cv_return_value_void;
        pub fn cv_completeSymm__InputOutputArray_bool(mtx: *mut c_void, lower_to_upper: bool) -> cv_return_value_void;
        pub fn cv_convertFp16__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_convertScaleAbs__InputArray__OutputArray_double_double(src: *mut c_void, dst: *mut c_void, alpha: f64, beta: f64) -> cv_return_value_void;
        pub fn cv_copyMakeBorder__InputArray__OutputArray_int_int_int_int_int_Scalar(src: *mut c_void, dst: *mut c_void, top: i32, bottom: i32, left: i32, right: i32, border_type: i32, value: core::Scalar) -> cv_return_value_void;
        pub fn cv_countNonZero__InputArray(src: *mut c_void) -> cv_return_value_int;
        pub fn cv_cubeRoot_float(val: f32) -> cv_return_value_float;
        pub fn cv_cv_abs_schar(x: i8) -> cv_return_value_int;
        pub fn cv_cv_abs_ushort(x: u16) -> cv_return_value_int;
        pub fn cv_dct__InputArray__OutputArray_int(src: *mut c_void, dst: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_determinant__InputArray(mtx: *mut c_void) -> cv_return_value_double;
        pub fn cv_dft__InputArray__OutputArray_int_int(src: *mut c_void, dst: *mut c_void, flags: i32, nonzero_rows: i32) -> cv_return_value_void;
        pub fn cv_directx_getTypeFromD3DFORMAT_int(i_d3_dformat: i32) -> cv_return_value_int;
        pub fn cv_directx_getTypeFromDXGI_FORMAT_int(i_dxgi_format: i32) -> cv_return_value_int;
        pub fn cv_divide__InputArray__InputArray__OutputArray_double_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, scale: f64, dtype: i32) -> cv_return_value_void;
        pub fn cv_divide_double__InputArray__OutputArray_int(scale: f64, src2: *mut c_void, dst: *mut c_void, dtype: i32) -> cv_return_value_void;
        pub fn cv_eigen__InputArray__OutputArray__OutputArray(src: *mut c_void, eigenvalues: *mut c_void, eigenvectors: *mut c_void) -> cv_return_value_bool;
        pub fn cv_errorNoReturn_int_String_const_char_X_const_char_X_int(_code: i32, _err: *const c_char, _func: *const c_char, _file: *const c_char, _line: i32) -> cv_return_value_void;
        pub fn cv_error_int_String_const_char_X_const_char_X_int(_code: i32, _err: *const c_char, _func: *const c_char, _file: *const c_char, _line: i32) -> cv_return_value_void;
        pub fn cv_exp__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_extractChannel__InputArray__OutputArray_int(src: *mut c_void, dst: *mut c_void, coi: i32) -> cv_return_value_void;
        pub fn cv_fastAtan2_float_float(y: f32, x: f32) -> cv_return_value_float;
        pub fn cv_findNonZero__InputArray__OutputArray(src: *mut c_void, idx: *mut c_void) -> cv_return_value_void;
        pub fn cv_flip__InputArray__OutputArray_int(src: *mut c_void, dst: *mut c_void, flip_code: i32) -> cv_return_value_void;
        pub fn cv_gemm__InputArray__InputArray_double__InputArray_double__OutputArray_int(src1: *mut c_void, src2: *mut c_void, alpha: f64, src3: *mut c_void, beta: f64, dst: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_getBuildInformation() -> cv_return_value_const_char_X;
        pub fn cv_getCPUTickCount() -> cv_return_value_int64;
        pub fn cv_getElemSize_int(_type: i32) -> cv_return_value_std_size_t;
        pub fn cv_getNumThreads() -> cv_return_value_int;
        pub fn cv_getNumberOfCPUs() -> cv_return_value_int;
        pub fn cv_getOptimalDFTSize_int(vecsize: i32) -> cv_return_value_int;
        pub fn cv_getThreadNum() -> cv_return_value_int;
        pub fn cv_getTickCount() -> cv_return_value_int64;
        pub fn cv_getTickFrequency() -> cv_return_value_double;
        pub fn cv_glob_String_VectorOfString_bool(pattern: *mut c_char, result: *mut c_void, recursive: bool) -> cv_return_value_void;
        pub fn cv_haveOpenVX() -> cv_return_value_bool;
        pub fn cv_hconcat__InputArray__InputArray__OutputArray(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_hconcat__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_idct__InputArray__OutputArray_int(src: *mut c_void, dst: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_idft__InputArray__OutputArray_int_int(src: *mut c_void, dst: *mut c_void, flags: i32, nonzero_rows: i32) -> cv_return_value_void;
        pub fn cv_inRange__InputArray__InputArray__InputArray__OutputArray(src: *mut c_void, lowerb: *mut c_void, upperb: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_insertChannel__InputArray__InputOutputArray_int(src: *mut c_void, dst: *mut c_void, coi: i32) -> cv_return_value_void;
        pub fn cv_instr_getFlags() -> cv_return_value_instr_FLAGS;
        pub fn cv_instr_resetTrace() -> cv_return_value_void;
        pub fn cv_instr_setFlags_FLAGS(mode_flags: core::FLAGS) -> cv_return_value_void;
        pub fn cv_instr_setFlags_int(mode_flags: i32) -> cv_return_value_void;
        pub fn cv_instr_setUseInstrumentation_bool(flag: bool) -> cv_return_value_void;
        pub fn cv_instr_useInstrumentation() -> cv_return_value_bool;
        pub fn cv_invert__InputArray__OutputArray_int(src: *mut c_void, dst: *mut c_void, flags: i32) -> cv_return_value_double;
        pub fn cv_ipp_getIppErrorLocation() -> cv_return_value_char_X;
        pub fn cv_ipp_getIppFeatures() -> cv_return_value_int;
        pub fn cv_ipp_getIppStatus() -> cv_return_value_int;
        pub fn cv_ipp_setUseIPP_bool(flag: bool) -> cv_return_value_void;
        pub fn cv_ipp_useIPP() -> cv_return_value_bool;
        pub fn cv_kmeans__InputArray_int__InputOutputArray_TermCriteria_int_int__OutputArray(data: *mut c_void, k: i32, best_labels: *mut c_void, criteria: *mut c_void, attempts: i32, flags: i32, centers: *mut c_void) -> cv_return_value_double;
        pub fn cv_log__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_magnitude__InputArray__InputArray__OutputArray(x: *mut c_void, y: *mut c_void, magnitude: *mut c_void) -> cv_return_value_void;
        pub fn cv_max_Mat_Mat(a: *mut c_void, b: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_max_Mat_Mat_Mat(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_max_Mat_double(a: *mut c_void, s: f64) -> cv_return_value_void_X;
        pub fn cv_max_UMat_UMat_UMat(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_max__InputArray__InputArray__OutputArray(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_max_double_Mat(s: f64, a: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_meanStdDev__InputArray__OutputArray__OutputArray__InputArray(src: *mut c_void, mean: *mut c_void, stddev: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_mean__InputArray__InputArray(src: *mut c_void, mask: *mut c_void) -> cv_return_value_ScalarWrapper;
        pub fn cv_merge__InputArray__OutputArray(mv: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_minMaxIdx__InputArray_double_X_double_X_int_X_int_X__InputArray(src: *mut c_void, min_val: *mut f64, max_val: *mut f64, min_idx: *mut i32, max_idx: *mut i32, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_minMaxLoc_SparseMat_double_X_double_X_int_X_int_X(a: *mut c_void, min_val: *mut f64, max_val: *mut f64, min_idx: *mut i32, max_idx: *mut i32) -> cv_return_value_void;
        pub fn cv_minMaxLoc__InputArray_double_X_double_X_Point_X_Point_X__InputArray(src: *mut c_void, min_val: *mut f64, max_val: *mut f64, min_loc: *mut core::Point, max_loc: *mut core::Point, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_min_Mat_Mat(a: *mut c_void, b: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_min_Mat_Mat_Mat(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_min_Mat_double(a: *mut c_void, s: f64) -> cv_return_value_void_X;
        pub fn cv_min_UMat_UMat_UMat(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_min__InputArray__InputArray__OutputArray(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_min_double_Mat(s: f64, a: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_mixChannels__InputArray__InputOutputArray_VectorOfint(src: *mut c_void, dst: *mut c_void, from_to: *mut c_void) -> cv_return_value_void;
        pub fn cv_mulSpectrums__InputArray__InputArray__OutputArray_int_bool(a: *mut c_void, b: *mut c_void, c: *mut c_void, flags: i32, conj_b: bool) -> cv_return_value_void;
        pub fn cv_mulTransposed__InputArray__OutputArray_bool__InputArray_double_int(src: *mut c_void, dst: *mut c_void, a_ta: bool, delta: *mut c_void, scale: f64, dtype: i32) -> cv_return_value_void;
        pub fn cv_multiply__InputArray__InputArray__OutputArray_double_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, scale: f64, dtype: i32) -> cv_return_value_void;
        pub fn cv_noArray() -> cv_return_value_void_X;
        pub fn cv_normL1_const_float_X_const_float_X_int(a: *const f32, b: *const f32, n: i32) -> cv_return_value_float;
        pub fn cv_normL1_const_uchar_X_const_uchar_X_int(a: *const u8, b: *const u8, n: i32) -> cv_return_value_int;
        pub fn cv_normL2Sqr_const_float_X_const_float_X_int(a: *const f32, b: *const f32, n: i32) -> cv_return_value_float;
        pub fn cv_norm_SparseMat_int(src: *mut c_void, norm_type: i32) -> cv_return_value_double;
        pub fn cv_norm__InputArray__InputArray_int__InputArray(src1: *mut c_void, src2: *mut c_void, norm_type: i32, mask: *mut c_void) -> cv_return_value_double;
        pub fn cv_norm__InputArray_int__InputArray(src1: *mut c_void, norm_type: i32, mask: *mut c_void) -> cv_return_value_double;
        pub fn cv_normalize_SparseMat_SparseMat_double_int(src: *mut c_void, dst: *mut c_void, alpha: f64, norm_type: i32) -> cv_return_value_void;
        pub fn cv_normalize__InputArray__InputOutputArray_double_double_int_int__InputArray(src: *mut c_void, dst: *mut c_void, alpha: f64, beta: f64, norm_type: i32, dtype: i32, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_ocl_attachContext_String_void_X_void_X_void_X(platform_name: *const c_char, platform_id: *mut c_void, context: *mut c_void, device_id: *mut c_void) -> cv_return_value_void;
        pub fn cv_ocl_buildOptionsAddMatrixDescription_String_String__InputArray(build_options: *mut *mut c_char, name: *const c_char, _m: *mut c_void) -> cv_return_value_void;
        pub fn cv_ocl_checkOptimalVectorWidth_const_int_X__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray_OclVectorStrategy(vector_widths: *const i32, src1: *mut c_void, src2: *mut c_void, src3: *mut c_void, src4: *mut c_void, src5: *mut c_void, src6: *mut c_void, src7: *mut c_void, src8: *mut c_void, src9: *mut c_void, strat: core::OclVectorStrategy) -> cv_return_value_int;
        pub fn cv_ocl_convertFromBuffer_void_X_size_t_int_int_int_UMat(cl_mem_buffer: *mut c_void, step: size_t, rows: i32, cols: i32, _type: i32, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_ocl_convertFromImage_void_X_UMat(cl_mem_image: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_ocl_convertTypeStr_int_int_int_char_X(sdepth: i32, ddepth: i32, cn: i32, buf: *mut c_char) -> cv_return_value_const_char_X;
        pub fn cv_ocl_finish() -> cv_return_value_void;
        pub fn cv_ocl_getPlatfomsInfo_VectorOfPlatformInfo(platform_info: *mut c_void) -> cv_return_value_void;
        pub fn cv_ocl_haveAmdBlas() -> cv_return_value_bool;
        pub fn cv_ocl_haveAmdFft() -> cv_return_value_bool;
        pub fn cv_ocl_haveOpenCL() -> cv_return_value_bool;
        pub fn cv_ocl_haveSVM() -> cv_return_value_bool;
        pub fn cv_ocl_kernelToStr__InputArray_int_const_char_X(_kernel: *mut c_void, ddepth: i32, name: *const c_char) -> cv_return_value_char_X;
        pub fn cv_ocl_memopTypeToStr_int(t: i32) -> cv_return_value_const_char_X;
        pub fn cv_ocl_predictOptimalVectorWidthMax__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray(src1: *mut c_void, src2: *mut c_void, src3: *mut c_void, src4: *mut c_void, src5: *mut c_void, src6: *mut c_void, src7: *mut c_void, src8: *mut c_void, src9: *mut c_void) -> cv_return_value_int;
        pub fn cv_ocl_predictOptimalVectorWidth__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray_OclVectorStrategy(src1: *mut c_void, src2: *mut c_void, src3: *mut c_void, src4: *mut c_void, src5: *mut c_void, src6: *mut c_void, src7: *mut c_void, src8: *mut c_void, src9: *mut c_void, strat: core::OclVectorStrategy) -> cv_return_value_int;
        pub fn cv_ocl_setUseOpenCL_bool(flag: bool) -> cv_return_value_void;
        pub fn cv_ocl_typeToStr_int(t: i32) -> cv_return_value_const_char_X;
        pub fn cv_ocl_useOpenCL() -> cv_return_value_bool;
        pub fn cv_ocl_vecopTypeToStr_int(t: i32) -> cv_return_value_const_char_X;
        pub fn cv_parallel_for__Range_ParallelLoopBody_double(range: *mut c_void, body: *mut c_void, nstripes: f64) -> cv_return_value_void;
        pub fn cv_patchNaNs__InputOutputArray_double(a: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_perspectiveTransform__InputArray__OutputArray__InputArray(src: *mut c_void, dst: *mut c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_phase__InputArray__InputArray__OutputArray_bool(x: *mut c_void, y: *mut c_void, angle: *mut c_void, angle_in_degrees: bool) -> cv_return_value_void;
        pub fn cv_polarToCart__InputArray__InputArray__OutputArray__OutputArray_bool(magnitude: *mut c_void, angle: *mut c_void, x: *mut c_void, y: *mut c_void, angle_in_degrees: bool) -> cv_return_value_void;
        pub fn cv_pow__InputArray_double__OutputArray(src: *mut c_void, power: f64, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_randn__InputOutputArray__InputArray__InputArray(dst: *mut c_void, mean: *mut c_void, stddev: *mut c_void) -> cv_return_value_void;
        pub fn cv_randu__InputOutputArray__InputArray__InputArray(dst: *mut c_void, low: *mut c_void, high: *mut c_void) -> cv_return_value_void;
        pub fn cv_read_FileNode_Mat_Mat(node: *mut c_void, mat: *mut c_void, default_mat: *mut c_void) -> cv_return_value_void;
        pub fn cv_read_FileNode_Range_Range(node: *mut c_void, value: *mut c_void, default_value: *mut c_void) -> cv_return_value_void;
        pub fn cv_read_FileNode_SparseMat_SparseMat(node: *mut c_void, mat: *mut c_void, default_mat: *mut c_void) -> cv_return_value_void;
        pub fn cv_read_FileNode_String_String(node: *mut c_void, value: *mut *mut c_char, default_value: *const c_char) -> cv_return_value_void;
        pub fn cv_read_FileNode_VectorOfDMatch(node: *mut c_void, matches: *mut c_void) -> cv_return_value_void;
        pub fn cv_read_FileNode_VectorOfKeyPoint(node: *mut c_void, keypoints: *mut c_void) -> cv_return_value_void;
        pub fn cv_read_FileNode_bool_bool(node: *mut c_void, value: *mut bool, default_value: bool) -> cv_return_value_void;
        pub fn cv_read_FileNode_double_double(node: *mut c_void, value: *mut f64, default_value: f64) -> cv_return_value_void;
        pub fn cv_read_FileNode_float_float(node: *mut c_void, value: *mut f32, default_value: f32) -> cv_return_value_void;
        pub fn cv_read_FileNode_int_int(node: *mut c_void, value: *mut i32, default_value: i32) -> cv_return_value_void;
        pub fn cv_read_FileNode_short_short(node: *mut c_void, value: *mut i16, default_value: i16) -> cv_return_value_void;
        pub fn cv_read_FileNode_uchar_uchar(node: *mut c_void, value: *mut u8, default_value: u8) -> cv_return_value_void;
        pub fn cv_read_FileNode_ushort_ushort(node: *mut c_void, value: *mut u16, default_value: u16) -> cv_return_value_void;
        pub fn cv_reduce__InputArray__OutputArray_int_int_int(src: *mut c_void, dst: *mut c_void, dim: i32, rtype: i32, dtype: i32) -> cv_return_value_void;
        pub fn cv_repeat_Mat_int_int(src: *mut c_void, ny: i32, nx: i32) -> cv_return_value_void_X;
        pub fn cv_repeat__InputArray_int_int__OutputArray(src: *mut c_void, ny: i32, nx: i32, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_rotate__InputArray__OutputArray_int(src: *mut c_void, dst: *mut c_void, rotate_code: i32) -> cv_return_value_void;
        pub fn cv_scaleAdd__InputArray_double__InputArray__OutputArray(src1: *mut c_void, alpha: f64, src2: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_setBreakOnError_bool(flag: bool) -> cv_return_value_bool;
        pub fn cv_setIdentity__InputOutputArray_Scalar(mtx: *mut c_void, s: core::Scalar) -> cv_return_value_void;
        pub fn cv_setNumThreads_int(nthreads: i32) -> cv_return_value_void;
        pub fn cv_setRNGSeed_int(seed: i32) -> cv_return_value_void;
        pub fn cv_setUseOpenVX_bool(flag: bool) -> cv_return_value_void;
        pub fn cv_setUseOptimized_bool(onoff: bool) -> cv_return_value_void;
        pub fn cv_solveCubic__InputArray__OutputArray(coeffs: *mut c_void, roots: *mut c_void) -> cv_return_value_int;
        pub fn cv_solveLP_Mat_Mat_Mat(func: *mut c_void, constr: *mut c_void, z: *mut c_void) -> cv_return_value_int;
        pub fn cv_solvePoly__InputArray__OutputArray_int(coeffs: *mut c_void, roots: *mut c_void, max_iters: i32) -> cv_return_value_double;
        pub fn cv_solve__InputArray__InputArray__OutputArray_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, flags: i32) -> cv_return_value_bool;
        pub fn cv_sortIdx__InputArray__OutputArray_int(src: *mut c_void, dst: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_sort__InputArray__OutputArray_int(src: *mut c_void, dst: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_split__InputArray__OutputArray(m: *mut c_void, mv: *mut c_void) -> cv_return_value_void;
        pub fn cv_sqrt__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_subtract__InputArray__InputArray__OutputArray__InputArray_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void, dtype: i32) -> cv_return_value_void;
        pub fn cv_sum__InputArray(src: *mut c_void) -> cv_return_value_ScalarWrapper;
        pub fn cv_swap_Mat_Mat(a: *mut c_void, b: *mut c_void) -> cv_return_value_void;
        pub fn cv_swap_UMat_UMat(a: *mut c_void, b: *mut c_void) -> cv_return_value_void;
        pub fn cv_tempfile_const_char_X(suffix: *const c_char) -> cv_return_value_char_X;
        pub fn cv_trace__InputArray(mtx: *mut c_void) -> cv_return_value_ScalarWrapper;
        pub fn cv_transform__InputArray__OutputArray__InputArray(src: *mut c_void, dst: *mut c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_transpose__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_useOpenVX() -> cv_return_value_bool;
        pub fn cv_useOptimized() -> cv_return_value_bool;
        pub fn cv_va_intel_convertFromVASurface_void_X_unsigned_int_Size__OutputArray(display: *mut c_void, surface: u32, size: core::Size, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_va_intel_convertToVASurface_void_X__InputArray_unsigned_int_Size(display: *mut c_void, src: *mut c_void, surface: u32, size: core::Size) -> cv_return_value_void;
        pub fn cv_vconcat__InputArray__InputArray__OutputArray(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_vconcat__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_writeScalar_FileStorage_String(fs: *mut c_void, value: *const c_char) -> cv_return_value_void;
        pub fn cv_writeScalar_FileStorage_double(fs: *mut c_void, value: f64) -> cv_return_value_void;
        pub fn cv_writeScalar_FileStorage_float(fs: *mut c_void, value: f32) -> cv_return_value_void;
        pub fn cv_writeScalar_FileStorage_int(fs: *mut c_void, value: i32) -> cv_return_value_void;
        pub fn cv_write_FileStorage_Range(fs: *mut c_void, r: *mut c_void) -> cv_return_value_void;
        pub fn cv_write_FileStorage_String_Mat(fs: *mut c_void, name: *const c_char, value: *mut c_void) -> cv_return_value_void;
        pub fn cv_write_FileStorage_String_Range(fs: *mut c_void, name: *const c_char, r: *mut c_void) -> cv_return_value_void;
        pub fn cv_write_FileStorage_String_SparseMat(fs: *mut c_void, name: *const c_char, value: *mut c_void) -> cv_return_value_void;
        pub fn cv_write_FileStorage_String_String(fs: *mut c_void, name: *const c_char, value: *const c_char) -> cv_return_value_void;
        pub fn cv_write_FileStorage_String_VectorOfDMatch(fs: *mut c_void, name: *const c_char, value: *mut c_void) -> cv_return_value_void;
        pub fn cv_write_FileStorage_String_VectorOfKeyPoint(fs: *mut c_void, name: *const c_char, value: *mut c_void) -> cv_return_value_void;
        pub fn cv_write_FileStorage_String_double(fs: *mut c_void, name: *const c_char, value: f64) -> cv_return_value_void;
        pub fn cv_write_FileStorage_String_float(fs: *mut c_void, name: *const c_char, value: f32) -> cv_return_value_void;
        pub fn cv_write_FileStorage_String_int(fs: *mut c_void, name: *const c_char, value: i32) -> cv_return_value_void;
        pub fn cv_Algorithm_clear(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_Algorithm_write_const_FileStorage(instance: *const c_void, fs: *mut c_void) -> cv_return_value_void;
        pub fn cv_Algorithm_read_FileNode(instance: *mut c_void, _fn: *mut c_void) -> cv_return_value_void;
        pub fn cv_Algorithm_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_Algorithm_save_const_String(instance: *const c_void, filename: *const c_char) -> cv_return_value_void;
        pub fn cv_Algorithm_getDefaultName_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_Algorithm_delete(ptr : *mut c_void);
        pub fn cv_Algorithm_Algorithm() -> cv_return_value_void_X;
        pub fn cv_AutoLock_delete(ptr : *mut c_void);
        pub fn cv_BufferPoolController_getReservedSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_BufferPoolController_getMaxReservedSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_BufferPoolController_setMaxReservedSize_size_t(instance: *mut c_void, size: size_t) -> cv_return_value_void;
        pub fn cv_BufferPoolController_freeAllReservedBuffers(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_CommandLineParser_delete(ptr : *mut c_void);
        pub fn cv_CommandLineParser_CommandLineParser_CommandLineParser(parser: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_CommandLineParser_getPathToApplication_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_CommandLineParser_has_const_String(instance: *const c_void, name: *const c_char) -> cv_return_value_bool;
        pub fn cv_CommandLineParser_check_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_CommandLineParser_about_String(instance: *mut c_void, message: *const c_char) -> cv_return_value_void;
        pub fn cv_CommandLineParser_printMessage_const(instance: *const c_void) -> cv_return_value_void;
        pub fn cv_CommandLineParser_printErrors_const(instance: *const c_void) -> cv_return_value_void;
        pub fn cv_ConjGradSolver_delete(ptr : *mut c_void);
        pub fn cv_ConjGradSolver_create_PtrOfFunction_TermCriteria(f: *mut c_void, termcrit: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_DMatch_DMatch() -> cv_return_value_DMatch;
        pub fn cv_DMatch_DMatch_int_int_float(_query_idx: i32, _train_idx: i32, _distance: f32) -> cv_return_value_DMatch;
        pub fn cv_DMatch_DMatch_int_int_int_float(_query_idx: i32, _train_idx: i32, _img_idx: i32, _distance: f32) -> cv_return_value_DMatch;
        pub fn cv_DownhillSolver_getInitStep_const__OutputArray(instance: *const c_void, step: *mut c_void) -> cv_return_value_void;
        pub fn cv_DownhillSolver_setInitStep__InputArray(instance: *mut c_void, step: *mut c_void) -> cv_return_value_void;
        pub fn cv_DownhillSolver_create_PtrOfFunction__InputArray_TermCriteria(f: *mut c_void, init_step: *mut c_void, termcrit: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_FileNode_delete(ptr : *mut c_void);
        pub fn cv_FileNode_FileNode() -> cv_return_value_void_X;
        pub fn cv_FileNode_FileNode_FileNode(node: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_FileNode_type_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_FileNode_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FileNode_isNone_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FileNode_isSeq_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FileNode_isMap_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FileNode_isInt_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FileNode_isReal_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FileNode_isString_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FileNode_isNamed_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FileNode_name_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_FileNode_size_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_FileNode_operator_int_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_FileNode_operator_float_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_FileNode_operator_double_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_FileNode_operator_String_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_FileNode_readRaw_const_String_uchar_X_size_t(instance: *const c_void, fmt: *const c_char, vec: *mut u8, len: size_t) -> cv_return_value_void;
        pub fn cv_FileNode_readObj_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_FileNode_real_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_FileNode_string_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_FileNode_mat_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_FileNodeIterator_delete(ptr : *mut c_void);
        pub fn cv_FileNodeIterator_readRaw_String_uchar_X_size_t(instance: *mut c_void, fmt: *const c_char, vec: *mut u8, max_count: size_t) -> cv_return_value_void_X;
        pub fn cv_FileNodeIterator_SeqReader_delete(ptr : *mut c_void);
        pub fn cv_FileStorage_delete(ptr : *mut c_void);
        pub fn cv_FileStorage_FileStorage() -> cv_return_value_void_X;
        pub fn cv_FileStorage_FileStorage_String_int_String(source: *const c_char, flags: i32, encoding: *const c_char) -> cv_return_value_void_X;
        pub fn cv_FileStorage_open_String_int_String(instance: *mut c_void, filename: *const c_char, flags: i32, encoding: *const c_char) -> cv_return_value_bool;
        pub fn cv_FileStorage_isOpened_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FileStorage_release(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_FileStorage_releaseAndGetString(instance: *mut c_void) -> cv_return_value_char_X;
        pub fn cv_FileStorage_getFirstTopLevelNode_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_FileStorage_root_const_int(instance: *const c_void, streamidx: i32) -> cv_return_value_void_X;
        pub fn cv_FileStorage_writeRaw_String_const_uchar_X_size_t(instance: *mut c_void, fmt: *const c_char, vec: *const u8, len: size_t) -> cv_return_value_void;
        pub fn cv_FileStorage_writeObj_String_const_void_X(instance: *mut c_void, name: *const c_char, obj: *const c_void) -> cv_return_value_void;
        pub fn cv_FileStorage_write_String_double(instance: *mut c_void, name: *const c_char, val: f64) -> cv_return_value_void;
        pub fn cv_FileStorage_write_String_String(instance: *mut c_void, name: *const c_char, val: *const c_char) -> cv_return_value_void;
        pub fn cv_FileStorage_write_String__InputArray(instance: *mut c_void, name: *const c_char, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_FileStorage_writeComment_String_bool(instance: *mut c_void, comment: *const c_char, append: bool) -> cv_return_value_void;
        pub fn cv_FileStorage_getDefaultObjectName_String(filename: *const c_char) -> cv_return_value_char_X;
        pub fn cv_Formatted_next(instance: *mut c_void) -> cv_return_value_const_char_X;
        pub fn cv_Formatted_reset(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_Formatter_format_const_Mat(instance: *const c_void, mtx: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Formatter_set32fPrecision_int(instance: *mut c_void, p: i32) -> cv_return_value_void;
        pub fn cv_Formatter_set64fPrecision_int(instance: *mut c_void, p: i32) -> cv_return_value_void;
        pub fn cv_Formatter_setMultiline_bool(instance: *mut c_void, ml: bool) -> cv_return_value_void;
        pub fn cv_Formatter_get_int(fmt: i32) -> cv_return_value_void_X;
        pub fn cv_Hamming_delete(ptr : *mut c_void);
        pub fn cv_KeyPoint_KeyPoint() -> cv_return_value_KeyPoint;
        pub fn cv_KeyPoint_KeyPoint_Point2f_float_float_float_int_int(_pt: core::Point2f, _size: f32, _angle: f32, _response: f32, _octave: i32, _class_id: i32) -> cv_return_value_KeyPoint;
        pub fn cv_KeyPoint_KeyPoint_float_float_float_float_float_int_int(x: f32, y: f32, _size: f32, _angle: f32, _response: f32, _octave: i32, _class_id: i32) -> cv_return_value_KeyPoint;
        pub fn cv_KeyPoint_hash_const(instance: core::KeyPoint) -> cv_return_value_std_size_t;
        pub fn cv_KeyPoint_convert_VectorOfKeyPoint_VectorOfPoint2f_VectorOfint(keypoints: *mut c_void, points2f: *mut c_void, keypoint_indexes: *mut c_void) -> cv_return_value_void;
        pub fn cv_KeyPoint_convert_VectorOfPoint2f_VectorOfKeyPoint_float_float_int_int(points2f: *mut c_void, keypoints: *mut c_void, size: f32, response: f32, octave: i32, class_id: i32) -> cv_return_value_void;
        pub fn cv_KeyPoint_overlap_KeyPoint_KeyPoint(kp1: core::KeyPoint, kp2: core::KeyPoint) -> cv_return_value_float;
        pub fn cv_LDA_delete(ptr : *mut c_void);
        pub fn cv_LDA_LDA_int(num_components: i32) -> cv_return_value_void_X;
        pub fn cv_LDA_LDA__InputArray__InputArray_int(src: *mut c_void, labels: *mut c_void, num_components: i32) -> cv_return_value_void_X;
        pub fn cv_LDA_save_const_String(instance: *const c_void, filename: *const c_char) -> cv_return_value_void;
        pub fn cv_LDA_load_String(instance: *mut c_void, filename: *const c_char) -> cv_return_value_void;
        pub fn cv_LDA_save_const_FileStorage(instance: *const c_void, fs: *mut c_void) -> cv_return_value_void;
        pub fn cv_LDA_load_FileStorage(instance: *mut c_void, node: *mut c_void) -> cv_return_value_void;
        pub fn cv_LDA_compute__InputArray__InputArray(instance: *mut c_void, src: *mut c_void, labels: *mut c_void) -> cv_return_value_void;
        pub fn cv_LDA_project__InputArray(instance: *mut c_void, src: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_LDA_reconstruct__InputArray(instance: *mut c_void, src: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_LDA_eigenvectors_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_LDA_eigenvalues_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_LDA_subspaceProject__InputArray__InputArray__InputArray(w: *mut c_void, mean: *mut c_void, src: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_LDA_subspaceReconstruct__InputArray__InputArray__InputArray(w: *mut c_void, mean: *mut c_void, src: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_delete(ptr : *mut c_void);
        pub fn cv_Mat_flags_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Mat_set_flags_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_Mat_dims_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Mat_set_dims_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_Mat_rows_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Mat_set_rows_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_Mat_cols_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Mat_set_cols_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_Mat_data(instance: *mut c_void) -> cv_return_value_unsigned_char_X;
        pub fn cv_Mat_set_data_uchar_X(instance: *mut c_void, val: *mut u8) -> cv_return_value_void;
        pub fn cv_Mat_datastart_const(instance: *const c_void) -> cv_return_value_const_unsigned_char_X;
        pub fn cv_Mat_dataend_const(instance: *const c_void) -> cv_return_value_const_unsigned_char_X;
        pub fn cv_Mat_datalimit_const(instance: *const c_void) -> cv_return_value_const_unsigned_char_X;
        pub fn cv_Mat_size_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_step_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat() -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_int_int_int(rows: i32, cols: i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_Size_int(size: core::Size, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_int_int_int_Scalar(rows: i32, cols: i32, _type: i32, s: core::Scalar) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_Size_int_Scalar(size: core::Size, _type: i32, s: core::Scalar) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_VectorOfint_int(sizes: *mut c_void, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_VectorOfint_int_Scalar(sizes: *mut c_void, _type: i32, s: core::Scalar) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_Mat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_int_int_int_void_X_size_t(rows: i32, cols: i32, _type: i32, data: *mut c_void, step: size_t) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_Size_int_void_X_size_t(size: core::Size, _type: i32, data: *mut c_void, step: size_t) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_VectorOfint_int_void_X_const_size_t_X(sizes: *mut c_void, _type: i32, data: *mut c_void, steps: *const size_t) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_Mat_Range_Range(m: *mut c_void, row_range: *mut c_void, col_range: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_Mat_Rect(m: *mut c_void, roi: core::Rect) -> cv_return_value_void_X;
        pub fn cv_Mat_Mat_Mat_VectorOfRange(m: *mut c_void, ranges: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_getUMat_const_int_UMatUsageFlags(instance: *const c_void, access_flags: i32, usage_flags: core::UMatUsageFlags) -> cv_return_value_void_X;
        pub fn cv_Mat_row_const_int(instance: *const c_void, y: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_col_const_int(instance: *const c_void, x: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_rowRange_const_int_int(instance: *const c_void, startrow: i32, endrow: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_rowRange_const_Range(instance: *const c_void, r: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_colRange_const_int_int(instance: *const c_void, startcol: i32, endcol: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_colRange_const_Range(instance: *const c_void, r: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_diag_const_int(instance: *const c_void, d: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_diag_Mat(d: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_clone_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_copyTo_const__OutputArray(instance: *const c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_Mat_copyTo_const__OutputArray__InputArray(instance: *const c_void, m: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_Mat_convertTo_const__OutputArray_int_double_double(instance: *const c_void, m: *mut c_void, rtype: i32, alpha: f64, beta: f64) -> cv_return_value_void;
        pub fn cv_Mat_assignTo_const_Mat_int(instance: *const c_void, m: *mut c_void, _type: i32) -> cv_return_value_void;
        pub fn cv_Mat_setTo__InputArray__InputArray(instance: *mut c_void, value: *mut c_void, mask: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_t_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_inv_const_int(instance: *const c_void, method: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_mul_const__InputArray_double(instance: *const c_void, m: *mut c_void, scale: f64) -> cv_return_value_void_X;
        pub fn cv_Mat_cross_const__InputArray(instance: *const c_void, m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Mat_dot_const__InputArray(instance: *const c_void, m: *mut c_void) -> cv_return_value_double;
        pub fn cv_Mat_zeros_int_int_int(rows: i32, cols: i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_zeros_Size_int(size: core::Size, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_zeros_int_const_int_X_int(ndims: i32, sz: *const i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_ones_int_int_int(rows: i32, cols: i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_ones_Size_int(size: core::Size, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_ones_int_const_int_X_int(ndims: i32, sz: *const i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_eye_int_int_int(rows: i32, cols: i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_eye_Size_int(size: core::Size, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_create_int_int_int(instance: *mut c_void, rows: i32, cols: i32, _type: i32) -> cv_return_value_void;
        pub fn cv_Mat_create_Size_int(instance: *mut c_void, size: core::Size, _type: i32) -> cv_return_value_void;
        pub fn cv_Mat_create_VectorOfint_int(instance: *mut c_void, sizes: *mut c_void, _type: i32) -> cv_return_value_void;
        pub fn cv_Mat_addref(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_Mat_release(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_Mat_deallocate(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_Mat_reserve_size_t(instance: *mut c_void, sz: size_t) -> cv_return_value_void;
        pub fn cv_Mat_resize_size_t(instance: *mut c_void, sz: size_t) -> cv_return_value_void;
        pub fn cv_Mat_resize_size_t_Scalar(instance: *mut c_void, sz: size_t, s: core::Scalar) -> cv_return_value_void;
        pub fn cv_Mat_push_back_Mat(instance: *mut c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_Mat_pop_back_size_t(instance: *mut c_void, nelems: size_t) -> cv_return_value_void;
        pub fn cv_Mat_locateROI_const_Size_Point(instance: *const c_void, whole_size: *mut core::Size, ofs: *mut core::Point) -> cv_return_value_void;
        pub fn cv_Mat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32) -> cv_return_value_void_X;
        pub fn cv_Mat_isContinuous_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_Mat_isSubmatrix_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_Mat_elemSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_Mat_elemSize1_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_Mat_type_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Mat_depth_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Mat_channels_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Mat_step1_const_int(instance: *const c_void, i: i32) -> cv_return_value_std_size_t;
        pub fn cv_Mat_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_Mat_total_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_Mat_checkVector_const_int_int_bool(instance: *const c_void, elem_channels: i32, depth: i32, require_continuous: bool) -> cv_return_value_int;
        pub fn cv_Mat_ptr_int(instance: *mut c_void, i0: i32) -> cv_return_value_unsigned_char_X;
        pub fn cv_Mat_ptr_const_int(instance: *const c_void, i0: i32) -> cv_return_value_const_unsigned_char_X;
        pub fn cv_Mat_ptr_int_int(instance: *mut c_void, row: i32, col: i32) -> cv_return_value_unsigned_char_X;
        pub fn cv_Mat_ptr_const_int_int(instance: *const c_void, row: i32, col: i32) -> cv_return_value_const_unsigned_char_X;
        pub fn cv_Mat_ptr_int_int_int(instance: *mut c_void, i0: i32, i1: i32, i2: i32) -> cv_return_value_unsigned_char_X;
        pub fn cv_Mat_ptr_const_int_int_int(instance: *const c_void, i0: i32, i1: i32, i2: i32) -> cv_return_value_const_unsigned_char_X;
        pub fn cv_Mat_ptr_const_int_X(instance: *mut c_void, idx: *const i32) -> cv_return_value_unsigned_char_X;
        pub fn cv_Mat_ptr_const_const_int_X(instance: *const c_void, idx: *const i32) -> cv_return_value_const_unsigned_char_X;
        pub fn cv_MatConstIterator_delete(ptr : *mut c_void);
        pub fn cv_MatConstIterator_MatConstIterator() -> cv_return_value_void_X;
        pub fn cv_MatConstIterator_MatConstIterator_const_Mat(_m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_MatConstIterator_MatConstIterator_const_Mat_int_int(_m: *mut c_void, _row: i32, _col: i32) -> cv_return_value_void_X;
        pub fn cv_MatConstIterator_MatConstIterator_const_Mat_Point(_m: *mut c_void, _pt: core::Point) -> cv_return_value_void_X;
        pub fn cv_MatConstIterator_MatConstIterator_MatConstIterator(it: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_MatConstIterator_pos_const(instance: *const c_void) -> cv_return_value_PointWrapper;
        pub fn cv_MatConstIterator_pos_const_int_X(instance: *const c_void, _idx: *mut i32) -> cv_return_value_void;
        pub fn cv_MatConstIterator_lpos_const(instance: *const c_void) -> cv_return_value_std_ptrdiff_t;
        pub fn cv_MatConstIterator_seek_ptrdiff_t_bool(instance: *mut c_void, ofs: ptrdiff_t, relative: bool) -> cv_return_value_void;
        pub fn cv_MatConstIterator_seek_const_int_X_bool(instance: *mut c_void, _idx: *const i32, relative: bool) -> cv_return_value_void;
        pub fn cv_MatExpr_delete(ptr : *mut c_void);
        pub fn cv_MatExpr_MatExpr() -> cv_return_value_void_X;
        pub fn cv_MatExpr_MatExpr_Mat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_MatExpr_MatExpr_const_MatOp_int_Mat_Mat_Mat_double_double_Scalar(_op: *mut c_void, _flags: i32, _a: *mut c_void, _b: *mut c_void, _c: *mut c_void, _alpha: f64, _beta: f64, _s: core::Scalar) -> cv_return_value_void_X;
        pub fn cv_MatExpr_operator_Mat_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_MatExpr_size_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_MatExpr_type_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_MatExpr_row_const_int(instance: *const c_void, y: i32) -> cv_return_value_void_X;
        pub fn cv_MatExpr_col_const_int(instance: *const c_void, x: i32) -> cv_return_value_void_X;
        pub fn cv_MatExpr_diag_const_int(instance: *const c_void, d: i32) -> cv_return_value_void_X;
        pub fn cv_MatExpr_t_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_MatExpr_inv_const_int(instance: *const c_void, method: i32) -> cv_return_value_void_X;
        pub fn cv_MatExpr_mul_const_MatExpr_double(instance: *const c_void, e: *mut c_void, scale: f64) -> cv_return_value_void_X;
        pub fn cv_MatExpr_mul_const_Mat_double(instance: *const c_void, m: *mut c_void, scale: f64) -> cv_return_value_void_X;
        pub fn cv_MatExpr_cross_const_Mat(instance: *const c_void, m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_MatExpr_dot_const_Mat(instance: *const c_void, m: *mut c_void) -> cv_return_value_double;
        pub fn cv_MatOp_elementWise_const_MatExpr(instance: *const c_void, expr: *mut c_void) -> cv_return_value_bool;
        pub fn cv_MatOp_assign_const_MatExpr_Mat_int(instance: *const c_void, expr: *mut c_void, m: *mut c_void, _type: i32) -> cv_return_value_void;
        pub fn cv_MatOp_roi_const_MatExpr_Range_Range_MatExpr(instance: *const c_void, expr: *mut c_void, row_range: *mut c_void, col_range: *mut c_void, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_diag_const_MatExpr_int_MatExpr(instance: *const c_void, expr: *mut c_void, d: i32, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_augAssignAdd_const_MatExpr_Mat(instance: *const c_void, expr: *mut c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_augAssignSubtract_const_MatExpr_Mat(instance: *const c_void, expr: *mut c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_augAssignMultiply_const_MatExpr_Mat(instance: *const c_void, expr: *mut c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_augAssignDivide_const_MatExpr_Mat(instance: *const c_void, expr: *mut c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_augAssignAnd_const_MatExpr_Mat(instance: *const c_void, expr: *mut c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_augAssignOr_const_MatExpr_Mat(instance: *const c_void, expr: *mut c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_augAssignXor_const_MatExpr_Mat(instance: *const c_void, expr: *mut c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_add_const_MatExpr_MatExpr_MatExpr(instance: *const c_void, expr1: *mut c_void, expr2: *mut c_void, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_add_const_MatExpr_Scalar_MatExpr(instance: *const c_void, expr1: *mut c_void, s: core::Scalar, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_subtract_const_MatExpr_MatExpr_MatExpr(instance: *const c_void, expr1: *mut c_void, expr2: *mut c_void, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_subtract_const_Scalar_MatExpr_MatExpr(instance: *const c_void, s: core::Scalar, expr: *mut c_void, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_multiply_const_MatExpr_MatExpr_MatExpr_double(instance: *const c_void, expr1: *mut c_void, expr2: *mut c_void, res: *mut c_void, scale: f64) -> cv_return_value_void;
        pub fn cv_MatOp_multiply_const_MatExpr_double_MatExpr(instance: *const c_void, expr1: *mut c_void, s: f64, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_divide_const_MatExpr_MatExpr_MatExpr_double(instance: *const c_void, expr1: *mut c_void, expr2: *mut c_void, res: *mut c_void, scale: f64) -> cv_return_value_void;
        pub fn cv_MatOp_divide_const_double_MatExpr_MatExpr(instance: *const c_void, s: f64, expr: *mut c_void, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_abs_const_MatExpr_MatExpr(instance: *const c_void, expr: *mut c_void, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_transpose_const_MatExpr_MatExpr(instance: *const c_void, expr: *mut c_void, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_matmul_const_MatExpr_MatExpr_MatExpr(instance: *const c_void, expr1: *mut c_void, expr2: *mut c_void, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_invert_const_MatExpr_int_MatExpr(instance: *const c_void, expr: *mut c_void, method: i32, res: *mut c_void) -> cv_return_value_void;
        pub fn cv_MatOp_size_const_MatExpr(instance: *const c_void, expr: *mut c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_MatOp_type_const_MatExpr(instance: *const c_void, expr: *mut c_void) -> cv_return_value_int;
        pub fn cv_MatSize_delete(ptr : *mut c_void);
        pub fn cv_MatSize_MatSize_int_X(_p: *mut i32) -> cv_return_value_void_X;
        pub fn cv_MatStep_delete(ptr : *mut c_void);
        pub fn cv_MatStep_MatStep() -> cv_return_value_void_X;
        pub fn cv_MatStep_MatStep_size_t(s: size_t) -> cv_return_value_void_X;
        pub fn cv_MatStep_operator_size_t_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_Matx_AddOp_delete(ptr : *mut c_void);
        pub fn cv_Matx_DivOp_delete(ptr : *mut c_void);
        pub fn cv_Matx_MatMulOp_delete(ptr : *mut c_void);
        pub fn cv_Matx_MulOp_delete(ptr : *mut c_void);
        pub fn cv_Matx_ScaleOp_delete(ptr : *mut c_void);
        pub fn cv_Matx_SubOp_delete(ptr : *mut c_void);
        pub fn cv_Matx_TOp_delete(ptr : *mut c_void);
        pub fn cv_MinProblemSolver_getFunction_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_MinProblemSolver_setFunction_PtrOfFunction(instance: *mut c_void, f: *mut c_void) -> cv_return_value_void;
        pub fn cv_MinProblemSolver_getTermCriteria_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_MinProblemSolver_setTermCriteria_TermCriteria(instance: *mut c_void, termcrit: *mut c_void) -> cv_return_value_void;
        pub fn cv_MinProblemSolver_minimize__InputOutputArray(instance: *mut c_void, x: *mut c_void) -> cv_return_value_double;
        pub fn cv_MinProblemSolver_Function_getDims_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_MinProblemSolver_Function_getGradientEps_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_MinProblemSolver_Function_calc_const_const_double_X(instance: *const c_void, x: *const f64) -> cv_return_value_double;
        pub fn cv_MinProblemSolver_Function_getGradient_const_double_X_double_X(instance: *mut c_void, x: *const f64, grad: *mut f64) -> cv_return_value_void;
        pub fn cv_Moments_Moments() -> cv_return_value_Moments;
        pub fn cv_Moments_Moments_double_double_double_double_double_double_double_double_double_double(m00: f64, m10: f64, m01: f64, m20: f64, m11: f64, m02: f64, m30: f64, m21: f64, m12: f64, m03: f64) -> cv_return_value_Moments;
        pub fn cv_NAryMatIterator_delete(ptr : *mut c_void);
        pub fn cv_NAryMatIterator_NAryMatIterator() -> cv_return_value_void_X;
        pub fn cv_PCA_delete(ptr : *mut c_void);
        pub fn cv_PCA_PCA() -> cv_return_value_void_X;
        pub fn cv_PCA_PCA__InputArray__InputArray_int_int(data: *mut c_void, mean: *mut c_void, flags: i32, max_components: i32) -> cv_return_value_void_X;
        pub fn cv_PCA_PCA__InputArray__InputArray_int_double(data: *mut c_void, mean: *mut c_void, flags: i32, retained_variance: f64) -> cv_return_value_void_X;
        pub fn cv_PCA_project_const__InputArray(instance: *const c_void, vec: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_PCA_project_const__InputArray__OutputArray(instance: *const c_void, vec: *mut c_void, result: *mut c_void) -> cv_return_value_void;
        pub fn cv_PCA_backProject_const__InputArray(instance: *const c_void, vec: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_PCA_backProject_const__InputArray__OutputArray(instance: *const c_void, vec: *mut c_void, result: *mut c_void) -> cv_return_value_void;
        pub fn cv_PCA_write_const_FileStorage(instance: *const c_void, fs: *mut c_void) -> cv_return_value_void;
        pub fn cv_PCA_read_FileNode(instance: *mut c_void, _fn: *mut c_void) -> cv_return_value_void;
        pub fn cv_Param_delete(ptr : *mut c_void);
        pub fn cv_Range_delete(ptr : *mut c_void);
        pub fn cv_Range_start_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Range_set_start_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_Range_end_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Range_set_end_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_Range_Range() -> cv_return_value_void_X;
        pub fn cv_Range_Range_int_int(_start: i32, _end: i32) -> cv_return_value_void_X;
        pub fn cv_Range_size_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Range_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_Range_all() -> cv_return_value_void_X;
        pub fn cv_RotatedRect_delete(ptr : *mut c_void);
        pub fn cv_RotatedRect_center_const(instance: *const c_void) -> cv_return_value_Point2fWrapper;
        pub fn cv_RotatedRect_set_center_Point2f(instance: *mut c_void, val: core::Point2f) -> cv_return_value_void;
        pub fn cv_RotatedRect_size_const(instance: *const c_void) -> cv_return_value_Size2fWrapper;
        pub fn cv_RotatedRect_set_size_Size2f(instance: *mut c_void, val: core::Size2f) -> cv_return_value_void;
        pub fn cv_RotatedRect_angle_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_RotatedRect_set_angle_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_RotatedRect_RotatedRect() -> cv_return_value_void_X;
        pub fn cv_RotatedRect_RotatedRect_Point2f_Size2f_float(center: core::Point2f, size: core::Size2f, angle: f32) -> cv_return_value_void_X;
        pub fn cv_RotatedRect_RotatedRect_Point2f_Point2f_Point2f(point1: core::Point2f, point2: core::Point2f, point3: core::Point2f) -> cv_return_value_void_X;
        pub fn cv_RotatedRect_points_const_Point2f_X(instance: *const c_void, pts: *mut core::Point2f) -> cv_return_value_void;
        pub fn cv_RotatedRect_boundingRect_const(instance: *const c_void) -> cv_return_value_RectWrapper;
        pub fn cv_RotatedRect_boundingRect2f_const(instance: *const c_void) -> cv_return_value_Rect2fWrapper;
        pub fn cv_SparseMat_delete(ptr : *mut c_void);
        pub fn cv_SparseMat_SparseMat() -> cv_return_value_void_X;
        pub fn cv_SparseMat_SparseMat_int_const_int_X_int(dims: i32, _sizes: *const i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_SparseMat_SparseMat_SparseMat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_SparseMat_SparseMat_Mat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_SparseMat_clone_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_SparseMat_copyTo_const_SparseMat(instance: *const c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_SparseMat_copyTo_const_Mat(instance: *const c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_SparseMat_convertTo_const_SparseMat_int_double(instance: *const c_void, m: *mut c_void, rtype: i32, alpha: f64) -> cv_return_value_void;
        pub fn cv_SparseMat_convertTo_const_Mat_int_double_double(instance: *const c_void, m: *mut c_void, rtype: i32, alpha: f64, beta: f64) -> cv_return_value_void;
        pub fn cv_SparseMat_assignTo_const_SparseMat_int(instance: *const c_void, m: *mut c_void, _type: i32) -> cv_return_value_void;
        pub fn cv_SparseMat_create_int_const_int_X_int(instance: *mut c_void, dims: i32, _sizes: *const i32, _type: i32) -> cv_return_value_void;
        pub fn cv_SparseMat_clear(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_SparseMat_addref(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_SparseMat_release(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_SparseMat_elemSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_SparseMat_elemSize1_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_SparseMat_type_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_SparseMat_depth_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_SparseMat_channels_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_SparseMat_size_const(instance: *const c_void) -> cv_return_value_const_int_X;
        pub fn cv_SparseMat_size_const_int(instance: *const c_void, i: i32) -> cv_return_value_int;
        pub fn cv_SparseMat_dims_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_SparseMat_nzcount_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_SparseMat_hash_const_int(instance: *const c_void, i0: i32) -> cv_return_value_std_size_t;
        pub fn cv_SparseMat_hash_const_int_int(instance: *const c_void, i0: i32, i1: i32) -> cv_return_value_std_size_t;
        pub fn cv_SparseMat_hash_const_int_int_int(instance: *const c_void, i0: i32, i1: i32, i2: i32) -> cv_return_value_std_size_t;
        pub fn cv_SparseMat_hash_const_const_int_X(instance: *const c_void, idx: *const i32) -> cv_return_value_std_size_t;
        pub fn cv_SparseMat_ptr_int_bool_size_t_X(instance: *mut c_void, i0: i32, create_missing: bool, hashval: *mut size_t) -> cv_return_value_unsigned_char_X;
        pub fn cv_SparseMat_ptr_int_int_bool_size_t_X(instance: *mut c_void, i0: i32, i1: i32, create_missing: bool, hashval: *mut size_t) -> cv_return_value_unsigned_char_X;
        pub fn cv_SparseMat_ptr_int_int_int_bool_size_t_X(instance: *mut c_void, i0: i32, i1: i32, i2: i32, create_missing: bool, hashval: *mut size_t) -> cv_return_value_unsigned_char_X;
        pub fn cv_SparseMat_ptr_const_int_X_bool_size_t_X(instance: *mut c_void, idx: *const i32, create_missing: bool, hashval: *mut size_t) -> cv_return_value_unsigned_char_X;
        pub fn cv_SparseMat_erase_int_int_size_t_X(instance: *mut c_void, i0: i32, i1: i32, hashval: *mut size_t) -> cv_return_value_void;
        pub fn cv_SparseMat_erase_int_int_int_size_t_X(instance: *mut c_void, i0: i32, i1: i32, i2: i32, hashval: *mut size_t) -> cv_return_value_void;
        pub fn cv_SparseMat_erase_const_int_X_size_t_X(instance: *mut c_void, idx: *const i32, hashval: *mut size_t) -> cv_return_value_void;
        pub fn cv_SparseMat_node_size_t(instance: *mut c_void, nidx: size_t) -> cv_return_value_void_X;
        pub fn cv_SparseMat_node_const_size_t(instance: *const c_void, nidx: size_t) -> cv_return_value_const_void_X;
        pub fn cv_SparseMat_newNode_const_int_X_size_t(instance: *mut c_void, idx: *const i32, hashval: size_t) -> cv_return_value_unsigned_char_X;
        pub fn cv_SparseMat_removeNode_size_t_size_t_size_t(instance: *mut c_void, hidx: size_t, nidx: size_t, previdx: size_t) -> cv_return_value_void;
        pub fn cv_SparseMat_resizeHashTab_size_t(instance: *mut c_void, newsize: size_t) -> cv_return_value_void;
        pub fn cv_SparseMat_Hdr_delete(ptr : *mut c_void);
        pub fn cv_SparseMat_Hdr_Hdr_int_const_int_X_int(_dims: i32, _sizes: *const i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_SparseMat_Hdr_clear(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_SparseMat_Node_delete(ptr : *mut c_void);
        pub fn cv_SparseMatConstIterator_node_const(instance: *const c_void) -> cv_return_value_const_void_X;
        pub fn cv_SparseMatConstIterator_seekEnd(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_SparseMatConstIterator_delete(ptr : *mut c_void);
        pub fn cv_SparseMatIterator_delete(ptr : *mut c_void);
        pub fn cv_SparseMatIterator_node_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_TermCriteria_delete(ptr : *mut c_void);
        pub fn cv_TermCriteria_type_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_TermCriteria_set_type_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_TermCriteria_maxCount_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_TermCriteria_set_maxCount_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_TermCriteria_epsilon_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_TermCriteria_set_epsilon_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_TermCriteria_TermCriteria() -> cv_return_value_void_X;
        pub fn cv_TermCriteria_TermCriteria_int_int_double(_type: i32, max_count: i32, epsilon: f64) -> cv_return_value_void_X;
        pub fn cv_TickMeter_delete(ptr : *mut c_void);
        pub fn cv_TickMeter_TickMeter() -> cv_return_value_void_X;
        pub fn cv_TickMeter_start(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_TickMeter_stop(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_TickMeter_getTimeTicks_const(instance: *const c_void) -> cv_return_value_int64;
        pub fn cv_TickMeter_getTimeMicro_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_TickMeter_getTimeMilli_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_TickMeter_getTimeSec_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_TickMeter_getCounter_const(instance: *const c_void) -> cv_return_value_int64;
        pub fn cv_TickMeter_reset(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_UMat_delete(ptr : *mut c_void);
        pub fn cv_UMat_flags_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_UMat_set_flags_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_UMat_dims_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_UMat_set_dims_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_UMat_rows_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_UMat_set_rows_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_UMat_cols_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_UMat_set_cols_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_UMat_usageFlags_const(instance: *const c_void) -> cv_return_value_UMatUsageFlags;
        pub fn cv_UMat_set_usageFlags_UMatUsageFlags(instance: *mut c_void, val: core::UMatUsageFlags) -> cv_return_value_void;
        pub fn cv_UMat_offset_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_UMat_set_offset_size_t(instance: *mut c_void, val: size_t) -> cv_return_value_void;
        pub fn cv_UMat_size_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_UMat_step_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_UMat_UMat_UMatUsageFlags(usage_flags: core::UMatUsageFlags) -> cv_return_value_void_X;
        pub fn cv_UMat_UMat_int_int_int_UMatUsageFlags(rows: i32, cols: i32, _type: i32, usage_flags: core::UMatUsageFlags) -> cv_return_value_void_X;
        pub fn cv_UMat_UMat_Size_int_UMatUsageFlags(size: core::Size, _type: i32, usage_flags: core::UMatUsageFlags) -> cv_return_value_void_X;
        pub fn cv_UMat_UMat_int_int_int_Scalar_UMatUsageFlags(rows: i32, cols: i32, _type: i32, s: core::Scalar, usage_flags: core::UMatUsageFlags) -> cv_return_value_void_X;
        pub fn cv_UMat_UMat_Size_int_Scalar_UMatUsageFlags(size: core::Size, _type: i32, s: core::Scalar, usage_flags: core::UMatUsageFlags) -> cv_return_value_void_X;
        pub fn cv_UMat_UMat_int_const_int_X_int_UMatUsageFlags(ndims: i32, sizes: *const i32, _type: i32, usage_flags: core::UMatUsageFlags) -> cv_return_value_void_X;
        pub fn cv_UMat_UMat_int_const_int_X_int_Scalar_UMatUsageFlags(ndims: i32, sizes: *const i32, _type: i32, s: core::Scalar, usage_flags: core::UMatUsageFlags) -> cv_return_value_void_X;
        pub fn cv_UMat_UMat_UMat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_UMat_UMat_UMat_Range_Range(m: *mut c_void, row_range: *mut c_void, col_range: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_UMat_UMat_UMat_Rect(m: *mut c_void, roi: core::Rect) -> cv_return_value_void_X;
        pub fn cv_UMat_UMat_UMat_VectorOfRange(m: *mut c_void, ranges: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_UMat_getMat_const_int(instance: *const c_void, flags: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_row_const_int(instance: *const c_void, y: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_col_const_int(instance: *const c_void, x: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_rowRange_const_int_int(instance: *const c_void, startrow: i32, endrow: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_rowRange_const_Range(instance: *const c_void, r: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_UMat_colRange_const_int_int(instance: *const c_void, startcol: i32, endcol: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_colRange_const_Range(instance: *const c_void, r: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_UMat_diag_const_int(instance: *const c_void, d: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_diag_UMat(d: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_UMat_clone_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_UMat_copyTo_const__OutputArray(instance: *const c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv_UMat_copyTo_const__OutputArray__InputArray(instance: *const c_void, m: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_UMat_convertTo_const__OutputArray_int_double_double(instance: *const c_void, m: *mut c_void, rtype: i32, alpha: f64, beta: f64) -> cv_return_value_void;
        pub fn cv_UMat_assignTo_const_UMat_int(instance: *const c_void, m: *mut c_void, _type: i32) -> cv_return_value_void;
        pub fn cv_UMat_setTo__InputArray__InputArray(instance: *mut c_void, value: *mut c_void, mask: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_UMat_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_reshape_const_int_int_const_int_X(instance: *const c_void, cn: i32, newndims: i32, newsz: *const i32) -> cv_return_value_void_X;
        pub fn cv_UMat_t_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_UMat_inv_const_int(instance: *const c_void, method: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_mul_const__InputArray_double(instance: *const c_void, m: *mut c_void, scale: f64) -> cv_return_value_void_X;
        pub fn cv_UMat_dot_const__InputArray(instance: *const c_void, m: *mut c_void) -> cv_return_value_double;
        pub fn cv_UMat_zeros_int_int_int(rows: i32, cols: i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_zeros_Size_int(size: core::Size, _type: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_zeros_int_const_int_X_int(ndims: i32, sz: *const i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_ones_int_int_int(rows: i32, cols: i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_ones_Size_int(size: core::Size, _type: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_ones_int_const_int_X_int(ndims: i32, sz: *const i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_eye_int_int_int(rows: i32, cols: i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_eye_Size_int(size: core::Size, _type: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_create_int_int_int_UMatUsageFlags(instance: *mut c_void, rows: i32, cols: i32, _type: i32, usage_flags: core::UMatUsageFlags) -> cv_return_value_void;
        pub fn cv_UMat_create_Size_int_UMatUsageFlags(instance: *mut c_void, size: core::Size, _type: i32, usage_flags: core::UMatUsageFlags) -> cv_return_value_void;
        pub fn cv_UMat_create_VectorOfint_int_UMatUsageFlags(instance: *mut c_void, sizes: *mut c_void, _type: i32, usage_flags: core::UMatUsageFlags) -> cv_return_value_void;
        pub fn cv_UMat_addref(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_UMat_release(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_UMat_deallocate(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_UMat_locateROI_const_Size_Point(instance: *const c_void, whole_size: *mut core::Size, ofs: *mut core::Point) -> cv_return_value_void;
        pub fn cv_UMat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_isContinuous_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_UMat_isSubmatrix_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_UMat_elemSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_UMat_elemSize1_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_UMat_type_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_UMat_depth_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_UMat_channels_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_UMat_step1_const_int(instance: *const c_void, i: i32) -> cv_return_value_std_size_t;
        pub fn cv_UMat_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_UMat_total_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_UMat_checkVector_const_int_int_bool(instance: *const c_void, elem_channels: i32, depth: i32, require_continuous: bool) -> cv_return_value_int;
        pub fn cv_UMat_handle_const_int(instance: *const c_void, access_flags: i32) -> cv_return_value_void_X;
        pub fn cv_UMat_ndoffset_const_size_t_X(instance: *const c_void, ofs: *mut size_t) -> cv_return_value_void;
        pub fn cv_UMatData_delete(ptr : *mut c_void);
        pub fn cv_UMatData_lock(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_UMatData_unlock(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_UMatData_hostCopyObsolete_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_UMatData_deviceCopyObsolete_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_UMatData_deviceMemMapped_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_UMatData_copyOnMap_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_UMatData_tempUMat_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_UMatData_tempCopiedUMat_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_UMatData_markHostCopyObsolete_bool(instance: *mut c_void, flag: bool) -> cv_return_value_void;
        pub fn cv_UMatData_markDeviceCopyObsolete_bool(instance: *mut c_void, flag: bool) -> cv_return_value_void;
        pub fn cv_UMatData_markDeviceMemMapped_bool(instance: *mut c_void, flag: bool) -> cv_return_value_void;
        pub fn cv_UMatDataAutoLock_delete(ptr : *mut c_void);
        pub fn cv__InputArray_getMat_const_int(instance: *const c_void, idx: i32) -> cv_return_value_void_X;
        pub fn cv__InputArray_getMat__const_int(instance: *const c_void, idx: i32) -> cv_return_value_void_X;
        pub fn cv__InputArray_getUMat_const_int(instance: *const c_void, idx: i32) -> cv_return_value_void_X;
        pub fn cv__InputArray_getMatVector_const_VectorOfMat(instance: *const c_void, mv: *mut c_void) -> cv_return_value_void;
        pub fn cv__InputArray_getUMatVector_const_VectorOfUMat(instance: *const c_void, umv: *mut c_void) -> cv_return_value_void;
        pub fn cv__InputArray_getFlags_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv__InputArray_getObj_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv__InputArray_getSz_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv__InputArray_kind_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv__InputArray_dims_const_int(instance: *const c_void, i: i32) -> cv_return_value_int;
        pub fn cv__InputArray_cols_const_int(instance: *const c_void, i: i32) -> cv_return_value_int;
        pub fn cv__InputArray_rows_const_int(instance: *const c_void, i: i32) -> cv_return_value_int;
        pub fn cv__InputArray_size_const_int(instance: *const c_void, i: i32) -> cv_return_value_SizeWrapper;
        pub fn cv__InputArray_sizend_const_int_X_int(instance: *const c_void, sz: *mut i32, i: i32) -> cv_return_value_int;
        pub fn cv__InputArray_sameSize_const__InputArray(instance: *const c_void, arr: *mut c_void) -> cv_return_value_bool;
        pub fn cv__InputArray_total_const_int(instance: *const c_void, i: i32) -> cv_return_value_std_size_t;
        pub fn cv__InputArray_type_const_int(instance: *const c_void, i: i32) -> cv_return_value_int;
        pub fn cv__InputArray_depth_const_int(instance: *const c_void, i: i32) -> cv_return_value_int;
        pub fn cv__InputArray_channels_const_int(instance: *const c_void, i: i32) -> cv_return_value_int;
        pub fn cv__InputArray_isContinuous_const_int(instance: *const c_void, i: i32) -> cv_return_value_bool;
        pub fn cv__InputArray_isSubmatrix_const_int(instance: *const c_void, i: i32) -> cv_return_value_bool;
        pub fn cv__InputArray_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv__InputArray_copyTo_const__OutputArray(instance: *const c_void, arr: *mut c_void) -> cv_return_value_void;
        pub fn cv__InputArray_copyTo_const__OutputArray__InputArray(instance: *const c_void, arr: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv__InputArray_offset_const_int(instance: *const c_void, i: i32) -> cv_return_value_std_size_t;
        pub fn cv__InputArray_step_const_int(instance: *const c_void, i: i32) -> cv_return_value_std_size_t;
        pub fn cv__InputArray_isMat_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv__InputArray_isUMat_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv__InputArray_isMatVector_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv__InputArray_isUMatVector_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv__InputArray_isMatx_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv__InputArray_isVector_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv__InputArray_isGpuMatVector_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv__InputArray_delete(ptr : *mut c_void);
        pub fn cv__InputArray__InputArray() -> cv_return_value_void_X;
        pub fn cv__InputArray__InputArray_int_void_X(_flags: i32, _obj: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputArray__InputArray_Mat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputArray__InputArray_MatExpr(expr: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputArray__InputArray_VectorOfMat(vec: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputArray__InputArray_VectorOfbool(vec: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputArray__InputArray_double(val: *const f64) -> cv_return_value_void_X;
        pub fn cv__InputArray__InputArray_UMat(um: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputArray__InputArray_VectorOfUMat(umv: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputOutputArray_delete(ptr : *mut c_void);
        pub fn cv__InputOutputArray__InputOutputArray() -> cv_return_value_void_X;
        pub fn cv__InputOutputArray__InputOutputArray_int_void_X(_flags: i32, _obj: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputOutputArray__InputOutputArray_Mat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputOutputArray__InputOutputArray_VectorOfMat(vec: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputOutputArray__InputOutputArray_VectorOfbool(vec: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputOutputArray__InputOutputArray_UMat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__InputOutputArray__InputOutputArray_VectorOfUMat(vec: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__OutputArray_fixedSize_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv__OutputArray_fixedType_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv__OutputArray_needed_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv__OutputArray_getMatRef_const_int(instance: *const c_void, i: i32) -> cv_return_value_void_X;
        pub fn cv__OutputArray_getUMatRef_const_int(instance: *const c_void, i: i32) -> cv_return_value_void_X;
        pub fn cv__OutputArray_create_const_Size_int_int_bool_int(instance: *const c_void, sz: core::Size, _type: i32, i: i32, allow_transposed: bool, fixed_depth_mask: i32) -> cv_return_value_void;
        pub fn cv__OutputArray_create_const_int_int_int_int_bool_int(instance: *const c_void, rows: i32, cols: i32, _type: i32, i: i32, allow_transposed: bool, fixed_depth_mask: i32) -> cv_return_value_void;
        pub fn cv__OutputArray_create_const_int_const_int_X_int_int_bool_int(instance: *const c_void, dims: i32, size: *const i32, _type: i32, i: i32, allow_transposed: bool, fixed_depth_mask: i32) -> cv_return_value_void;
        pub fn cv__OutputArray_createSameSize_const__InputArray_int(instance: *const c_void, arr: *mut c_void, mtype: i32) -> cv_return_value_void;
        pub fn cv__OutputArray_release_const(instance: *const c_void) -> cv_return_value_void;
        pub fn cv__OutputArray_clear_const(instance: *const c_void) -> cv_return_value_void;
        pub fn cv__OutputArray_setTo_const__InputArray__InputArray(instance: *const c_void, value: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv__OutputArray_assign_const_UMat(instance: *const c_void, u: *mut c_void) -> cv_return_value_void;
        pub fn cv__OutputArray_assign_const_Mat(instance: *const c_void, m: *mut c_void) -> cv_return_value_void;
        pub fn cv__OutputArray_delete(ptr : *mut c_void);
        pub fn cv__OutputArray__OutputArray() -> cv_return_value_void_X;
        pub fn cv__OutputArray__OutputArray_int_void_X(_flags: i32, _obj: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__OutputArray__OutputArray_Mat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__OutputArray__OutputArray_VectorOfMat(vec: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__OutputArray__OutputArray_VectorOfbool(vec: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__OutputArray__OutputArray_UMat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv__OutputArray__OutputArray_VectorOfUMat(vec: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_NodeData_delete(ptr : *mut c_void);
        pub fn cv_instr_NodeData_NodeData_const_char_X_const_char_X_int_void_X_bool_TYPE_IMPL(fun_name: *const c_char, file_name: *const c_char, line_num: i32, ret_address: *mut c_void, always_expand: bool, instr_type: core::TYPE, impl_type: core::IMPL) -> cv_return_value_void_X;
        pub fn cv_instr_NodeData_NodeData_NodeData(_ref: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_instr_NodeData_getTotalMs_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_instr_NodeData_getMeanMs_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_NodeDataTls_delete(ptr : *mut c_void);
        pub fn cv_instr_NodeDataTls_NodeDataTls() -> cv_return_value_void_X;
        pub fn cv_WriteStructContext_delete(ptr : *mut c_void);
        pub fn cv_internal_WriteStructContext_WriteStructContext_FileStorage_String_int_String(_fs: *mut c_void, name: *const c_char, flags: i32, type_name: *const c_char) -> cv_return_value_void_X;
        pub fn cv_Context_delete(ptr : *mut c_void);
        pub fn cv_ocl_Context_Context() -> cv_return_value_void_X;
        pub fn cv_ocl_Context_Context_int(dtype: i32) -> cv_return_value_void_X;
        pub fn cv_ocl_Context_Context_Context(c: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Context_create(instance: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Context_create_int(instance: *mut c_void, dtype: i32) -> cv_return_value_bool;
        pub fn cv_ocl_Context_ndevices_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Context_device_const_size_t(instance: *const c_void, idx: size_t) -> cv_return_value_void_X;
        pub fn cv_ocl_Context_ptr_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Context_useSVM_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Context_setUseSVM_bool(instance: *mut c_void, enabled: bool) -> cv_return_value_void;
        pub fn cv_Device_delete(ptr : *mut c_void);
        pub fn cv_ocl_Device_Device() -> cv_return_value_void_X;
        pub fn cv_ocl_Device_Device_void_X(d: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Device_Device_Device(d: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Device_set_void_X(instance: *mut c_void, d: *mut c_void) -> cv_return_value_void;
        pub fn cv_ocl_Device_name_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_ocl_Device_extensions_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_ocl_Device_version_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_ocl_Device_vendorName_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_ocl_Device_OpenCL_C_Version_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_ocl_Device_OpenCLVersion_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_ocl_Device_deviceVersionMajor_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_deviceVersionMinor_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_driverVersion_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_ocl_Device_ptr_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Device_type_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_addressBits_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_available_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Device_compilerAvailable_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Device_linkerAvailable_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Device_doubleFPConfig_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_singleFPConfig_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_halfFPConfig_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_endianLittle_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Device_errorCorrectionSupport_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Device_executionCapabilities_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_globalMemCacheSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_globalMemCacheType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_globalMemCacheLineSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_globalMemSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_localMemSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_localMemType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_hostUnifiedMemory_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Device_imageSupport_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Device_imageFromBufferSupport_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Device_imagePitchAlignment_const(instance: *const c_void) -> cv_return_value_unsigned_int;
        pub fn cv_ocl_Device_imageBaseAddressAlignment_const(instance: *const c_void) -> cv_return_value_unsigned_int;
        pub fn cv_ocl_Device_image2DMaxWidth_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_image2DMaxHeight_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_image3DMaxWidth_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_image3DMaxHeight_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_image3DMaxDepth_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_imageMaxBufferSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_imageMaxArraySize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_vendorID_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_isAMD_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Device_isIntel_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Device_isNVidia_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Device_maxClockFrequency_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_maxComputeUnits_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_maxConstantArgs_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_maxConstantBufferSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_maxMemAllocSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_maxParameterSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_maxReadImageArgs_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_maxWriteImageArgs_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_maxSamplers_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_maxWorkGroupSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_maxWorkItemDims_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_maxWorkItemSizes_const_size_t_X(instance: *const c_void, unnamed_arg: *mut size_t) -> cv_return_value_void;
        pub fn cv_ocl_Device_memBaseAddrAlign_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_nativeVectorWidthChar_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_nativeVectorWidthShort_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_nativeVectorWidthInt_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_nativeVectorWidthLong_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_nativeVectorWidthFloat_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_nativeVectorWidthDouble_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_nativeVectorWidthHalf_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_preferredVectorWidthChar_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_preferredVectorWidthShort_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_preferredVectorWidthInt_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_preferredVectorWidthLong_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_preferredVectorWidthFloat_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_preferredVectorWidthDouble_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_preferredVectorWidthHalf_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_Device_printfBufferSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_profilingTimerResolution_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Device_getDefault() -> cv_return_value_void_X;
        pub fn cv_Image2D_delete(ptr : *mut c_void);
        pub fn cv_ocl_Image2D_Image2D() -> cv_return_value_void_X;
        pub fn cv_ocl_Image2D_Image2D_UMat_bool_bool(src: *mut c_void, norm: bool, alias: bool) -> cv_return_value_void_X;
        pub fn cv_ocl_Image2D_Image2D_Image2D(i: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Image2D_canCreateAlias_UMat(u: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Image2D_isFormatSupported_int_int_bool(depth: i32, cn: i32, norm: bool) -> cv_return_value_bool;
        pub fn cv_ocl_Image2D_ptr_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_Kernel_delete(ptr : *mut c_void);
        pub fn cv_ocl_Kernel_Kernel() -> cv_return_value_void_X;
        pub fn cv_ocl_Kernel_Kernel_Kernel(k: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Kernel_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Kernel_set_int_const_void_X_size_t(instance: *mut c_void, i: i32, value: *const c_void, sz: size_t) -> cv_return_value_int;
        pub fn cv_ocl_Kernel_set_int_UMat(instance: *mut c_void, i: i32, m: *mut c_void) -> cv_return_value_int;
        pub fn cv_ocl_Kernel_set_int_KernelArg(instance: *mut c_void, i: i32, arg: *mut c_void) -> cv_return_value_int;
        pub fn cv_ocl_Kernel_run_int_size_t_X_size_t_X_bool_Queue(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, q: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Kernel_runTask_bool_Queue(instance: *mut c_void, sync: bool, q: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Kernel_workGroupSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Kernel_preferedWorkGroupSizeMultiple_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Kernel_compileWorkGroupSize_const_size_t_X(instance: *const c_void, wsz: *mut size_t) -> cv_return_value_bool;
        pub fn cv_ocl_Kernel_localMemSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_ocl_Kernel_ptr_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_KernelArg_delete(ptr : *mut c_void);
        pub fn cv_ocl_KernelArg_KernelArg_int_UMat_int_int_const_void_X_size_t(_flags: i32, _m: *mut c_void, wscale: i32, iwscale: i32, _obj: *const c_void, _sz: size_t) -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_KernelArg() -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_Local() -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_PtrWriteOnly_UMat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_PtrReadOnly_UMat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_PtrReadWrite_UMat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_ReadWrite_UMat_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_ReadWriteNoSize_UMat_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_ReadOnly_UMat_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_WriteOnly_UMat_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_ReadOnlyNoSize_UMat_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_WriteOnlyNoSize_UMat_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> cv_return_value_void_X;
        pub fn cv_ocl_KernelArg_Constant_Mat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Platform_delete(ptr : *mut c_void);
        pub fn cv_ocl_Platform_Platform() -> cv_return_value_void_X;
        pub fn cv_ocl_Platform_Platform_Platform(p: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Platform_ptr_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Platform_getDefault() -> cv_return_value_void_X;
        pub fn cv_PlatformInfo_delete(ptr : *mut c_void);
        pub fn cv_ocl_PlatformInfo_PlatformInfo() -> cv_return_value_void_X;
        pub fn cv_ocl_PlatformInfo_PlatformInfo_void_X(id: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_PlatformInfo_PlatformInfo_PlatformInfo(i: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_PlatformInfo_name_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_ocl_PlatformInfo_vendor_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_ocl_PlatformInfo_version_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_ocl_PlatformInfo_deviceNumber_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ocl_PlatformInfo_getDevice_const_Device_int(instance: *const c_void, device: *mut c_void, d: i32) -> cv_return_value_void;
        pub fn cv_Program_delete(ptr : *mut c_void);
        pub fn cv_ocl_Program_read_String_String(instance: *mut c_void, buf: *const c_char, buildflags: *const c_char) -> cv_return_value_bool;
        pub fn cv_ocl_Program_write_const_String(instance: *const c_void, buf: *mut *mut c_char) -> cv_return_value_bool;
        pub fn cv_ocl_Program_ptr_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Program_getPrefix_const(instance: *const c_void) -> cv_return_value_char_X;
        pub fn cv_ocl_Program_getPrefix_String(buildflags: *const c_char) -> cv_return_value_char_X;
        pub fn cv_ProgramEntry_delete(ptr : *mut c_void);
        pub fn cv_ProgramSource_delete(ptr : *mut c_void);
        pub fn cv_ocl_ProgramSource_ProgramSource() -> cv_return_value_void_X;
        pub fn cv_ocl_ProgramSource_ProgramSource_String(prog: *const c_char) -> cv_return_value_void_X;
        pub fn cv_ocl_ProgramSource_source_const(instance: *const c_void) -> cv_return_value_const_char_X;
        pub fn cv_ocl_ProgramSource_hash_const(instance: *const c_void) -> cv_return_value_uint64;
        pub fn cv_Queue_delete(ptr : *mut c_void);
        pub fn cv_ocl_Queue_Queue() -> cv_return_value_void_X;
        pub fn cv_ocl_Queue_Queue_Context_Device(c: *mut c_void, d: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Queue_Queue_Queue(q: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Queue_create_Context_Device(instance: *mut c_void, c: *mut c_void, d: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ocl_Queue_finish(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_ocl_Queue_ptr_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ocl_Queue_getDefault() -> cv_return_value_void_X;
    
    }
}
pub use core_sys::*;

#[cfg(feature = "contrib")]
mod aruco_sys {
    use super::*;

    extern "C" {
        pub fn cv_aruco__drawPlanarBoardImpl_Board_Size__OutputArray_int_int(board: *mut c_void, out_size: core::Size, img: *mut c_void, margin_size: i32, border_bits: i32) -> cv_return_value_void;
        pub fn cv_aruco_calibrateCameraAruco__InputArray__InputArray__InputArray_PtrOfBoard_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria(corners: *mut c_void, ids: *mut c_void, counter: *mut c_void, board: *mut c_void, image_size: core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, std_deviations_intrinsics: *mut c_void, std_deviations_extrinsics: *mut c_void, per_view_errors: *mut c_void, flags: i32, criteria: *mut c_void) -> cv_return_value_double;
        pub fn cv_aruco_calibrateCameraAruco__InputArray__InputArray__InputArray_PtrOfBoard_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray_int_TermCriteria(corners: *mut c_void, ids: *mut c_void, counter: *mut c_void, board: *mut c_void, image_size: core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void) -> cv_return_value_double;
        pub fn cv_aruco_calibrateCameraCharuco__InputArray__InputArray_PtrOfCharucoBoard_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria(charuco_corners: *mut c_void, charuco_ids: *mut c_void, board: *mut c_void, image_size: core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, std_deviations_intrinsics: *mut c_void, std_deviations_extrinsics: *mut c_void, per_view_errors: *mut c_void, flags: i32, criteria: *mut c_void) -> cv_return_value_double;
        pub fn cv_aruco_calibrateCameraCharuco__InputArray__InputArray_PtrOfCharucoBoard_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray_int_TermCriteria(charuco_corners: *mut c_void, charuco_ids: *mut c_void, board: *mut c_void, image_size: core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void) -> cv_return_value_double;
        pub fn cv_aruco_detectCharucoDiamond__InputArray__InputArray__InputArray_float__OutputArray__OutputArray__InputArray__InputArray(image: *mut c_void, marker_corners: *mut c_void, marker_ids: *mut c_void, square_marker_length_rate: f32, diamond_corners: *mut c_void, diamond_ids: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void) -> cv_return_value_void;
        pub fn cv_aruco_detectMarkers__InputArray_PtrOfDictionary__OutputArray__OutputArray_PtrOfDetectorParameters__OutputArray(image: *mut c_void, dictionary: *mut c_void, corners: *mut c_void, ids: *mut c_void, parameters: *mut c_void, rejected_img_points: *mut c_void) -> cv_return_value_void;
        pub fn cv_aruco_drawAxis__InputOutputArray__InputArray__InputArray__InputArray__InputArray_float(image: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, length: f32) -> cv_return_value_void;
        pub fn cv_aruco_drawCharucoDiamond_PtrOfDictionary_Vec4i_int_int__OutputArray_int_int(dictionary: *mut c_void, ids: core::Vec4i, square_length: i32, marker_length: i32, img: *mut c_void, margin_size: i32, border_bits: i32) -> cv_return_value_void;
        pub fn cv_aruco_drawDetectedCornersCharuco__InputOutputArray__InputArray__InputArray_Scalar(image: *mut c_void, charuco_corners: *mut c_void, charuco_ids: *mut c_void, corner_color: core::Scalar) -> cv_return_value_void;
        pub fn cv_aruco_drawDetectedDiamonds__InputOutputArray__InputArray__InputArray_Scalar(image: *mut c_void, diamond_corners: *mut c_void, diamond_ids: *mut c_void, border_color: core::Scalar) -> cv_return_value_void;
        pub fn cv_aruco_drawDetectedMarkers__InputOutputArray__InputArray__InputArray_Scalar(image: *mut c_void, corners: *mut c_void, ids: *mut c_void, border_color: core::Scalar) -> cv_return_value_void;
        pub fn cv_aruco_drawMarker_PtrOfDictionary_int_int__OutputArray_int(dictionary: *mut c_void, id: i32, side_pixels: i32, img: *mut c_void, border_bits: i32) -> cv_return_value_void;
        pub fn cv_aruco_drawPlanarBoard_PtrOfBoard_Size__OutputArray_int_int(board: *mut c_void, out_size: core::Size, img: *mut c_void, margin_size: i32, border_bits: i32) -> cv_return_value_void;
        pub fn cv_aruco_estimatePoseBoard__InputArray__InputArray_PtrOfBoard__InputArray__InputArray__OutputArray__OutputArray(corners: *mut c_void, ids: *mut c_void, board: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void) -> cv_return_value_int;
        pub fn cv_aruco_estimatePoseCharucoBoard__InputArray__InputArray_PtrOfCharucoBoard__InputArray__InputArray__OutputArray__OutputArray(charuco_corners: *mut c_void, charuco_ids: *mut c_void, board: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void) -> cv_return_value_bool;
        pub fn cv_aruco_estimatePoseSingleMarkers__InputArray_float__InputArray__InputArray__OutputArray__OutputArray(corners: *mut c_void, marker_length: f32, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void) -> cv_return_value_void;
        pub fn cv_aruco_generateCustomDictionary_int_int(n_markers: i32, marker_size: i32) -> cv_return_value_void_X;
        pub fn cv_aruco_generateCustomDictionary_int_int_PtrOfDictionary(n_markers: i32, marker_size: i32, base_dictionary: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_aruco_getPredefinedDictionary_PREDEFINED_DICTIONARY_NAME(name: crate::aruco::PREDEFINED_DICTIONARY_NAME) -> cv_return_value_void_X;
        pub fn cv_aruco_getPredefinedDictionary_int(dict: i32) -> cv_return_value_void_X;
        pub fn cv_aruco_interpolateCornersCharuco__InputArray__InputArray__InputArray_PtrOfCharucoBoard__OutputArray__OutputArray__InputArray__InputArray_int(marker_corners: *mut c_void, marker_ids: *mut c_void, image: *mut c_void, board: *mut c_void, charuco_corners: *mut c_void, charuco_ids: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, min_markers: i32) -> cv_return_value_int;
        pub fn cv_aruco_refineDetectedMarkers__InputArray_PtrOfBoard__InputOutputArray__InputOutputArray__InputOutputArray__InputArray__InputArray_float_float_bool__OutputArray_PtrOfDetectorParameters(image: *mut c_void, board: *mut c_void, detected_corners: *mut c_void, detected_ids: *mut c_void, rejected_corners: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, min_rep_distance: f32, error_correction_rate: f32, check_all_orders: bool, recovered_idxs: *mut c_void, parameters: *mut c_void) -> cv_return_value_void;
        pub fn cv_Board_delete(ptr : *mut c_void);
        pub fn cv_aruco_Board_create__InputArray_PtrOfDictionary__InputArray(obj_points: *mut c_void, dictionary: *mut c_void, ids: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_CharucoBoard_delete(ptr : *mut c_void);
        pub fn cv_aruco_CharucoBoard_draw_Size__OutputArray_int_int(instance: *mut c_void, out_size: core::Size, img: *mut c_void, margin_size: i32, border_bits: i32) -> cv_return_value_void;
        pub fn cv_aruco_CharucoBoard_create_int_int_float_float_PtrOfDictionary(squares_x: i32, squares_y: i32, square_length: f32, marker_length: f32, dictionary: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_aruco_CharucoBoard_getChessboardSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_aruco_CharucoBoard_getSquareLength_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_aruco_CharucoBoard_getMarkerLength_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_DetectorParameters_delete(ptr : *mut c_void);
        pub fn cv_aruco_DetectorParameters_adaptiveThreshWinSizeMin_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_aruco_DetectorParameters_set_adaptiveThreshWinSizeMin_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_adaptiveThreshWinSizeMax_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_aruco_DetectorParameters_set_adaptiveThreshWinSizeMax_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_adaptiveThreshWinSizeStep_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_aruco_DetectorParameters_set_adaptiveThreshWinSizeStep_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_adaptiveThreshConstant_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_aruco_DetectorParameters_set_adaptiveThreshConstant_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_minMarkerPerimeterRate_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_aruco_DetectorParameters_set_minMarkerPerimeterRate_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_maxMarkerPerimeterRate_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_aruco_DetectorParameters_set_maxMarkerPerimeterRate_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_polygonalApproxAccuracyRate_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_aruco_DetectorParameters_set_polygonalApproxAccuracyRate_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_minCornerDistanceRate_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_aruco_DetectorParameters_set_minCornerDistanceRate_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_minDistanceToBorder_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_aruco_DetectorParameters_set_minDistanceToBorder_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_minMarkerDistanceRate_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_aruco_DetectorParameters_set_minMarkerDistanceRate_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_doCornerRefinement_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_aruco_DetectorParameters_set_doCornerRefinement_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_cornerRefinementWinSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_aruco_DetectorParameters_set_cornerRefinementWinSize_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_cornerRefinementMaxIterations_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_aruco_DetectorParameters_set_cornerRefinementMaxIterations_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_cornerRefinementMinAccuracy_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_aruco_DetectorParameters_set_cornerRefinementMinAccuracy_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_markerBorderBits_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_aruco_DetectorParameters_set_markerBorderBits_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_perspectiveRemovePixelPerCell_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_aruco_DetectorParameters_set_perspectiveRemovePixelPerCell_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_perspectiveRemoveIgnoredMarginPerCell_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_aruco_DetectorParameters_set_perspectiveRemoveIgnoredMarginPerCell_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_maxErroneousBitsInBorderRate_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_aruco_DetectorParameters_set_maxErroneousBitsInBorderRate_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_minOtsuStdDev_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_aruco_DetectorParameters_set_minOtsuStdDev_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_errorCorrectionRate_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_aruco_DetectorParameters_set_errorCorrectionRate_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_aruco_DetectorParameters_DetectorParameters() -> cv_return_value_void_X;
        pub fn cv_aruco_DetectorParameters_create() -> cv_return_value_void_X;
        pub fn cv_Dictionary_delete(ptr : *mut c_void);
        pub fn cv_aruco_Dictionary_bytesList(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_aruco_Dictionary_set_bytesList_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_aruco_Dictionary_markerSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_aruco_Dictionary_set_markerSize_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_aruco_Dictionary_maxCorrectionBits_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_aruco_Dictionary_set_maxCorrectionBits_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_aruco_Dictionary_Dictionary_Mat_int_int(_bytes_list: *mut c_void, _marker_size: i32, _maxcorr: i32) -> cv_return_value_void_X;
        pub fn cv_aruco_Dictionary_Dictionary_PtrOfDictionary(_dictionary: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_aruco_Dictionary_create_int_int(n_markers: i32, marker_size: i32) -> cv_return_value_void_X;
        pub fn cv_aruco_Dictionary_create_int_int_PtrOfDictionary(n_markers: i32, marker_size: i32, base_dictionary: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_aruco_Dictionary_get_int(dict: i32) -> cv_return_value_void_X;
        pub fn cv_aruco_Dictionary_identify_const_Mat_int_int_double(instance: *const c_void, only_bits: *mut c_void, idx: *mut i32, rotation: *mut i32, max_correction_rate: f64) -> cv_return_value_bool;
        pub fn cv_aruco_Dictionary_getDistanceToId_const__InputArray_int_bool(instance: *const c_void, bits: *mut c_void, id: i32, all_rotations: bool) -> cv_return_value_int;
        pub fn cv_aruco_Dictionary_drawMarker_const_int_int__OutputArray_int(instance: *const c_void, id: i32, side_pixels: i32, _img: *mut c_void, border_bits: i32) -> cv_return_value_void;
        pub fn cv_aruco_Dictionary_getByteListFromBits_Mat(bits: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_aruco_Dictionary_getBitsFromByteList_Mat_int(byte_list: *mut c_void, marker_size: i32) -> cv_return_value_void_X;
        pub fn cv_GridBoard_delete(ptr : *mut c_void);
        pub fn cv_aruco_GridBoard_draw_Size__OutputArray_int_int(instance: *mut c_void, out_size: core::Size, img: *mut c_void, margin_size: i32, border_bits: i32) -> cv_return_value_void;
        pub fn cv_aruco_GridBoard_create_int_int_float_float_PtrOfDictionary_int(markers_x: i32, markers_y: i32, marker_length: f32, marker_separation: f32, dictionary: *mut c_void, first_marker: i32) -> cv_return_value_void_X;
        pub fn cv_aruco_GridBoard_getGridSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_aruco_GridBoard_getMarkerLength_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_aruco_GridBoard_getMarkerSeparation_const(instance: *const c_void) -> cv_return_value_float;
    
    }
}
#[cfg(feature = "contrib")]
pub use aruco_sys::*;

#[cfg(feature = "contrib")]
mod bgsegm_sys {
    use super::*;

    extern "C" {
        pub fn cv_bgsegm_createBackgroundSubtractorGMG_int_double(initialization_frames: i32, decision_threshold: f64) -> cv_return_value_void_X;
        pub fn cv_bgsegm_createBackgroundSubtractorMOG_int_int_double_double(history: i32, nmixtures: i32, background_ratio: f64, noise_sigma: f64) -> cv_return_value_void_X;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_getMaxFeatures_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_setMaxFeatures_int(instance: *mut c_void, max_features: i32) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_getDefaultLearningRate_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_setDefaultLearningRate_double(instance: *mut c_void, lr: f64) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_getNumFrames_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_setNumFrames_int(instance: *mut c_void, nframes: i32) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_getQuantizationLevels_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_setQuantizationLevels_int(instance: *mut c_void, nlevels: i32) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_getBackgroundPrior_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_setBackgroundPrior_double(instance: *mut c_void, bgprior: f64) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_getSmoothingRadius_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_setSmoothingRadius_int(instance: *mut c_void, radius: i32) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_getDecisionThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_setDecisionThreshold_double(instance: *mut c_void, thresh: f64) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_getUpdateBackgroundModel_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_setUpdateBackgroundModel_bool(instance: *mut c_void, update: bool) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_getMinVal_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_setMinVal_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_getMaxVal_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_bgsegm_BackgroundSubtractorGMG_setMaxVal_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorMOG_getHistory_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_bgsegm_BackgroundSubtractorMOG_setHistory_int(instance: *mut c_void, nframes: i32) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorMOG_getNMixtures_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_bgsegm_BackgroundSubtractorMOG_setNMixtures_int(instance: *mut c_void, nmix: i32) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorMOG_getBackgroundRatio_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_bgsegm_BackgroundSubtractorMOG_setBackgroundRatio_double(instance: *mut c_void, background_ratio: f64) -> cv_return_value_void;
        pub fn cv_bgsegm_BackgroundSubtractorMOG_getNoiseSigma_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_bgsegm_BackgroundSubtractorMOG_setNoiseSigma_double(instance: *mut c_void, noise_sigma: f64) -> cv_return_value_void;
    
    }
}
#[cfg(feature = "contrib")]
pub use bgsegm_sys::*;

#[cfg(feature = "contrib")]
mod bioinspired_sys {
    use super::*;

    extern "C" {
        pub fn cv_bioinspired_createRetinaFastToneMapping_Size(input_size: core::Size) -> cv_return_value_void_X;
        pub fn cv_bioinspired_createRetina_OCL_Size(input_size: core::Size) -> cv_return_value_void_X;
        pub fn cv_bioinspired_createRetina_OCL_Size_bool_int_bool_float_float(input_size: core::Size, color_mode: bool, color_sampling_method: i32, use_retina_log_sampling: bool, reduction_factor: f32, sampling_strenght: f32) -> cv_return_value_void_X;
        pub fn cv_bioinspired_createRetina_Size(input_size: core::Size) -> cv_return_value_void_X;
        pub fn cv_bioinspired_createRetina_Size_bool_int_bool_float_float(input_size: core::Size, color_mode: bool, color_sampling_method: i32, use_retina_log_sampling: bool, reduction_factor: f32, sampling_strenght: f32) -> cv_return_value_void_X;
        pub fn cv_bioinspired_createTransientAreasSegmentationModule_Size(input_size: core::Size) -> cv_return_value_void_X;
        pub fn cv_bioinspired_Retina_getInputSize(instance: *mut c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_bioinspired_Retina_getOutputSize(instance: *mut c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_bioinspired_Retina_setup_String_bool(instance: *mut c_void, retina_parameter_file: *mut c_char, apply_default_setup_on_failure: bool) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_setup_FileStorage_bool(instance: *mut c_void, fs: *mut c_void, apply_default_setup_on_failure: bool) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_setup_RetinaParameters(instance: *mut c_void, new_parameters: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_getParameters(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_bioinspired_Retina_printSetup(instance: *mut c_void) -> cv_return_value_const_char_X;
        pub fn cv_bioinspired_Retina_write_const_String(instance: *const c_void, fs: *mut c_char) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_write_const_FileStorage(instance: *const c_void, fs: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_setupOPLandIPLParvoChannel_bool_bool_float_float_float_float_float_float_float(instance: *mut c_void, color_mode: bool, normalise_output: bool, photoreceptors_local_adaptation_sensitivity: f32, photoreceptors_temporal_constant: f32, photoreceptors_spatial_constant: f32, horizontal_cells_gain: f32, hcells_temporal_constant: f32, hcells_spatial_constant: f32, ganglion_cells_sensitivity: f32) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_setupIPLMagnoChannel_bool_float_float_float_float_float_float_float(instance: *mut c_void, normalise_output: bool, parasol_cells_beta: f32, parasol_cells_tau: f32, parasol_cells_k: f32, amacrin_cells_temporal_cut_frequency: f32, v0_compression_parameter: f32, local_adaptintegration_tau: f32, local_adaptintegration_k: f32) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_run__InputArray(instance: *mut c_void, input_image: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_applyFastToneMapping__InputArray__OutputArray(instance: *mut c_void, input_image: *mut c_void, output_tone_mapped_image: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_getParvo__OutputArray(instance: *mut c_void, retina_output_parvo: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_getParvoRAW__OutputArray(instance: *mut c_void, retina_output_parvo: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_getMagno__OutputArray(instance: *mut c_void, retina_output_magno: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_getMagnoRAW__OutputArray(instance: *mut c_void, retina_output_magno: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_getMagnoRAW_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_bioinspired_Retina_getParvoRAW_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_bioinspired_Retina_setColorSaturation_bool_float(instance: *mut c_void, saturate_colors: bool, color_saturation_value: f32) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_clearBuffers(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_activateMovingContoursProcessing_bool(instance: *mut c_void, activate: bool) -> cv_return_value_void;
        pub fn cv_bioinspired_Retina_activateContoursProcessing_bool(instance: *mut c_void, activate: bool) -> cv_return_value_void;
        pub fn cv_bioinspired_RetinaFastToneMapping_applyFastToneMapping__InputArray__OutputArray(instance: *mut c_void, input_image: *mut c_void, output_tone_mapped_image: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_RetinaFastToneMapping_setup_float_float_float(instance: *mut c_void, photoreceptors_neighborhood_radius: f32, ganglioncells_neighborhood_radius: f32, mean_luminance_modulator_k: f32) -> cv_return_value_void;
        pub fn cv_RetinaParameters_delete(ptr : *mut c_void);
        pub fn cv_RetinaParameters_IplMagnoParameters_delete(ptr : *mut c_void);
        pub fn cv_bioinspired_RetinaParameters_IplMagnoParameters_IplMagnoParameters() -> cv_return_value_void_X;
        pub fn cv_RetinaParameters_OPLandIplParvoParameters_delete(ptr : *mut c_void);
        pub fn cv_bioinspired_RetinaParameters_OPLandIplParvoParameters_OPLandIplParvoParameters() -> cv_return_value_void_X;
        pub fn cv_SegmentationParameters_delete(ptr : *mut c_void);
        pub fn cv_bioinspired_SegmentationParameters_SegmentationParameters() -> cv_return_value_void_X;
        pub fn cv_bioinspired_TransientAreasSegmentationModule_getSize(instance: *mut c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_bioinspired_TransientAreasSegmentationModule_setup_String_bool(instance: *mut c_void, segmentation_parameter_file: *mut c_char, apply_default_setup_on_failure: bool) -> cv_return_value_void;
        pub fn cv_bioinspired_TransientAreasSegmentationModule_setup_FileStorage_bool(instance: *mut c_void, fs: *mut c_void, apply_default_setup_on_failure: bool) -> cv_return_value_void;
        pub fn cv_bioinspired_TransientAreasSegmentationModule_setup_SegmentationParameters(instance: *mut c_void, new_parameters: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_TransientAreasSegmentationModule_getParameters(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_bioinspired_TransientAreasSegmentationModule_printSetup(instance: *mut c_void) -> cv_return_value_const_char_X;
        pub fn cv_bioinspired_TransientAreasSegmentationModule_write_const_String(instance: *const c_void, fs: *mut c_char) -> cv_return_value_void;
        pub fn cv_bioinspired_TransientAreasSegmentationModule_write_const_FileStorage(instance: *const c_void, fs: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_TransientAreasSegmentationModule_run__InputArray_int(instance: *mut c_void, input_to_segment: *mut c_void, channel_index: i32) -> cv_return_value_void;
        pub fn cv_bioinspired_TransientAreasSegmentationModule_getSegmentationPicture__OutputArray(instance: *mut c_void, transient_areas: *mut c_void) -> cv_return_value_void;
        pub fn cv_bioinspired_TransientAreasSegmentationModule_clearAllBuffers(instance: *mut c_void) -> cv_return_value_void;
    
    }
}
#[cfg(feature = "contrib")]
pub use bioinspired_sys::*;

mod calib3d_sys {
    use super::*;

    extern "C" {
        pub fn cv_RQDecomp3x3__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray(src: *mut c_void, mtx_r: *mut c_void, mtx_q: *mut c_void, qx: *mut c_void, qy: *mut c_void, qz: *mut c_void) -> cv_return_value_Vec3dWrapper;
        pub fn cv_Rodrigues__InputArray__OutputArray__OutputArray(src: *mut c_void, dst: *mut c_void, jacobian: *mut c_void) -> cv_return_value_void;
        pub fn cv_calibrateCamera__InputArray__InputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria(object_points: *mut c_void, image_points: *mut c_void, image_size: core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, std_deviations_intrinsics: *mut c_void, std_deviations_extrinsics: *mut c_void, per_view_errors: *mut c_void, flags: i32, criteria: *mut c_void) -> cv_return_value_double;
        pub fn cv_calibrateCamera__InputArray__InputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray_int_TermCriteria(object_points: *mut c_void, image_points: *mut c_void, image_size: core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void) -> cv_return_value_double;
        pub fn cv_calibrationMatrixValues__InputArray_Size_double_double_double_double_double_Point2d_double(camera_matrix: *mut c_void, image_size: core::Size, aperture_width: f64, aperture_height: f64, fovx: *mut f64, fovy: *mut f64, focal_length: *mut f64, principal_point: *mut core::Point2d, aspect_ratio: *mut f64) -> cv_return_value_void;
        pub fn cv_composeRT__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray(rvec1: *mut c_void, tvec1: *mut c_void, rvec2: *mut c_void, tvec2: *mut c_void, rvec3: *mut c_void, tvec3: *mut c_void, dr3dr1: *mut c_void, dr3dt1: *mut c_void, dr3dr2: *mut c_void, dr3dt2: *mut c_void, dt3dr1: *mut c_void, dt3dt1: *mut c_void, dt3dr2: *mut c_void, dt3dt2: *mut c_void) -> cv_return_value_void;
        pub fn cv_computeCorrespondEpilines__InputArray_int__InputArray__OutputArray(points: *mut c_void, which_image: i32, f: *mut c_void, lines: *mut c_void) -> cv_return_value_void;
        pub fn cv_convertPointsFromHomogeneous__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_convertPointsHomogeneous__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_convertPointsToHomogeneous__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_correctMatches__InputArray__InputArray__InputArray__OutputArray__OutputArray(f: *mut c_void, points1: *mut c_void, points2: *mut c_void, new_points1: *mut c_void, new_points2: *mut c_void) -> cv_return_value_void;
        pub fn cv_decomposeEssentialMat__InputArray__OutputArray__OutputArray__OutputArray(e: *mut c_void, r1: *mut c_void, r2: *mut c_void, t: *mut c_void) -> cv_return_value_void;
        pub fn cv_decomposeHomographyMat__InputArray__InputArray__OutputArray__OutputArray__OutputArray(h: *mut c_void, k: *mut c_void, rotations: *mut c_void, translations: *mut c_void, normals: *mut c_void) -> cv_return_value_int;
        pub fn cv_decomposeProjectionMatrix__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray(proj_matrix: *mut c_void, camera_matrix: *mut c_void, rot_matrix: *mut c_void, trans_vect: *mut c_void, rot_matrix_x: *mut c_void, rot_matrix_y: *mut c_void, rot_matrix_z: *mut c_void, euler_angles: *mut c_void) -> cv_return_value_void;
        pub fn cv_drawChessboardCorners__InputOutputArray_Size__InputArray_bool(image: *mut c_void, pattern_size: core::Size, corners: *mut c_void, pattern_was_found: bool) -> cv_return_value_void;
        pub fn cv_estimateAffine2D__InputArray__InputArray__OutputArray_int_double_size_t_double_size_t(from: *mut c_void, to: *mut c_void, inliers: *mut c_void, method: i32, ransac_reproj_threshold: f64, max_iters: size_t, confidence: f64, refine_iters: size_t) -> cv_return_value_void_X;
        pub fn cv_estimateAffine3D__InputArray__InputArray__OutputArray__OutputArray_double_double(src: *mut c_void, dst: *mut c_void, out: *mut c_void, inliers: *mut c_void, ransac_threshold: f64, confidence: f64) -> cv_return_value_int;
        pub fn cv_estimateAffinePartial2D__InputArray__InputArray__OutputArray_int_double_size_t_double_size_t(from: *mut c_void, to: *mut c_void, inliers: *mut c_void, method: i32, ransac_reproj_threshold: f64, max_iters: size_t, confidence: f64, refine_iters: size_t) -> cv_return_value_void_X;
        pub fn cv_filterSpeckles__InputOutputArray_double_int_double__InputOutputArray(img: *mut c_void, new_val: f64, max_speckle_size: i32, max_diff: f64, buf: *mut c_void) -> cv_return_value_void;
        pub fn cv_find4QuadCornerSubpix__InputArray__InputOutputArray_Size(img: *mut c_void, corners: *mut c_void, region_size: core::Size) -> cv_return_value_bool;
        pub fn cv_findChessboardCorners__InputArray_Size__OutputArray_int(image: *mut c_void, pattern_size: core::Size, corners: *mut c_void, flags: i32) -> cv_return_value_bool;
        pub fn cv_findCirclesGrid__InputArray_Size__OutputArray_int_PtrOfFeature2D(image: *mut c_void, pattern_size: core::Size, centers: *mut c_void, flags: i32, blob_detector: *mut c_void) -> cv_return_value_bool;
        pub fn cv_findEssentialMat__InputArray__InputArray__InputArray_int_double_double__OutputArray(points1: *mut c_void, points2: *mut c_void, camera_matrix: *mut c_void, method: i32, prob: f64, threshold: f64, mask: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_findEssentialMat__InputArray__InputArray_double_Point2d_int_double_double__OutputArray(points1: *mut c_void, points2: *mut c_void, focal: f64, pp: core::Point2d, method: i32, prob: f64, threshold: f64, mask: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_findFundamentalMat__InputArray__InputArray__OutputArray_int_double_double(points1: *mut c_void, points2: *mut c_void, mask: *mut c_void, method: i32, param1: f64, param2: f64) -> cv_return_value_void_X;
        pub fn cv_findHomography__InputArray__InputArray__OutputArray_int_double(src_points: *mut c_void, dst_points: *mut c_void, mask: *mut c_void, method: i32, ransac_reproj_threshold: f64) -> cv_return_value_void_X;
        pub fn cv_findHomography__InputArray__InputArray_int_double__OutputArray_int_double(src_points: *mut c_void, dst_points: *mut c_void, method: i32, ransac_reproj_threshold: f64, mask: *mut c_void, max_iters: i32, confidence: f64) -> cv_return_value_void_X;
        pub fn cv_fisheye_calibrate__InputArray__InputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray_int_TermCriteria(object_points: *mut c_void, image_points: *mut c_void, image_size: core::Size, k: *mut c_void, d: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void) -> cv_return_value_double;
        pub fn cv_fisheye_distortPoints__InputArray__OutputArray__InputArray__InputArray_double(undistorted: *mut c_void, distorted: *mut c_void, k: *mut c_void, d: *mut c_void, alpha: f64) -> cv_return_value_void;
        pub fn cv_fisheye_estimateNewCameraMatrixForUndistortRectify__InputArray__InputArray_Size__InputArray__OutputArray_double_Size_double(k: *mut c_void, d: *mut c_void, image_size: core::Size, r: *mut c_void, p: *mut c_void, balance: f64, new_size: core::Size, fov_scale: f64) -> cv_return_value_void;
        pub fn cv_fisheye_initUndistortRectifyMap__InputArray__InputArray__InputArray__InputArray_Size_int__OutputArray__OutputArray(k: *mut c_void, d: *mut c_void, r: *mut c_void, p: *mut c_void, size: core::Size, m1type: i32, map1: *mut c_void, map2: *mut c_void) -> cv_return_value_void;
        pub fn cv_fisheye_projectPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray_double__OutputArray(object_points: *mut c_void, image_points: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, k: *mut c_void, d: *mut c_void, alpha: f64, jacobian: *mut c_void) -> cv_return_value_void;
        pub fn cv_fisheye_stereoCalibrate__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray__InputOutputArray__InputOutputArray_Size__OutputArray__OutputArray_int_TermCriteria(object_points: *mut c_void, image_points1: *mut c_void, image_points2: *mut c_void, k1: *mut c_void, d1: *mut c_void, k2: *mut c_void, d2: *mut c_void, image_size: core::Size, r: *mut c_void, t: *mut c_void, flags: i32, criteria: *mut c_void) -> cv_return_value_double;
        pub fn cv_fisheye_stereoRectify__InputArray__InputArray__InputArray__InputArray_Size__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_Size_double_double(k1: *mut c_void, d1: *mut c_void, k2: *mut c_void, d2: *mut c_void, image_size: core::Size, r: *mut c_void, tvec: *mut c_void, r1: *mut c_void, r2: *mut c_void, p1: *mut c_void, p2: *mut c_void, q: *mut c_void, flags: i32, new_image_size: core::Size, balance: f64, fov_scale: f64) -> cv_return_value_void;
        pub fn cv_fisheye_undistortImage__InputArray__OutputArray__InputArray__InputArray__InputArray_Size(distorted: *mut c_void, undistorted: *mut c_void, k: *mut c_void, d: *mut c_void, knew: *mut c_void, new_size: core::Size) -> cv_return_value_void;
        pub fn cv_fisheye_undistortPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray(distorted: *mut c_void, undistorted: *mut c_void, k: *mut c_void, d: *mut c_void, r: *mut c_void, p: *mut c_void) -> cv_return_value_void;
        pub fn cv_getOptimalNewCameraMatrix__InputArray__InputArray_Size_double_Size_Rect_X_bool(camera_matrix: *mut c_void, dist_coeffs: *mut c_void, image_size: core::Size, alpha: f64, new_img_size: core::Size, valid_pix_roi: *mut core::Rect, center_principal_point: bool) -> cv_return_value_void_X;
        pub fn cv_getValidDisparityROI_Rect_Rect_int_int_int(roi1: core::Rect, roi2: core::Rect, min_disparity: i32, number_of_disparities: i32, sad_window_size: i32) -> cv_return_value_RectWrapper;
        pub fn cv_initCameraMatrix2D__InputArray__InputArray_Size_double(object_points: *mut c_void, image_points: *mut c_void, image_size: core::Size, aspect_ratio: f64) -> cv_return_value_void_X;
        pub fn cv_matMulDeriv__InputArray__InputArray__OutputArray__OutputArray(a: *mut c_void, b: *mut c_void, d_a_bd_a: *mut c_void, d_a_bd_b: *mut c_void) -> cv_return_value_void;
        pub fn cv_projectPoints__InputArray__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_double(object_points: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, image_points: *mut c_void, jacobian: *mut c_void, aspect_ratio: f64) -> cv_return_value_void;
        pub fn cv_recoverPose__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__InputOutputArray(e: *mut c_void, points1: *mut c_void, points2: *mut c_void, camera_matrix: *mut c_void, r: *mut c_void, t: *mut c_void, mask: *mut c_void) -> cv_return_value_int;
        pub fn cv_recoverPose__InputArray__InputArray__InputArray__OutputArray__OutputArray_double_Point2d__InputOutputArray(e: *mut c_void, points1: *mut c_void, points2: *mut c_void, r: *mut c_void, t: *mut c_void, focal: f64, pp: core::Point2d, mask: *mut c_void) -> cv_return_value_int;
        pub fn cv_rectify3Collinear__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray_Size__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_double_Size_Rect_X_Rect_X_int(camera_matrix1: *mut c_void, dist_coeffs1: *mut c_void, camera_matrix2: *mut c_void, dist_coeffs2: *mut c_void, camera_matrix3: *mut c_void, dist_coeffs3: *mut c_void, imgpt1: *mut c_void, imgpt3: *mut c_void, image_size: core::Size, r12: *mut c_void, t12: *mut c_void, r13: *mut c_void, t13: *mut c_void, r1: *mut c_void, r2: *mut c_void, r3: *mut c_void, p1: *mut c_void, p2: *mut c_void, p3: *mut c_void, q: *mut c_void, alpha: f64, new_img_size: core::Size, roi1: *mut core::Rect, roi2: *mut core::Rect, flags: i32) -> cv_return_value_float;
        pub fn cv_reprojectImageTo3D__InputArray__OutputArray__InputArray_bool_int(disparity: *mut c_void, _3d_image: *mut c_void, q: *mut c_void, handle_missing_values: bool, ddepth: i32) -> cv_return_value_void;
        pub fn cv_sampsonDistance__InputArray__InputArray__InputArray(pt1: *mut c_void, pt2: *mut c_void, f: *mut c_void) -> cv_return_value_double;
        pub fn cv_solvePnPRansac__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_int_float_double__OutputArray_int(object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, iterations_count: i32, reprojection_error: f32, confidence: f64, inliers: *mut c_void, flags: i32) -> cv_return_value_bool;
        pub fn cv_solvePnP__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_int(object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, flags: i32) -> cv_return_value_bool;
        pub fn cv_stereoCalibrate__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray__InputOutputArray__InputOutputArray_Size__OutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria(object_points: *mut c_void, image_points1: *mut c_void, image_points2: *mut c_void, camera_matrix1: *mut c_void, dist_coeffs1: *mut c_void, camera_matrix2: *mut c_void, dist_coeffs2: *mut c_void, image_size: core::Size, r: *mut c_void, t: *mut c_void, e: *mut c_void, f: *mut c_void, flags: i32, criteria: *mut c_void) -> cv_return_value_double;
        pub fn cv_stereoRectifyUncalibrated__InputArray__InputArray__InputArray_Size__OutputArray__OutputArray_double(points1: *mut c_void, points2: *mut c_void, f: *mut c_void, img_size: core::Size, h1: *mut c_void, h2: *mut c_void, threshold: f64) -> cv_return_value_bool;
        pub fn cv_stereoRectify__InputArray__InputArray__InputArray__InputArray_Size__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_double_Size_Rect_X_Rect_X(camera_matrix1: *mut c_void, dist_coeffs1: *mut c_void, camera_matrix2: *mut c_void, dist_coeffs2: *mut c_void, image_size: core::Size, r: *mut c_void, t: *mut c_void, r1: *mut c_void, r2: *mut c_void, p1: *mut c_void, p2: *mut c_void, q: *mut c_void, flags: i32, alpha: f64, new_image_size: core::Size, valid_pix_roi1: *mut core::Rect, valid_pix_roi2: *mut core::Rect) -> cv_return_value_void;
        pub fn cv_triangulatePoints__InputArray__InputArray__InputArray__InputArray__OutputArray(proj_matr1: *mut c_void, proj_matr2: *mut c_void, proj_points1: *mut c_void, proj_points2: *mut c_void, points4_d: *mut c_void) -> cv_return_value_void;
        pub fn cv_validateDisparity__InputOutputArray__InputArray_int_int_int(disparity: *mut c_void, cost: *mut c_void, min_disparity: i32, number_of_disparities: i32, disp12_max_disp: i32) -> cv_return_value_void;
        pub fn cv_StereoBM_getPreFilterType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoBM_setPreFilterType_int(instance: *mut c_void, pre_filter_type: i32) -> cv_return_value_void;
        pub fn cv_StereoBM_getPreFilterSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoBM_setPreFilterSize_int(instance: *mut c_void, pre_filter_size: i32) -> cv_return_value_void;
        pub fn cv_StereoBM_getPreFilterCap_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoBM_setPreFilterCap_int(instance: *mut c_void, pre_filter_cap: i32) -> cv_return_value_void;
        pub fn cv_StereoBM_getTextureThreshold_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoBM_setTextureThreshold_int(instance: *mut c_void, texture_threshold: i32) -> cv_return_value_void;
        pub fn cv_StereoBM_getUniquenessRatio_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoBM_setUniquenessRatio_int(instance: *mut c_void, uniqueness_ratio: i32) -> cv_return_value_void;
        pub fn cv_StereoBM_getSmallerBlockSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoBM_setSmallerBlockSize_int(instance: *mut c_void, block_size: i32) -> cv_return_value_void;
        pub fn cv_StereoBM_getROI1_const(instance: *const c_void) -> cv_return_value_RectWrapper;
        pub fn cv_StereoBM_setROI1_Rect(instance: *mut c_void, roi1: core::Rect) -> cv_return_value_void;
        pub fn cv_StereoBM_getROI2_const(instance: *const c_void) -> cv_return_value_RectWrapper;
        pub fn cv_StereoBM_setROI2_Rect(instance: *mut c_void, roi2: core::Rect) -> cv_return_value_void;
        pub fn cv_StereoBM_create_int_int(num_disparities: i32, block_size: i32) -> cv_return_value_void_X;
        pub fn cv_StereoMatcher_compute__InputArray__InputArray__OutputArray(instance: *mut c_void, left: *mut c_void, right: *mut c_void, disparity: *mut c_void) -> cv_return_value_void;
        pub fn cv_StereoMatcher_getMinDisparity_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoMatcher_setMinDisparity_int(instance: *mut c_void, min_disparity: i32) -> cv_return_value_void;
        pub fn cv_StereoMatcher_getNumDisparities_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoMatcher_setNumDisparities_int(instance: *mut c_void, num_disparities: i32) -> cv_return_value_void;
        pub fn cv_StereoMatcher_getBlockSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoMatcher_setBlockSize_int(instance: *mut c_void, block_size: i32) -> cv_return_value_void;
        pub fn cv_StereoMatcher_getSpeckleWindowSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoMatcher_setSpeckleWindowSize_int(instance: *mut c_void, speckle_window_size: i32) -> cv_return_value_void;
        pub fn cv_StereoMatcher_getSpeckleRange_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoMatcher_setSpeckleRange_int(instance: *mut c_void, speckle_range: i32) -> cv_return_value_void;
        pub fn cv_StereoMatcher_getDisp12MaxDiff_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoMatcher_setDisp12MaxDiff_int(instance: *mut c_void, disp12_max_diff: i32) -> cv_return_value_void;
        pub fn cv_StereoSGBM_getPreFilterCap_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoSGBM_setPreFilterCap_int(instance: *mut c_void, pre_filter_cap: i32) -> cv_return_value_void;
        pub fn cv_StereoSGBM_getUniquenessRatio_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoSGBM_setUniquenessRatio_int(instance: *mut c_void, uniqueness_ratio: i32) -> cv_return_value_void;
        pub fn cv_StereoSGBM_getP1_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoSGBM_setP1_int(instance: *mut c_void, p1: i32) -> cv_return_value_void;
        pub fn cv_StereoSGBM_getP2_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoSGBM_setP2_int(instance: *mut c_void, p2: i32) -> cv_return_value_void;
        pub fn cv_StereoSGBM_getMode_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_StereoSGBM_setMode_int(instance: *mut c_void, mode: i32) -> cv_return_value_void;
        pub fn cv_StereoSGBM_create_int_int_int_int_int_int_int_int_int_int_int(min_disparity: i32, num_disparities: i32, block_size: i32, p1: i32, p2: i32, disp12_max_diff: i32, pre_filter_cap: i32, uniqueness_ratio: i32, speckle_window_size: i32, speckle_range: i32, mode: i32) -> cv_return_value_void_X;
    
    }
}
pub use calib3d_sys::*;

#[cfg(feature = "contrib")]
mod ccalib_sys {
    use super::*;

    extern "C" {
        pub fn cv_omnidir_calibrate__InputArray__InputArray_Size__InputOutputArray__InputOutputArray__InputOutputArray__OutputArray__OutputArray_int_TermCriteria__OutputArray(object_points: *mut c_void, image_points: *mut c_void, size: core::Size, k: *mut c_void, xi: *mut c_void, d: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void, idx: *mut c_void) -> cv_return_value_double;
        pub fn cv_omnidir_initUndistortRectifyMap__InputArray__InputArray__InputArray__InputArray__InputArray_Size_int__OutputArray__OutputArray_int(k: *mut c_void, d: *mut c_void, xi: *mut c_void, r: *mut c_void, p: *mut c_void, size: core::Size, mltype: i32, map1: *mut c_void, map2: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_omnidir_internal_checkFixed_Mat_int_int(g: *mut c_void, flags: i32, n: i32) -> cv_return_value_void;
        pub fn cv_omnidir_internal_compose_motion__InputArray__InputArray__InputArray__InputArray_Mat_Mat_Mat_Mat_Mat_Mat_Mat_Mat_Mat_Mat(_om1: *mut c_void, _t1: *mut c_void, _om2: *mut c_void, _t2: *mut c_void, om3: *mut c_void, t3: *mut c_void, dom3dom1: *mut c_void, dom3d_t1: *mut c_void, dom3dom2: *mut c_void, dom3d_t2: *mut c_void, d_t3dom1: *mut c_void, d_t3d_t1: *mut c_void, d_t3dom2: *mut c_void, d_t3d_t2: *mut c_void) -> cv_return_value_void;
        pub fn cv_omnidir_internal_computeJacobianStereo__InputArray__InputArray__InputArray__InputArray_Mat_Mat_int_double(object_points: *mut c_void, image_points1: *mut c_void, image_points2: *mut c_void, parameters: *mut c_void, jtj_inv: *mut c_void, jte: *mut c_void, flags: i32, epsilon: f64) -> cv_return_value_void;
        pub fn cv_omnidir_internal_computeJacobian__InputArray__InputArray__InputArray_Mat_Mat_int_double(object_points: *mut c_void, image_points: *mut c_void, parameters: *mut c_void, jtj_inv: *mut c_void, jte: *mut c_void, flags: i32, epsilon: f64) -> cv_return_value_void;
        pub fn cv_omnidir_internal_computeMeanReproErrStereo__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray_double_double__InputArray__InputArray__InputArray__InputArray(object_points: *mut c_void, image_points1: *mut c_void, image_points2: *mut c_void, k1: *mut c_void, k2: *mut c_void, d1: *mut c_void, d2: *mut c_void, xi1: f64, xi2: f64, om: *mut c_void, t: *mut c_void, om_l: *mut c_void, tl: *mut c_void) -> cv_return_value_double;
        pub fn cv_omnidir_internal_computeMeanReproErr__InputArray__InputArray(image_points: *mut c_void, pro_image_points: *mut c_void) -> cv_return_value_double;
        pub fn cv_omnidir_internal_computeMeanReproErr__InputArray__InputArray__InputArray__InputArray_double__InputArray__InputArray(object_points: *mut c_void, image_points: *mut c_void, k: *mut c_void, d: *mut c_void, xi: f64, om_all: *mut c_void, t_all: *mut c_void) -> cv_return_value_double;
        pub fn cv_omnidir_internal_decodeParametersStereo__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_double_double(parameters: *mut c_void, k1: *mut c_void, k2: *mut c_void, om: *mut c_void, t: *mut c_void, om_l: *mut c_void, t_l: *mut c_void, d1: *mut c_void, d2: *mut c_void, xi1: *mut f64, xi2: *mut f64) -> cv_return_value_void;
        pub fn cv_omnidir_internal_decodeParameters__InputArray__OutputArray__OutputArray__OutputArray__OutputArray_double(paramsters: *mut c_void, k: *mut c_void, om_all: *mut c_void, t_all: *mut c_void, distoration: *mut c_void, xi: *mut f64) -> cv_return_value_void;
        pub fn cv_omnidir_internal_encodeParametersStereo__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray_double_double__OutputArray(k1: *mut c_void, k2: *mut c_void, om: *mut c_void, t: *mut c_void, om_l: *mut c_void, t_l: *mut c_void, d1: *mut c_void, d2: *mut c_void, xi1: f64, xi2: f64, parameters: *mut c_void) -> cv_return_value_void;
        pub fn cv_omnidir_internal_encodeParameters__InputArray__InputArray__InputArray__InputArray_double__OutputArray(k: *mut c_void, om_all: *mut c_void, t_all: *mut c_void, distoaration: *mut c_void, xi: f64, parameters: *mut c_void) -> cv_return_value_void;
        pub fn cv_omnidir_internal_estimateUncertaintiesStereo__InputArray__InputArray__InputArray__InputArray_Mat_Vec2d_double_int(object_points: *mut c_void, image_points1: *mut c_void, image_points2: *mut c_void, parameters: *mut c_void, errors: *mut c_void, std_error: *mut core::Vec2d, rms: *mut f64, flags: i32) -> cv_return_value_void;
        pub fn cv_omnidir_internal_estimateUncertainties__InputArray__InputArray__InputArray_Mat_Vec2d_double_int(object_points: *mut c_void, image_points: *mut c_void, parameters: *mut c_void, errors: *mut c_void, std_error: *mut core::Vec2d, rms: *mut f64, flags: i32) -> cv_return_value_void;
        pub fn cv_omnidir_internal_fillFixedStereo_Mat_int_int(g: *mut c_void, flags: i32, n: i32) -> cv_return_value_void;
        pub fn cv_omnidir_internal_fillFixed_Mat_int_int(g: *mut c_void, flags: i32, n: i32) -> cv_return_value_void;
        pub fn cv_omnidir_internal_findMedian3__InputArray(mat: *mut c_void) -> cv_return_value_Vec3dWrapper;
        pub fn cv_omnidir_internal_findMedian_Mat(row: *mut c_void) -> cv_return_value_double;
        pub fn cv_omnidir_internal_flags2idxStereo_int_VectorOfint_int(flags: i32, idx: *mut c_void, n: i32) -> cv_return_value_void;
        pub fn cv_omnidir_internal_flags2idx_int_VectorOfint_int(flags: i32, idx: *mut c_void, n: i32) -> cv_return_value_void;
        pub fn cv_omnidir_internal_getInterset__InputArray__InputArray__OutputArray__OutputArray__OutputArray(idx1: *mut c_void, idx2: *mut c_void, inter1: *mut c_void, inter2: *mut c_void, inter_ori: *mut c_void) -> cv_return_value_void;
        pub fn cv_omnidir_internal_initializeCalibration__InputArray__InputArray_Size__OutputArray__OutputArray__OutputArray_double__OutputArray(object_points: *mut c_void, image_points: *mut c_void, size: core::Size, om_all: *mut c_void, t_all: *mut c_void, k: *mut c_void, xi: *mut f64, idx: *mut c_void) -> cv_return_value_void;
        pub fn cv_omnidir_internal_initializeStereoCalibration__InputArray__InputArray__InputArray_Size_Size__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_double_double_int__OutputArray(object_points: *mut c_void, image_points1: *mut c_void, image_points2: *mut c_void, size1: core::Size, size2: core::Size, om: *mut c_void, t: *mut c_void, om_l: *mut c_void, t_l: *mut c_void, k1: *mut c_void, d1: *mut c_void, k2: *mut c_void, d2: *mut c_void, xi1: *mut f64, xi2: *mut f64, flags: i32, idx: *mut c_void) -> cv_return_value_void;
        pub fn cv_omnidir_internal_subMatrix_Mat_Mat_VectorOfint_VectorOfint(src: *mut c_void, dst: *mut c_void, cols: *mut c_void, rows: *mut c_void) -> cv_return_value_void;
        pub fn cv_omnidir_projectPoints__InputArray__OutputArray__InputArray__InputArray__InputArray_double__InputArray__OutputArray(object_points: *mut c_void, image_points: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, k: *mut c_void, xi: f64, d: *mut c_void, jacobian: *mut c_void) -> cv_return_value_void;
        pub fn cv_omnidir_stereoCalibrate__InputOutputArray__InputOutputArray__InputOutputArray_Size_Size__InputOutputArray__InputOutputArray__InputOutputArray__InputOutputArray__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria__OutputArray(object_points: *mut c_void, image_points1: *mut c_void, image_points2: *mut c_void, image_size1: core::Size, image_size2: core::Size, k1: *mut c_void, xi1: *mut c_void, d1: *mut c_void, k2: *mut c_void, xi2: *mut c_void, d2: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, rvecs_l: *mut c_void, tvecs_l: *mut c_void, flags: i32, criteria: *mut c_void, idx: *mut c_void) -> cv_return_value_double;
        pub fn cv_omnidir_stereoReconstruct__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray_int_int_int__OutputArray__OutputArray__OutputArray_Size__InputArray__OutputArray_int(image1: *mut c_void, image2: *mut c_void, k1: *mut c_void, d1: *mut c_void, xi1: *mut c_void, k2: *mut c_void, d2: *mut c_void, xi2: *mut c_void, r: *mut c_void, t: *mut c_void, flag: i32, num_disparities: i32, sad_window_size: i32, disparity: *mut c_void, image1_rec: *mut c_void, image2_rec: *mut c_void, new_size: core::Size, knew: *mut c_void, point_cloud: *mut c_void, point_type: i32) -> cv_return_value_void;
        pub fn cv_omnidir_stereoRectify__InputArray__InputArray__OutputArray__OutputArray(r: *mut c_void, t: *mut c_void, r1: *mut c_void, r2: *mut c_void) -> cv_return_value_void;
        pub fn cv_omnidir_undistortImage__InputArray__OutputArray__InputArray__InputArray__InputArray_int__InputArray_Size__InputArray(distorted: *mut c_void, undistorted: *mut c_void, k: *mut c_void, d: *mut c_void, xi: *mut c_void, flags: i32, knew: *mut c_void, new_size: core::Size, r: *mut c_void) -> cv_return_value_void;
        pub fn cv_omnidir_undistortPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray(distorted: *mut c_void, undistorted: *mut c_void, k: *mut c_void, d: *mut c_void, xi: *mut c_void, r: *mut c_void) -> cv_return_value_void;
        pub fn cv_CustomPattern_delete(ptr : *mut c_void);
        pub fn cv_ccalib_CustomPattern_CustomPattern() -> cv_return_value_void_X;
        pub fn cv_ccalib_CustomPattern_create__InputArray_Size2f__OutputArray(instance: *mut c_void, pattern: *mut c_void, board_size: core::Size2f, output: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ccalib_CustomPattern_findPattern__InputArray__OutputArray__OutputArray_double_double_bool__OutputArray__OutputArray__OutputArray(instance: *mut c_void, image: *mut c_void, matched_features: *mut c_void, pattern_points: *mut c_void, ratio: f64, proj_error: f64, refine_position: bool, out: *mut c_void, h: *mut c_void, pattern_corners: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ccalib_CustomPattern_isInitialized(instance: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ccalib_CustomPattern_getPatternPoints__OutputArray(instance: *mut c_void, original_points: *mut c_void) -> cv_return_value_void;
        pub fn cv_ccalib_CustomPattern_getPixelSize(instance: *mut c_void) -> cv_return_value_double;
        pub fn cv_ccalib_CustomPattern_setFeatureDetector_PtrOfFeature2D(instance: *mut c_void, feature_detector: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ccalib_CustomPattern_setDescriptorExtractor_PtrOfFeature2D(instance: *mut c_void, extractor: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ccalib_CustomPattern_setDescriptorMatcher_PtrOfDescriptorMatcher(instance: *mut c_void, matcher: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ccalib_CustomPattern_getFeatureDetector(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ccalib_CustomPattern_getDescriptorExtractor(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ccalib_CustomPattern_getDescriptorMatcher(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ccalib_CustomPattern_calibrate__InputArray__InputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray_int_TermCriteria(instance: *mut c_void, object_points: *mut c_void, image_points: *mut c_void, image_size: core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void) -> cv_return_value_double;
        pub fn cv_ccalib_CustomPattern_findRt__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_int(instance: *mut c_void, object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, flags: i32) -> cv_return_value_bool;
        pub fn cv_ccalib_CustomPattern_findRt__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_int(instance: *mut c_void, image: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, flags: i32) -> cv_return_value_bool;
        pub fn cv_ccalib_CustomPattern_findRtRANSAC__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_int_float_int__OutputArray_int(instance: *mut c_void, object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, iterations_count: i32, reprojection_error: f32, min_inliers_count: i32, inliers: *mut c_void, flags: i32) -> cv_return_value_bool;
        pub fn cv_ccalib_CustomPattern_findRtRANSAC__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_int_float_int__OutputArray_int(instance: *mut c_void, image: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, iterations_count: i32, reprojection_error: f32, min_inliers_count: i32, inliers: *mut c_void, flags: i32) -> cv_return_value_bool;
        pub fn cv_ccalib_CustomPattern_drawOrientation__InputOutputArray__InputArray__InputArray__InputArray__InputArray_double_int(instance: *mut c_void, image: *mut c_void, tvec: *mut c_void, rvec: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, axis_length: f64, axis_width: i32) -> cv_return_value_void;
        pub fn cv_MultiCameraCalibration_delete(ptr : *mut c_void);
        pub fn cv_multicalib_MultiCameraCalibration_MultiCameraCalibration_int_int_std_string_float_float_int_int_int_int_TermCriteria_PtrOfFeature2D_PtrOfFeature2D_PtrOfDescriptorMatcher(camera_type: i32, n_cameras: i32, file_name: *const c_char, pattern_width: f32, pattern_height: f32, verbose: i32, show_extration: i32, n_mini_matches: i32, flags: i32, criteria: *mut c_void, detector: *mut c_void, descriptor: *mut c_void, matcher: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_multicalib_MultiCameraCalibration_loadImages(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_multicalib_MultiCameraCalibration_initialize(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_multicalib_MultiCameraCalibration_optimizeExtrinsics(instance: *mut c_void) -> cv_return_value_double;
        pub fn cv_multicalib_MultiCameraCalibration_run(instance: *mut c_void) -> cv_return_value_double;
        pub fn cv_multicalib_MultiCameraCalibration_writeParameters_std_string(instance: *mut c_void, filename: *const c_char) -> cv_return_value_void;
        pub fn cv_MultiCameraCalibration_edge_delete(ptr : *mut c_void);
        pub fn cv_multicalib_MultiCameraCalibration_edge_edge_int_int_int_Mat(cv: i32, pv: i32, pi: i32, trans: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_MultiCameraCalibration_vertex_delete(ptr : *mut c_void);
        pub fn cv_multicalib_MultiCameraCalibration_vertex_vertex_Mat_int(po: *mut c_void, ts: i32) -> cv_return_value_void_X;
        pub fn cv_multicalib_MultiCameraCalibration_vertex_vertex() -> cv_return_value_void_X;
        pub fn cv_RandomPatternCornerFinder_delete(ptr : *mut c_void);
        pub fn cv_randpattern_RandomPatternCornerFinder_RandomPatternCornerFinder_float_float_int_int_int_int_PtrOfFeature2D_PtrOfFeature2D_PtrOfDescriptorMatcher(pattern_width: f32, pattern_height: f32, nmini_match: i32, depth: i32, verbose: i32, show_extraction: i32, detector: *mut c_void, descriptor: *mut c_void, matcher: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_randpattern_RandomPatternCornerFinder_loadPattern_Mat(instance: *mut c_void, pattern_image: *mut c_void) -> cv_return_value_void;
        pub fn cv_randpattern_RandomPatternCornerFinder_computeObjectImagePoints_VectorOfMat(instance: *mut c_void, input_images: *mut c_void) -> cv_return_value_void;
        pub fn cv_randpattern_RandomPatternCornerFinder_computeObjectImagePointsForSingle_Mat(instance: *mut c_void, input_image: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_randpattern_RandomPatternCornerFinder_getObjectPoints(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_randpattern_RandomPatternCornerFinder_getImagePoints(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_RandomPatternGenerator_delete(ptr : *mut c_void);
        pub fn cv_randpattern_RandomPatternGenerator_RandomPatternGenerator_int_int(image_width: i32, image_height: i32) -> cv_return_value_void_X;
        pub fn cv_randpattern_RandomPatternGenerator_generatePattern(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_randpattern_RandomPatternGenerator_getPattern(instance: *mut c_void) -> cv_return_value_void_X;
    
    }
}
#[cfg(feature = "contrib")]
pub use ccalib_sys::*;

#[cfg(feature = "contrib")]
mod cvv_sys {
    use super::*;

    extern "C" {
        pub fn cvv_debugMode() -> cv_return_value_bool;
        pub fn cvv_finalShow() -> cv_return_value_void;
        pub fn cvv_impl_finalShow() -> cv_return_value_void;
        pub fn cvv_impl_getDebugFlag() -> cv_return_value_bool;
        pub fn cvv_setDebugFlag_bool(active: bool) -> cv_return_value_void;
        pub fn cv_FinalShowCaller_delete(ptr : *mut c_void);
        pub fn cv_CallMetaData_delete(ptr : *mut c_void);
        pub fn cvv_impl_CallMetaData_CallMetaData() -> cv_return_value_void_X;
        pub fn cvv_impl_CallMetaData_CallMetaData_const_char_X_size_t_const_char_X(file: *const c_char, line: size_t, function: *const c_char) -> cv_return_value_void_X;
        pub fn cvv_impl_CallMetaData_operator_bool(instance: *mut c_void) -> cv_return_value_bool;
    
    }
}
#[cfg(feature = "contrib")]
pub use cvv_sys::*;

#[cfg(feature = "contrib")]
mod dnn_sys {
    use super::*;

    extern "C" {
        pub fn cv_dnn_computeShapeByReshapeMask_BlobShape_BlobShape_Range(src_shape: *mut c_void, mask_shape: *mut c_void, src_range: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_createCaffeImporter_String_String(prototxt: *const c_char, caffe_model: *const c_char) -> cv_return_value_void_X;
        pub fn cv_dnn_createTensorflowImporter_String(model: *const c_char) -> cv_return_value_void_X;
        pub fn cv_dnn_createTorchImporter_String_bool(filename: *const c_char, is_binary: bool) -> cv_return_value_void_X;
        pub fn cv_dnn_initModule() -> cv_return_value_void;
        pub fn cv_dnn_readNetFromCaffe_String_String(prototxt: *const c_char, caffe_model: *const c_char) -> cv_return_value_void_X;
        pub fn cv_dnn_readTorchBlob_String_bool(filename: *const c_char, is_binary: bool) -> cv_return_value_void_X;
        pub fn cv_AbsLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_AbsLayer_create() -> cv_return_value_void_X;
        pub fn cv_BNLLLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_BNLLLayer_create() -> cv_return_value_void_X;
        pub fn cv_dnn_BaseConvolutionLayer_kernel_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_dnn_BaseConvolutionLayer_set_kernel_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_dnn_BaseConvolutionLayer_stride_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_dnn_BaseConvolutionLayer_set_stride_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_dnn_BaseConvolutionLayer_pad_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_dnn_BaseConvolutionLayer_set_pad_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_dnn_BaseConvolutionLayer_dilation_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_dnn_BaseConvolutionLayer_set_dilation_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_dnn_BaseConvolutionLayer_padMode(instance: *mut c_void) -> cv_return_value_char_X;
        pub fn cv_dnn_BaseConvolutionLayer_set_padMode_String(instance: *mut c_void, val: *mut c_char) -> cv_return_value_void;
        pub fn cv_BaseConvolutionLayer_delete(ptr : *mut c_void);
        pub fn cv_Blob_delete(ptr : *mut c_void);
        pub fn cv_dnn_Blob_Blob() -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_Blob_BlobShape_int_int(shape: *mut c_void, _type: i32, alloc_flags: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_Blob__InputArray(data: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_fromImages__InputArray_int(image: *mut c_void, dst_cn: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_batchFromImages__InputArray_int(instance: *mut c_void, image: *mut c_void, dst_cn: i32) -> cv_return_value_void;
        pub fn cv_dnn_Blob_create_BlobShape_int_int(instance: *mut c_void, shape: *mut c_void, _type: i32, alloc_flags: i32) -> cv_return_value_void;
        pub fn cv_dnn_Blob_fill__InputArray(instance: *mut c_void, _in: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Blob_fill_BlobShape_int_void_X_bool(instance: *mut c_void, shape: *mut c_void, _type: i32, data: *mut c_void, deep_copy: bool) -> cv_return_value_void;
        pub fn cv_dnn_Blob_setTo__InputArray_int(instance: *mut c_void, value: *mut c_void, alloc_flags: i32) -> cv_return_value_void;
        pub fn cv_dnn_Blob_matRef_bool(instance: *mut c_void, write_only: bool) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_matRefConst_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_umatRef_bool(instance: *mut c_void, write_only: bool) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_umatRefConst_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_updateMat_const_bool(instance: *const c_void, sync_data: bool) -> cv_return_value_void;
        pub fn cv_dnn_Blob_updateUMat_const_bool(instance: *const c_void, sync_data: bool) -> cv_return_value_void;
        pub fn cv_dnn_Blob_sync_const(instance: *const c_void) -> cv_return_value_void;
        pub fn cv_dnn_Blob_dims_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_Blob_size_const_int(instance: *const c_void, axis: i32) -> cv_return_value_int;
        pub fn cv_dnn_Blob_xsize_const_int(instance: *const c_void, axis: i32) -> cv_return_value_int;
        pub fn cv_dnn_Blob_total_const_int_int(instance: *const c_void, start_axis: i32, end_axis: i32) -> cv_return_value_std_size_t;
        pub fn cv_dnn_Blob_canonicalAxis_const_int(instance: *const c_void, axis: i32) -> cv_return_value_int;
        pub fn cv_dnn_Blob_shape_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_equalShape_const_Blob(instance: *const c_void, other: *mut c_void) -> cv_return_value_bool;
        pub fn cv_dnn_Blob_getPlane_int_int(instance: *mut c_void, n: i32, cn: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_getPlanes_int(instance: *mut c_void, n: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_cols_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_Blob_rows_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_Blob_channels_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_Blob_num_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_Blob_size2_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_dnn_Blob_shape4_const(instance: *const c_void) -> cv_return_value_Vec4iWrapper;
        pub fn cv_dnn_Blob_offset_const_int_int_int_int(instance: *const c_void, n: i32, cn: i32, row: i32, col: i32) -> cv_return_value_std_size_t;
        pub fn cv_dnn_Blob_ptr_int_int_int_int(instance: *mut c_void, n: i32, cn: i32, row: i32, col: i32) -> cv_return_value_unsigned_char_X;
        pub fn cv_dnn_Blob_ptrf_int_int_int_int(instance: *mut c_void, n: i32, cn: i32, row: i32, col: i32) -> cv_return_value_float_X;
        pub fn cv_dnn_Blob_shareFrom_Blob(instance: *mut c_void, blob: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_reshape_BlobShape(instance: *mut c_void, shape: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_reshaped_const_BlobShape(instance: *const c_void, new_shape: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_Blob_type_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_Blob_elemSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_Blob_getState_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BlobShape_delete(ptr : *mut c_void);
        pub fn cv_dnn_BlobShape_BlobShape() -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_BlobShape_int(s0: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_BlobShape_int_int(s0: i32, s1: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_BlobShape_int_int_int(s0: i32, s1: i32, s2: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_BlobShape_int_int_int_int(num: i32, cn: i32, rows: i32, cols: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_BlobShape_int_const_int_X(ndims: i32, sizes: *const i32) -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_BlobShape_VectorOfint(sizes: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_all_int_int(ndims: i32, fill: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_dims_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_BlobShape_size_int(instance: *mut c_void, axis: i32) -> cv_return_value_int;
        pub fn cv_dnn_BlobShape_size_const_int(instance: *const c_void, axis: i32) -> cv_return_value_int;
        pub fn cv_dnn_BlobShape_xsize_const_int(instance: *const c_void, axis: i32) -> cv_return_value_int;
        pub fn cv_dnn_BlobShape_canonicalAxis_const_int(instance: *const c_void, axis: i32) -> cv_return_value_int;
        pub fn cv_dnn_BlobShape_total_const(instance: *const c_void) -> cv_return_value_std_ptrdiff_t;
        pub fn cv_dnn_BlobShape_total_const_int_int(instance: *const c_void, start_axis: i32, end_axis: i32) -> cv_return_value_std_ptrdiff_t;
        pub fn cv_dnn_BlobShape_slice_const_int_int(instance: *const c_void, start_axis: i32, end_axis: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_ptr_const(instance: *const c_void) -> cv_return_value_const_int_X;
        pub fn cv_dnn_BlobShape_ptr(instance: *mut c_void) -> cv_return_value_int_X;
        pub fn cv_dnn_BlobShape_equal_const_BlobShape(instance: *const c_void, other: *mut c_void) -> cv_return_value_bool;
        pub fn cv_dnn_BlobShape_like_Mat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_like_UMat(m: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_empty() -> cv_return_value_void_X;
        pub fn cv_dnn_BlobShape_isEmpty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ConcatLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_ConcatLayer_create_int(axis: i32) -> cv_return_value_void_X;
        pub fn cv_ConvolutionLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_ConvolutionLayer_create_Size_Size_Size_Size(kernel: core::Size, stride: core::Size, pad: core::Size, dilation: core::Size) -> cv_return_value_void_X;
        pub fn cv_CropLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_CropLayer_startAxis_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_CropLayer_set_startAxis_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_dnn_CropLayer_create_int_VectorOfint(start_axis: i32, offset: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_DeconvolutionLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_DeconvolutionLayer_create_Size_Size_Size_Size(kernel: core::Size, stride: core::Size, pad: core::Size, dilation: core::Size) -> cv_return_value_void_X;
        pub fn cv_dnn_Dict_has_const_String(instance: *const c_void, key: *const c_char) -> cv_return_value_bool;
        pub fn cv_dnn_Dict_ptr_String(instance: *mut c_void, key: *const c_char) -> cv_return_value_void_X;
        pub fn cv_dnn_Dict_get_const_String(instance: *const c_void, key: *const c_char) -> cv_return_value_void_X;
        pub fn cv_dnn_Dict_set_String_DictValue(instance: *mut c_void, key: *const c_char, value: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_Dict_delete(ptr : *mut c_void);
        pub fn cv_DictValue_delete(ptr : *mut c_void);
        pub fn cv_dnn_DictValue_DictValue_DictValue(r: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_DictValue_DictValue_int64(i: i64) -> cv_return_value_void_X;
        pub fn cv_dnn_DictValue_DictValue_int(i: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_DictValue_DictValue_unsigned(p: u32) -> cv_return_value_void_X;
        pub fn cv_dnn_DictValue_DictValue_double(p: f64) -> cv_return_value_void_X;
        pub fn cv_dnn_DictValue_DictValue_const_char_X(s: *const c_char) -> cv_return_value_void_X;
        pub fn cv_dnn_DictValue_size_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_DictValue_isInt_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_dnn_DictValue_isString_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_dnn_DictValue_isReal_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_EltwiseLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_Importer_populateNet_Net(instance: *mut c_void, net: *mut c_void) -> cv_return_value_void;
        pub fn cv_InnerProductLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_InnerProductLayer_axis_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_InnerProductLayer_set_axis_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_dnn_InnerProductLayer_create_int(axis: i32) -> cv_return_value_void_X;
        pub fn cv_LRNLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_LRNLayer_type_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_LRNLayer_set_type_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_dnn_LRNLayer_size_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_LRNLayer_set_size_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_dnn_LRNLayer_alpha_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_dnn_LRNLayer_set_alpha_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_dnn_LRNLayer_beta_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_dnn_LRNLayer_set_beta_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_dnn_LRNLayer_bias_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_dnn_LRNLayer_set_bias_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_dnn_LRNLayer_normBySize_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_dnn_LRNLayer_set_normBySize_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_dnn_LRNLayer_create_int_int_double_double_double_bool(_type: i32, size: i32, alpha: f64, beta: f64, bias: f64, norm_by_size: bool) -> cv_return_value_void_X;
        pub fn cv_dnn_LSTMLayer_setWeights_Blob_Blob_Blob(instance: *mut c_void, wh: *mut c_void, wx: *mut c_void, b: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_LSTMLayer_setOutShape_BlobShape(instance: *mut c_void, out_tail_shape: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_LSTMLayer_setH_Blob(instance: *mut c_void, h: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_LSTMLayer_getH_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_LSTMLayer_setC_Blob(instance: *mut c_void, c: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_LSTMLayer_getC_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_LSTMLayer_setUseTimstampsDim_bool(instance: *mut c_void, _use: bool) -> cv_return_value_void;
        pub fn cv_dnn_LSTMLayer_setProduceCellOutput_bool(instance: *mut c_void, produce: bool) -> cv_return_value_void;
        pub fn cv_dnn_LSTMLayer_inputNameToIndex_String(instance: *mut c_void, input_name: *mut c_char) -> cv_return_value_int;
        pub fn cv_dnn_LSTMLayer_outputNameToIndex_String(instance: *mut c_void, output_name: *mut c_char) -> cv_return_value_int;
        pub fn cv_dnn_LSTMLayer_create() -> cv_return_value_void_X;
        pub fn cv_dnn_Layer_name(instance: *mut c_void) -> cv_return_value_char_X;
        pub fn cv_dnn_Layer_set_name_String(instance: *mut c_void, val: *mut c_char) -> cv_return_value_void;
        pub fn cv_dnn_Layer_type(instance: *mut c_void) -> cv_return_value_char_X;
        pub fn cv_dnn_Layer_set_type_String(instance: *mut c_void, val: *mut c_char) -> cv_return_value_void;
        pub fn cv_dnn_Layer_allocate_VectorOfBlob_VectorOfBlob(instance: *mut c_void, inputs: *mut c_void, outputs: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Layer_allocate_VectorOfBlob(instance: *mut c_void, inputs: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_Layer_forward_VectorOfBlob_VectorOfBlob(instance: *mut c_void, inputs: *mut c_void, outputs: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Layer_run_VectorOfBlob_VectorOfBlob(instance: *mut c_void, inputs: *mut c_void, outputs: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Layer_inputNameToIndex_String(instance: *mut c_void, input_name: *mut c_char) -> cv_return_value_int;
        pub fn cv_dnn_Layer_outputNameToIndex_String(instance: *mut c_void, output_name: *mut c_char) -> cv_return_value_int;
        pub fn cv_dnn_Layer_setParamsFrom_LayerParams(instance: *mut c_void, params: *mut c_void) -> cv_return_value_void;
        pub fn cv_LayerFactory_delete(ptr : *mut c_void);
        pub fn cv_dnn_LayerFactory_unregisterLayer_String(_type: *const c_char) -> cv_return_value_void;
        pub fn cv_dnn_LayerFactory_createLayerInstance_String_LayerParams(_type: *const c_char, params: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_LayerParams_delete(ptr : *mut c_void);
        pub fn cv_dnn_LayerParams_name(instance: *mut c_void) -> cv_return_value_char_X;
        pub fn cv_dnn_LayerParams_set_name_String(instance: *mut c_void, val: *mut c_char) -> cv_return_value_void;
        pub fn cv_dnn_LayerParams_type(instance: *mut c_void) -> cv_return_value_char_X;
        pub fn cv_dnn_LayerParams_set_type_String(instance: *mut c_void, val: *mut c_char) -> cv_return_value_void;
        pub fn cv_dnn_LayerParams_LayerParams() -> cv_return_value_void_X;
        pub fn cv_MVNLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_MVNLayer_eps_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_dnn_MVNLayer_set_eps_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_dnn_MVNLayer_normVariance_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_dnn_MVNLayer_set_normVariance_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_dnn_MVNLayer_acrossChannels_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_dnn_MVNLayer_set_acrossChannels_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_dnn_MVNLayer_create_bool_bool_double(norm_variance: bool, across_channels: bool, eps: f64) -> cv_return_value_void_X;
        pub fn cv_Net_delete(ptr : *mut c_void);
        pub fn cv_dnn_Net_Net() -> cv_return_value_void_X;
        pub fn cv_dnn_Net_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_dnn_Net_addLayer_String_String_LayerParams(instance: *mut c_void, name: *const c_char, _type: *const c_char, params: *mut c_void) -> cv_return_value_int;
        pub fn cv_dnn_Net_addLayerToPrev_String_String_LayerParams(instance: *mut c_void, name: *const c_char, _type: *const c_char, params: *mut c_void) -> cv_return_value_int;
        pub fn cv_dnn_Net_getLayerId_String(instance: *mut c_void, layer: *const c_char) -> cv_return_value_int;
        pub fn cv_dnn_Net_getLayerNames_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_Net_getLayer_DictValue(instance: *mut c_void, layer_id: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_Net_deleteLayer_DictValue(instance: *mut c_void, layer: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Net_connect_String_String(instance: *mut c_void, out_pin: *mut c_char, inp_pin: *mut c_char) -> cv_return_value_void;
        pub fn cv_dnn_Net_connect_int_int_int_int(instance: *mut c_void, out_layer_id: i32, out_num: i32, inp_layer_id: i32, inp_num: i32) -> cv_return_value_void;
        pub fn cv_dnn_Net_setNetInputs_VectorOfString(instance: *mut c_void, input_blob_names: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Net_allocate(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Net_forward_DictValue(instance: *mut c_void, to_layer: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Net_forward_DictValue_DictValue(instance: *mut c_void, start_layer: *mut c_void, to_layer: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Net_forward_VectorOfDictValue_VectorOfDictValue(instance: *mut c_void, start_layers: *mut c_void, to_layers: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Net_forwardOpt_DictValue(instance: *mut c_void, to_layer: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Net_forwardOpt_VectorOfDictValue(instance: *mut c_void, to_layers: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Net_setBlob_String_Blob(instance: *mut c_void, output_name: *mut c_char, blob: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Net_getBlob_String(instance: *mut c_void, output_name: *mut c_char) -> cv_return_value_void_X;
        pub fn cv_dnn_Net_setParam_DictValue_int_Blob(instance: *mut c_void, layer: *mut c_void, num_param: i32, blob: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_Net_getParam_DictValue_int(instance: *mut c_void, layer: *mut c_void, num_param: i32) -> cv_return_value_void_X;
        pub fn cv_PoolingLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_PoolingLayer_type_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_PoolingLayer_set_type_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_dnn_PoolingLayer_kernel_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_dnn_PoolingLayer_set_kernel_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_dnn_PoolingLayer_stride_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_dnn_PoolingLayer_set_stride_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_dnn_PoolingLayer_pad_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_dnn_PoolingLayer_set_pad_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_dnn_PoolingLayer_globalPooling_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_dnn_PoolingLayer_set_globalPooling_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_dnn_PoolingLayer_padMode(instance: *mut c_void) -> cv_return_value_char_X;
        pub fn cv_dnn_PoolingLayer_set_padMode_String(instance: *mut c_void, val: *mut c_char) -> cv_return_value_void;
        pub fn cv_dnn_PoolingLayer_create_int_Size_Size_Size_String(_type: i32, kernel: core::Size, stride: core::Size, pad: core::Size, pad_mode: *const c_char) -> cv_return_value_void_X;
        pub fn cv_dnn_PoolingLayer_createGlobal_int(_type: i32) -> cv_return_value_void_X;
        pub fn cv_PowerLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_PowerLayer_power_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_dnn_PowerLayer_set_power_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_dnn_PowerLayer_scale_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_dnn_PowerLayer_set_scale_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_dnn_PowerLayer_shift_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_dnn_PowerLayer_set_shift_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_dnn_PowerLayer_create_double_double_double(power: f64, scale: f64, shift: f64) -> cv_return_value_void_X;
        pub fn cv_dnn_RNNLayer_setWeights_Blob_Blob_Blob_Blob_Blob(instance: *mut c_void, wxh: *mut c_void, bh: *mut c_void, whh: *mut c_void, who: *mut c_void, bo: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_RNNLayer_setProduceHiddenOutput_bool(instance: *mut c_void, produce: bool) -> cv_return_value_void;
        pub fn cv_dnn_RNNLayer_create() -> cv_return_value_void_X;
        pub fn cv_ReLULayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_ReLULayer_negativeSlope_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_dnn_ReLULayer_set_negativeSlope_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_dnn_ReLULayer_create_double(negative_slope: f64) -> cv_return_value_void_X;
        pub fn cv_ReshapeLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_ReshapeLayer_newShapeDesc(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_ReshapeLayer_set_newShapeDesc_BlobShape(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_ReshapeLayer_newShapeRange(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_dnn_ReshapeLayer_set_newShapeRange_Range(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_dnn_ReshapeLayer_create_BlobShape_Range_bool(new_shape: *mut c_void, applying_range: *mut c_void, enable_reordering: bool) -> cv_return_value_void_X;
        pub fn cv_SigmoidLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_SigmoidLayer_create() -> cv_return_value_void_X;
        pub fn cv_SliceLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_SliceLayer_axis_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_dnn_SliceLayer_set_axis_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_dnn_SliceLayer_create_int(axis: i32) -> cv_return_value_void_X;
        pub fn cv_dnn_SliceLayer_create_int_VectorOfint(axis: i32, slice_indices: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_SoftmaxLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_SoftmaxLayer_create_int(axis: i32) -> cv_return_value_void_X;
        pub fn cv_SplitLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_SplitLayer_create_int(outputs_count: i32) -> cv_return_value_void_X;
        pub fn cv_TanHLayer_delete(ptr : *mut c_void);
        pub fn cv_dnn_TanHLayer_create() -> cv_return_value_void_X;
        pub fn cv__LayerStaticRegisterer_delete(ptr : *mut c_void);
    
    }
}
#[cfg(feature = "contrib")]
pub use dnn_sys::*;

#[cfg(feature = "contrib")]
mod dpm_sys {
    use super::*;

    extern "C" {
        pub fn cv_dpm_DPMDetector_isEmpty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_dpm_DPMDetector_detect_Mat_VectorOfObjectDetection(instance: *mut c_void, image: *mut c_void, objects: *mut c_void) -> cv_return_value_void;
        pub fn cv_dpm_DPMDetector_getClassCount_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_DPMDetector_ObjectDetection_delete(ptr : *mut c_void);
        pub fn cv_dpm_DPMDetector_ObjectDetection_ObjectDetection() -> cv_return_value_void_X;
        pub fn cv_dpm_DPMDetector_ObjectDetection_ObjectDetection_Rect_float_int(rect: core::Rect, score: f32, class_id: i32) -> cv_return_value_void_X;
    
    }
}
#[cfg(feature = "contrib")]
pub use dpm_sys::*;

#[cfg(feature = "contrib")]
mod face_sys {
    use super::*;

    extern "C" {
        pub fn cv_face_createEigenFaceRecognizer_int_double(num_components: i32, threshold: f64) -> cv_return_value_void_X;
        pub fn cv_face_createFisherFaceRecognizer_int_double(num_components: i32, threshold: f64) -> cv_return_value_void_X;
        pub fn cv_face_createLBPHFaceRecognizer_int_int_int_int_double(radius: i32, neighbors: i32, grid_x: i32, grid_y: i32, threshold: f64) -> cv_return_value_void_X;
        pub fn cv_face_BIF_getNumBands_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_face_BIF_getNumRotations_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_face_BIF_compute_const__InputArray__OutputArray(instance: *const c_void, image: *mut c_void, features: *mut c_void) -> cv_return_value_void;
        pub fn cv_face_BasicFaceRecognizer_getNumComponents_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_face_BasicFaceRecognizer_setNumComponents_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_face_BasicFaceRecognizer_getThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_face_BasicFaceRecognizer_setThreshold_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_face_BasicFaceRecognizer_getProjections_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_face_BasicFaceRecognizer_getLabels_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_face_BasicFaceRecognizer_getEigenValues_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_face_BasicFaceRecognizer_getEigenVectors_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_face_BasicFaceRecognizer_getMean_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_face_FaceRecognizer_train__InputArray__InputArray(instance: *mut c_void, src: *mut c_void, labels: *mut c_void) -> cv_return_value_void;
        pub fn cv_face_FaceRecognizer_update__InputArray__InputArray(instance: *mut c_void, src: *mut c_void, labels: *mut c_void) -> cv_return_value_void;
        pub fn cv_face_FaceRecognizer_predict_const__InputArray(instance: *const c_void, src: *mut c_void) -> cv_return_value_int;
        pub fn cv_face_FaceRecognizer_predict_const__InputArray_int_double(instance: *const c_void, src: *mut c_void, label: *mut i32, confidence: *mut f64) -> cv_return_value_void;
        pub fn cv_face_FaceRecognizer_save_const_String(instance: *const c_void, filename: *const c_char) -> cv_return_value_void;
        pub fn cv_face_FaceRecognizer_load_String(instance: *mut c_void, filename: *const c_char) -> cv_return_value_void;
        pub fn cv_face_FaceRecognizer_save_const_FileStorage(instance: *const c_void, fs: *mut c_void) -> cv_return_value_void;
        pub fn cv_face_FaceRecognizer_load_FileStorage(instance: *mut c_void, fs: *mut c_void) -> cv_return_value_void;
        pub fn cv_face_FaceRecognizer_setLabelInfo_int_String(instance: *mut c_void, label: i32, str_info: *const c_char) -> cv_return_value_void;
        pub fn cv_face_FaceRecognizer_getLabelInfo_const_int(instance: *const c_void, label: i32) -> cv_return_value_char_X;
        pub fn cv_face_FaceRecognizer_getLabelsByString_const_String(instance: *const c_void, str: *const c_char) -> cv_return_value_void_X;
        pub fn cv_face_FaceRecognizer_getThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_face_FaceRecognizer_setThreshold_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_face_LBPHFaceRecognizer_getGridX_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_face_LBPHFaceRecognizer_setGridX_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_face_LBPHFaceRecognizer_getGridY_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_face_LBPHFaceRecognizer_setGridY_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_face_LBPHFaceRecognizer_getRadius_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_face_LBPHFaceRecognizer_setRadius_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_face_LBPHFaceRecognizer_getNeighbors_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_face_LBPHFaceRecognizer_setNeighbors_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_face_LBPHFaceRecognizer_getThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_face_LBPHFaceRecognizer_setThreshold_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_face_LBPHFaceRecognizer_getHistograms_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_face_LBPHFaceRecognizer_getLabels_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_face_PredictCollector_init_size_t(instance: *mut c_void, size: size_t) -> cv_return_value_void;
        pub fn cv_face_PredictCollector_collect_int_double(instance: *mut c_void, label: i32, dist: f64) -> cv_return_value_bool;
        pub fn cv_StandardCollector_delete(ptr : *mut c_void);
        pub fn cv_face_StandardCollector_StandardCollector_double(threshold_: f64) -> cv_return_value_void_X;
        pub fn cv_face_StandardCollector_init_size_t(instance: *mut c_void, size: size_t) -> cv_return_value_void;
        pub fn cv_face_StandardCollector_collect_int_double(instance: *mut c_void, label: i32, dist: f64) -> cv_return_value_bool;
        pub fn cv_face_StandardCollector_getMinLabel_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_face_StandardCollector_getMinDist_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_face_StandardCollector_create_double(threshold: f64) -> cv_return_value_void_X;
        pub fn cv_StandardCollector_PredictResult_delete(ptr : *mut c_void);
        pub fn cv_face_StandardCollector_PredictResult_PredictResult_int_double(label_: i32, distance_: f64) -> cv_return_value_void_X;
    
    }
}
#[cfg(feature = "contrib")]
pub use face_sys::*;

mod features2d_sys {
    use super::*;

    pub type cv_return_value_SimpleBlobDetector_Params = cv_return_value<crate::features2d::SimpleBlobDetector_Params>;
    extern "C" {
        pub fn cv_AGAST__InputArray_VectorOfKeyPoint_int_bool(image: *mut c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool) -> cv_return_value_void;
        pub fn cv_AGAST__InputArray_VectorOfKeyPoint_int_bool_int(image: *mut c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, _type: i32) -> cv_return_value_void;
        pub fn cv_FAST__InputArray_VectorOfKeyPoint_int_bool(image: *mut c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool) -> cv_return_value_void;
        pub fn cv_FAST__InputArray_VectorOfKeyPoint_int_bool_int(image: *mut c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, _type: i32) -> cv_return_value_void;
        pub fn cv_computeRecallPrecisionCurve_VectorOfVectorOfDMatch_VectorOfVectorOfuchar_VectorOfPoint2f(matches1to2: *mut c_void, correct_matches1to2_mask: *mut c_void, recall_precision_curve: *mut c_void) -> cv_return_value_void;
        pub fn cv_drawKeypoints__InputArray_VectorOfKeyPoint__InputOutputArray_Scalar_int(image: *mut c_void, keypoints: *mut c_void, out_image: *mut c_void, color: core::Scalar, flags: i32) -> cv_return_value_void;
        pub fn cv_drawMatches__InputArray_VectorOfKeyPoint__InputArray_VectorOfKeyPoint_VectorOfDMatch__InputOutputArray_Scalar_Scalar_VectorOfchar_int(img1: *mut c_void, keypoints1: *mut c_void, img2: *mut c_void, keypoints2: *mut c_void, matches1to2: *mut c_void, out_img: *mut c_void, match_color: core::Scalar, single_point_color: core::Scalar, matches_mask: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_drawMatches__InputArray_VectorOfKeyPoint__InputArray_VectorOfKeyPoint_VectorOfVectorOfDMatch__InputOutputArray_Scalar_Scalar_VectorOfVectorOfchar_int(img1: *mut c_void, keypoints1: *mut c_void, img2: *mut c_void, keypoints2: *mut c_void, matches1to2: *mut c_void, out_img: *mut c_void, match_color: core::Scalar, single_point_color: core::Scalar, matches_mask: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_evaluateFeatureDetector_Mat_Mat_Mat_VectorOfKeyPoint_VectorOfKeyPoint_float_int_PtrOfFeature2D(img1: *mut c_void, img2: *mut c_void, h1to2: *mut c_void, keypoints1: *mut c_void, keypoints2: *mut c_void, repeatability: *mut f32, corresp_count: *mut i32, fdetector: *mut c_void) -> cv_return_value_void;
        pub fn cv_getNearestPoint_VectorOfPoint2f_float(recall_precision_curve: *mut c_void, l_precision: f32) -> cv_return_value_int;
        pub fn cv_getRecall_VectorOfPoint2f_float(recall_precision_curve: *mut c_void, l_precision: f32) -> cv_return_value_float;
        pub fn cv_AKAZE_setDescriptorType_int(instance: *mut c_void, dtype: i32) -> cv_return_value_void;
        pub fn cv_AKAZE_getDescriptorType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_AKAZE_setDescriptorSize_int(instance: *mut c_void, dsize: i32) -> cv_return_value_void;
        pub fn cv_AKAZE_getDescriptorSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_AKAZE_setDescriptorChannels_int(instance: *mut c_void, dch: i32) -> cv_return_value_void;
        pub fn cv_AKAZE_getDescriptorChannels_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_AKAZE_setThreshold_double(instance: *mut c_void, threshold: f64) -> cv_return_value_void;
        pub fn cv_AKAZE_getThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_AKAZE_setNOctaves_int(instance: *mut c_void, octaves: i32) -> cv_return_value_void;
        pub fn cv_AKAZE_getNOctaves_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_AKAZE_setNOctaveLayers_int(instance: *mut c_void, octave_layers: i32) -> cv_return_value_void;
        pub fn cv_AKAZE_getNOctaveLayers_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_AKAZE_setDiffusivity_int(instance: *mut c_void, diff: i32) -> cv_return_value_void;
        pub fn cv_AKAZE_getDiffusivity_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_AKAZE_create_int_int_int_float_int_int_int(descriptor_type: i32, descriptor_size: i32, descriptor_channels: i32, threshold: f32, n_octaves: i32, n_octave_layers: i32, diffusivity: i32) -> cv_return_value_void_X;
        pub fn cv_AgastFeatureDetector_setThreshold_int(instance: *mut c_void, threshold: i32) -> cv_return_value_void;
        pub fn cv_AgastFeatureDetector_getThreshold_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_AgastFeatureDetector_setNonmaxSuppression_bool(instance: *mut c_void, f: bool) -> cv_return_value_void;
        pub fn cv_AgastFeatureDetector_getNonmaxSuppression_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_AgastFeatureDetector_setType_int(instance: *mut c_void, _type: i32) -> cv_return_value_void;
        pub fn cv_AgastFeatureDetector_getType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_AgastFeatureDetector_create_int_bool_int(threshold: i32, nonmax_suppression: bool, _type: i32) -> cv_return_value_void_X;
        pub fn cv_BFMatcher_delete(ptr : *mut c_void);
        pub fn cv_BFMatcher_BFMatcher_int_bool(norm_type: i32, cross_check: bool) -> cv_return_value_void_X;
        pub fn cv_BFMatcher_isMaskSupported_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_BFMatcher_create_int_bool(norm_type: i32, cross_check: bool) -> cv_return_value_void_X;
        pub fn cv_BFMatcher_clone_const_bool(instance: *const c_void, empty_train_data: bool) -> cv_return_value_void_X;
        pub fn cv_BOWImgDescriptorExtractor_delete(ptr : *mut c_void);
        pub fn cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor_PtrOfFeature2D_PtrOfDescriptorMatcher(dextractor: *mut c_void, dmatcher: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor_PtrOfDescriptorMatcher(dmatcher: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_BOWImgDescriptorExtractor_setVocabulary_Mat(instance: *mut c_void, vocabulary: *mut c_void) -> cv_return_value_void;
        pub fn cv_BOWImgDescriptorExtractor_getVocabulary_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_BOWImgDescriptorExtractor_compute__InputArray_VectorOfKeyPoint__OutputArray_VectorOfVectorOfint_Mat(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, img_descriptor: *mut c_void, point_idxs_of_clusters: *mut c_void, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_BOWImgDescriptorExtractor_compute__InputArray__OutputArray_VectorOfVectorOfint(instance: *mut c_void, keypoint_descriptors: *mut c_void, img_descriptor: *mut c_void, point_idxs_of_clusters: *mut c_void) -> cv_return_value_void;
        pub fn cv_BOWImgDescriptorExtractor_compute2_Mat_VectorOfKeyPoint_Mat(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, img_descriptor: *mut c_void) -> cv_return_value_void;
        pub fn cv_BOWImgDescriptorExtractor_descriptorSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BOWImgDescriptorExtractor_descriptorType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BOWKMeansTrainer_delete(ptr : *mut c_void);
        pub fn cv_BOWKMeansTrainer_BOWKMeansTrainer_int_TermCriteria_int_int(cluster_count: i32, termcrit: *mut c_void, attempts: i32, flags: i32) -> cv_return_value_void_X;
        pub fn cv_BOWKMeansTrainer_cluster_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_BOWKMeansTrainer_cluster_const_Mat(instance: *const c_void, descriptors: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_BOWTrainer_add_Mat(instance: *mut c_void, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_BOWTrainer_getDescriptors_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_BOWTrainer_descriptorsCount_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BOWTrainer_clear(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_BOWTrainer_cluster_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_BOWTrainer_cluster_const_Mat(instance: *const c_void, descriptors: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_BRISK_delete(ptr : *mut c_void);
        pub fn cv_BRISK_create_int_int_float(thresh: i32, octaves: i32, pattern_scale: f32) -> cv_return_value_void_X;
        pub fn cv_BRISK_create_VectorOffloat_VectorOfint_float_float_VectorOfint(radius_list: *mut c_void, number_list: *mut c_void, d_max: f32, d_min: f32, index_change: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_DescriptorMatcher_add__InputArray(instance: *mut c_void, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_getTrainDescriptors_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_DescriptorMatcher_clear(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_DescriptorMatcher_isMaskSupported_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_DescriptorMatcher_train(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_match_const__InputArray__InputArray_VectorOfDMatch__InputArray(instance: *const c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_knnMatch_const__InputArray__InputArray_VectorOfVectorOfDMatch_int__InputArray_bool(instance: *const c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, k: i32, mask: *mut c_void, compact_result: bool) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_radiusMatch_const__InputArray__InputArray_VectorOfVectorOfDMatch_float__InputArray_bool(instance: *const c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, max_distance: f32, mask: *mut c_void, compact_result: bool) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_match__InputArray_VectorOfDMatch__InputArray(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, masks: *mut c_void) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_knnMatch__InputArray_VectorOfVectorOfDMatch_int__InputArray_bool(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, k: i32, masks: *mut c_void, compact_result: bool) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_radiusMatch__InputArray_VectorOfVectorOfDMatch_float__InputArray_bool(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, max_distance: f32, masks: *mut c_void, compact_result: bool) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_write_const_String(instance: *const c_void, file_name: *const c_char) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_read_String(instance: *mut c_void, file_name: *const c_char) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_read_FileNode(instance: *mut c_void, unnamed_arg: *mut c_void) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_write_const_FileStorage(instance: *const c_void, unnamed_arg: *mut c_void) -> cv_return_value_void;
        pub fn cv_DescriptorMatcher_clone_const_bool(instance: *const c_void, empty_train_data: bool) -> cv_return_value_void_X;
        pub fn cv_DescriptorMatcher_create_String(descriptor_matcher_type: *const c_char) -> cv_return_value_void_X;
        pub fn cv_DescriptorMatcher_create_int(matcher_type: i32) -> cv_return_value_void_X;
        pub fn cv_FastFeatureDetector_setThreshold_int(instance: *mut c_void, threshold: i32) -> cv_return_value_void;
        pub fn cv_FastFeatureDetector_getThreshold_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_FastFeatureDetector_setNonmaxSuppression_bool(instance: *mut c_void, f: bool) -> cv_return_value_void;
        pub fn cv_FastFeatureDetector_getNonmaxSuppression_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FastFeatureDetector_setType_int(instance: *mut c_void, _type: i32) -> cv_return_value_void;
        pub fn cv_FastFeatureDetector_getType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_FastFeatureDetector_create_int_bool_int(threshold: i32, nonmax_suppression: bool, _type: i32) -> cv_return_value_void_X;
        pub fn cv_Feature2D_detect__InputArray_VectorOfKeyPoint__InputArray(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_Feature2D_detect__InputArray_VectorOfVectorOfKeyPoint__InputArray(instance: *mut c_void, images: *mut c_void, keypoints: *mut c_void, masks: *mut c_void) -> cv_return_value_void;
        pub fn cv_Feature2D_compute__InputArray_VectorOfKeyPoint__OutputArray(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_Feature2D_compute__InputArray_VectorOfVectorOfKeyPoint__OutputArray(instance: *mut c_void, images: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_Feature2D_detectAndCompute__InputArray__InputArray_VectorOfKeyPoint__OutputArray_bool(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void, use_provided_keypoints: bool) -> cv_return_value_void;
        pub fn cv_Feature2D_descriptorSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Feature2D_descriptorType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Feature2D_defaultNorm_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_Feature2D_write_const_String(instance: *const c_void, file_name: *const c_char) -> cv_return_value_void;
        pub fn cv_Feature2D_read_String(instance: *mut c_void, file_name: *const c_char) -> cv_return_value_void;
        pub fn cv_Feature2D_write_const_FileStorage(instance: *const c_void, unnamed_arg: *mut c_void) -> cv_return_value_void;
        pub fn cv_Feature2D_read_FileNode(instance: *mut c_void, unnamed_arg: *mut c_void) -> cv_return_value_void;
        pub fn cv_Feature2D_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_Feature2D_delete(ptr : *mut c_void);
        pub fn cv_FlannBasedMatcher_delete(ptr : *mut c_void);
        pub fn cv_FlannBasedMatcher_add__InputArray(instance: *mut c_void, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_FlannBasedMatcher_clear(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_FlannBasedMatcher_read_FileNode(instance: *mut c_void, unnamed_arg: *mut c_void) -> cv_return_value_void;
        pub fn cv_FlannBasedMatcher_write_const_FileStorage(instance: *const c_void, unnamed_arg: *mut c_void) -> cv_return_value_void;
        pub fn cv_FlannBasedMatcher_train(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_FlannBasedMatcher_isMaskSupported_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FlannBasedMatcher_create() -> cv_return_value_void_X;
        pub fn cv_FlannBasedMatcher_clone_const_bool(instance: *const c_void, empty_train_data: bool) -> cv_return_value_void_X;
        pub fn cv_GFTTDetector_setMaxFeatures_int(instance: *mut c_void, max_features: i32) -> cv_return_value_void;
        pub fn cv_GFTTDetector_getMaxFeatures_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_GFTTDetector_setQualityLevel_double(instance: *mut c_void, qlevel: f64) -> cv_return_value_void;
        pub fn cv_GFTTDetector_getQualityLevel_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GFTTDetector_setMinDistance_double(instance: *mut c_void, min_distance: f64) -> cv_return_value_void;
        pub fn cv_GFTTDetector_getMinDistance_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GFTTDetector_setBlockSize_int(instance: *mut c_void, block_size: i32) -> cv_return_value_void;
        pub fn cv_GFTTDetector_getBlockSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_GFTTDetector_setHarrisDetector_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_GFTTDetector_getHarrisDetector_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_GFTTDetector_setK_double(instance: *mut c_void, k: f64) -> cv_return_value_void;
        pub fn cv_GFTTDetector_getK_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GFTTDetector_create_int_double_double_int_bool_double(max_corners: i32, quality_level: f64, min_distance: f64, block_size: i32, use_harris_detector: bool, k: f64) -> cv_return_value_void_X;
        pub fn cv_KAZE_setExtended_bool(instance: *mut c_void, extended: bool) -> cv_return_value_void;
        pub fn cv_KAZE_getExtended_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_KAZE_setUpright_bool(instance: *mut c_void, upright: bool) -> cv_return_value_void;
        pub fn cv_KAZE_getUpright_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_KAZE_setThreshold_double(instance: *mut c_void, threshold: f64) -> cv_return_value_void;
        pub fn cv_KAZE_getThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_KAZE_setNOctaves_int(instance: *mut c_void, octaves: i32) -> cv_return_value_void;
        pub fn cv_KAZE_getNOctaves_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_KAZE_setNOctaveLayers_int(instance: *mut c_void, octave_layers: i32) -> cv_return_value_void;
        pub fn cv_KAZE_getNOctaveLayers_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_KAZE_setDiffusivity_int(instance: *mut c_void, diff: i32) -> cv_return_value_void;
        pub fn cv_KAZE_getDiffusivity_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_KAZE_create_bool_bool_float_int_int_int(extended: bool, upright: bool, threshold: f32, n_octaves: i32, n_octave_layers: i32, diffusivity: i32) -> cv_return_value_void_X;
        pub fn cv_KeyPointsFilter_delete(ptr : *mut c_void);
        pub fn cv_KeyPointsFilter_KeyPointsFilter() -> cv_return_value_void_X;
        pub fn cv_KeyPointsFilter_runByImageBorder_VectorOfKeyPoint_Size_int(keypoints: *mut c_void, image_size: core::Size, border_size: i32) -> cv_return_value_void;
        pub fn cv_KeyPointsFilter_runByKeypointSize_VectorOfKeyPoint_float_float(keypoints: *mut c_void, min_size: f32, max_size: f32) -> cv_return_value_void;
        pub fn cv_KeyPointsFilter_runByPixelsMask_VectorOfKeyPoint_Mat(keypoints: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_KeyPointsFilter_removeDuplicated_VectorOfKeyPoint(keypoints: *mut c_void) -> cv_return_value_void;
        pub fn cv_KeyPointsFilter_retainBest_VectorOfKeyPoint_int(keypoints: *mut c_void, npoints: i32) -> cv_return_value_void;
        pub fn cv_MSER_detectRegions__InputArray_VectorOfVectorOfPoint_VectorOfRect(instance: *mut c_void, image: *mut c_void, msers: *mut c_void, bboxes: *mut c_void) -> cv_return_value_void;
        pub fn cv_MSER_setDelta_int(instance: *mut c_void, delta: i32) -> cv_return_value_void;
        pub fn cv_MSER_getDelta_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_MSER_setMinArea_int(instance: *mut c_void, min_area: i32) -> cv_return_value_void;
        pub fn cv_MSER_getMinArea_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_MSER_setMaxArea_int(instance: *mut c_void, max_area: i32) -> cv_return_value_void;
        pub fn cv_MSER_getMaxArea_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_MSER_setPass2Only_bool(instance: *mut c_void, f: bool) -> cv_return_value_void;
        pub fn cv_MSER_getPass2Only_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_MSER_create_int_int_int_double_double_int_double_double_int(_delta: i32, _min_area: i32, _max_area: i32, _max_variation: f64, _min_diversity: f64, _max_evolution: i32, _area_threshold: f64, _min_margin: f64, _edge_blur_size: i32) -> cv_return_value_void_X;
        pub fn cv_ORB_setMaxFeatures_int(instance: *mut c_void, max_features: i32) -> cv_return_value_void;
        pub fn cv_ORB_getMaxFeatures_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ORB_setScaleFactor_double(instance: *mut c_void, scale_factor: f64) -> cv_return_value_void;
        pub fn cv_ORB_getScaleFactor_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ORB_setNLevels_int(instance: *mut c_void, nlevels: i32) -> cv_return_value_void;
        pub fn cv_ORB_getNLevels_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ORB_setEdgeThreshold_int(instance: *mut c_void, edge_threshold: i32) -> cv_return_value_void;
        pub fn cv_ORB_getEdgeThreshold_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ORB_setFirstLevel_int(instance: *mut c_void, first_level: i32) -> cv_return_value_void;
        pub fn cv_ORB_getFirstLevel_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ORB_setWTA_K_int(instance: *mut c_void, wta_k: i32) -> cv_return_value_void;
        pub fn cv_ORB_getWTA_K_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ORB_setScoreType_int(instance: *mut c_void, score_type: i32) -> cv_return_value_void;
        pub fn cv_ORB_getScoreType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ORB_setPatchSize_int(instance: *mut c_void, patch_size: i32) -> cv_return_value_void;
        pub fn cv_ORB_getPatchSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ORB_setFastThreshold_int(instance: *mut c_void, fast_threshold: i32) -> cv_return_value_void;
        pub fn cv_ORB_getFastThreshold_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ORB_create_int_float_int_int_int_int_int_int_int(nfeatures: i32, scale_factor: f32, nlevels: i32, edge_threshold: i32, first_level: i32, wta_k: i32, score_type: i32, patch_size: i32, fast_threshold: i32) -> cv_return_value_void_X;
        pub fn cv_ORB_create() -> cv_return_value_void_X;
        pub fn cv_SimpleBlobDetector_delete(ptr : *mut c_void);
        pub fn cv_SimpleBlobDetector_create_SimpleBlobDetector_Params(parameters: crate::features2d::SimpleBlobDetector_Params) -> cv_return_value_void_X;
        pub fn cv_SimpleBlobDetector_Params_Params() -> cv_return_value_SimpleBlobDetector_Params;
        pub fn cv_SimpleBlobDetector_Params_read_FileNode(instance: crate::features2d::SimpleBlobDetector_Params, _fn: *mut c_void) -> cv_return_value_void;
        pub fn cv_SimpleBlobDetector_Params_write_const_FileStorage(instance: crate::features2d::SimpleBlobDetector_Params, fs: *mut c_void) -> cv_return_value_void;
    
    }
}
pub use features2d_sys::*;

#[cfg(feature = "contrib")]
mod freetype_sys {
    use super::*;

    extern "C" {
        pub fn cv_freetype_createFreeType2() -> cv_return_value_void_X;
        pub fn cv_freetype_FreeType2_loadFontData_String_int(instance: *mut c_void, font_file_name: *mut c_char, id: i32) -> cv_return_value_void;
        pub fn cv_freetype_FreeType2_setSplitNumber_int(instance: *mut c_void, num: i32) -> cv_return_value_void;
        pub fn cv_freetype_FreeType2_putText__InputOutputArray_String_Point_int_Scalar_int_int_bool(instance: *mut c_void, img: *mut c_void, text: *const c_char, org: core::Point, font_height: i32, color: core::Scalar, thickness: i32, line_type: i32, bottom_left_origin: bool) -> cv_return_value_void;
    
    }
}
#[cfg(feature = "contrib")]
pub use freetype_sys::*;

#[cfg(feature = "contrib")]
mod fuzzy_sys {
    use super::*;

    extern "C" {
        pub fn cv_ft_FT02D_components__InputArray__InputArray__OutputArray(matrix: *mut c_void, kernel: *mut c_void, components: *mut c_void) -> cv_return_value_void;
        pub fn cv_ft_FT02D_components__InputArray__InputArray__OutputArray__InputArray(matrix: *mut c_void, kernel: *mut c_void, components: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_ft_FT02D_inverseFT__InputArray__InputArray__OutputArray_int_int(components: *mut c_void, kernel: *mut c_void, output: *mut c_void, width: i32, height: i32) -> cv_return_value_void;
        pub fn cv_ft_FT02D_iteration__InputArray__InputArray__OutputArray__InputArray__OutputArray_bool(matrix: *mut c_void, kernel: *mut c_void, output: *mut c_void, mask: *mut c_void, mask_output: *mut c_void, first_stop: bool) -> cv_return_value_int;
        pub fn cv_ft_FT02D_process__InputArray__InputArray__OutputArray(matrix: *mut c_void, kernel: *mut c_void, output: *mut c_void) -> cv_return_value_void;
        pub fn cv_ft_FT02D_process__InputArray__InputArray__OutputArray__InputArray(matrix: *mut c_void, kernel: *mut c_void, output: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_ft_createKernel__InputArray__InputArray__OutputArray_int(a: *mut c_void, b: *mut c_void, kernel: *mut c_void, chn: i32) -> cv_return_value_void;
        pub fn cv_ft_createKernel_int_int__OutputArray_int(function: i32, radius: i32, kernel: *mut c_void, chn: i32) -> cv_return_value_void;
        pub fn cv_ft_filter__InputArray__InputArray__OutputArray(image: *mut c_void, kernel: *mut c_void, output: *mut c_void) -> cv_return_value_void;
        pub fn cv_ft_inpaint__InputArray__InputArray__OutputArray_int_int_int(image: *mut c_void, mask: *mut c_void, output: *mut c_void, radius: i32, function: i32, algorithm: i32) -> cv_return_value_void;
    
    }
}
#[cfg(feature = "contrib")]
pub use fuzzy_sys::*;

#[cfg(feature = "contrib")]
mod hdf_sys {
    use super::*;

    extern "C" {
        pub fn cv_hdf_open_String(hdf5_filename: *mut c_char) -> cv_return_value_void_X;
        pub fn cv_hdf_HDF5_close(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_grcreate_String(instance: *mut c_void, grlabel: *mut c_char) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_hlexists_const_String(instance: *const c_void, label: *mut c_char) -> cv_return_value_bool;
        pub fn cv_hdf_HDF5_dscreate_const_int_int_int_String(instance: *const c_void, rows: i32, cols: i32, _type: i32, dslabel: *mut c_char) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dscreate_const_int_int_int_String_int(instance: *const c_void, rows: i32, cols: i32, _type: i32, dslabel: *mut c_char, compresslevel: i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dscreate_const_int_int_int_String_int_VectorOfint(instance: *const c_void, rows: i32, cols: i32, _type: i32, dslabel: *mut c_char, compresslevel: i32, dims_chunks: *mut c_void) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dscreate_const_int_int_int_String_int_const_int_X(instance: *const c_void, rows: i32, cols: i32, _type: i32, dslabel: *mut c_char, compresslevel: i32, dims_chunks: *const i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dscreate_const_int_const_int_X_int_String(instance: *const c_void, n_dims: i32, sizes: *const i32, _type: i32, dslabel: *mut c_char) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dscreate_const_int_const_int_X_int_String_int(instance: *const c_void, n_dims: i32, sizes: *const i32, _type: i32, dslabel: *mut c_char, compresslevel: i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dscreate_const_VectorOfint_int_String_int_VectorOfint(instance: *const c_void, sizes: *mut c_void, _type: i32, dslabel: *mut c_char, compresslevel: i32, dims_chunks: *mut c_void) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dscreate_const_int_const_int_X_int_String_int_const_int_X(instance: *const c_void, n_dims: i32, sizes: *const i32, _type: i32, dslabel: *mut c_char, compresslevel: i32, dims_chunks: *const i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dsgetsize_const_String_int(instance: *const c_void, dslabel: *mut c_char, dims_flag: i32) -> cv_return_value_void_X;
        pub fn cv_hdf_HDF5_dsgettype_const_String(instance: *const c_void, dslabel: *mut c_char) -> cv_return_value_int;
        pub fn cv_hdf_HDF5_dswrite_const__InputArray_String(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dswrite_const__InputArray_String_const_int_X(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char, dims_offset: *const i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dswrite_const__InputArray_String_VectorOfint_VectorOfint(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char, dims_offset: *mut c_void, dims_counts: *mut c_void) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dswrite_const__InputArray_String_const_int_X_const_int_X(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char, dims_offset: *const i32, dims_counts: *const i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dsinsert_const__InputArray_String(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dsinsert_const__InputArray_String_const_int_X(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char, dims_offset: *const i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dsinsert_const__InputArray_String_VectorOfint_VectorOfint(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char, dims_offset: *mut c_void, dims_counts: *mut c_void) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dsinsert_const__InputArray_String_const_int_X_const_int_X(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char, dims_offset: *const i32, dims_counts: *const i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dsread_const__OutputArray_String(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dsread_const__OutputArray_String_const_int_X(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char, dims_offset: *const i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dsread_const__OutputArray_String_VectorOfint_VectorOfint(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char, dims_offset: *mut c_void, dims_counts: *mut c_void) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_dsread_const__OutputArray_String_const_int_X_const_int_X(instance: *const c_void, array: *mut c_void, dslabel: *mut c_char, dims_offset: *const i32, dims_counts: *const i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_kpgetsize_const_String_int(instance: *const c_void, kplabel: *mut c_char, dims_flag: i32) -> cv_return_value_int;
        pub fn cv_hdf_HDF5_kpcreate_const_int_String_int_int(instance: *const c_void, size: i32, kplabel: *mut c_char, compresslevel: i32, chunks: i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_kpwrite_const_VectorOfKeyPoint_String_int_int(instance: *const c_void, keypoints: *mut c_void, kplabel: *mut c_char, offset: i32, counts: i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_kpinsert_const_VectorOfKeyPoint_String_int_int(instance: *const c_void, keypoints: *mut c_void, kplabel: *mut c_char, offset: i32, counts: i32) -> cv_return_value_void;
        pub fn cv_hdf_HDF5_kpread_const_VectorOfKeyPoint_String_int_int(instance: *const c_void, keypoints: *mut c_void, kplabel: *mut c_char, offset: i32, counts: i32) -> cv_return_value_void;
    
    }
}
#[cfg(feature = "contrib")]
pub use hdf_sys::*;

mod highgui_sys {
    use super::*;

    extern "C" {
        pub fn cv_addText_Mat_String_Point_QtFont(img: *mut c_void, text: *const c_char, org: core::Point, font: *mut c_void) -> cv_return_value_void;
        pub fn cv_addText_Mat_String_Point_String_int_Scalar_int_int_int(img: *mut c_void, text: *const c_char, org: core::Point, name_font: *const c_char, point_size: i32, color: core::Scalar, weight: i32, style: i32, spacing: i32) -> cv_return_value_void;
        pub fn cv_createButton_String_ButtonCallback_void_X_int_bool(bar_name: *const c_char, on_change: crate::highgui::ButtonCallbackExtern, userdata: *mut c_void, _type: i32, initial_button_state: bool) -> cv_return_value_int;
        pub fn cv_createTrackbar_String_String_int_X_int_TrackbarCallback_void_X(trackbarname: *const c_char, winname: *const c_char, value: *mut i32, count: i32, on_change: crate::highgui::TrackbarCallbackExtern, userdata: *mut c_void) -> cv_return_value_int;
        pub fn cv_destroyAllWindows() -> cv_return_value_void;
        pub fn cv_destroyWindow_String(winname: *const c_char) -> cv_return_value_void;
        pub fn cv_displayOverlay_String_String_int(winname: *const c_char, text: *const c_char, delayms: i32) -> cv_return_value_void;
        pub fn cv_displayStatusBar_String_String_int(winname: *const c_char, text: *const c_char, delayms: i32) -> cv_return_value_void;
        pub fn cv_fontQt_String_int_Scalar_int_int_int(name_font: *const c_char, point_size: i32, color: core::Scalar, weight: i32, style: i32, spacing: i32) -> cv_return_value_void_X;
        pub fn cv_getMouseWheelDelta_int(flags: i32) -> cv_return_value_int;
        pub fn cv_getTrackbarPos_String_String(trackbarname: *const c_char, winname: *const c_char) -> cv_return_value_int;
        pub fn cv_getWindowProperty_String_int(winname: *const c_char, prop_id: i32) -> cv_return_value_double;
        pub fn cv_imshow_String__InputArray(winname: *const c_char, mat: *mut c_void) -> cv_return_value_void;
        pub fn cv_loadWindowParameters_String(window_name: *const c_char) -> cv_return_value_void;
        pub fn cv_moveWindow_String_int_int(winname: *const c_char, x: i32, y: i32) -> cv_return_value_void;
        pub fn cv_namedWindow_String_int(winname: *const c_char, flags: i32) -> cv_return_value_void;
        pub fn cv_resizeWindow_String_int_int(winname: *const c_char, width: i32, height: i32) -> cv_return_value_void;
        pub fn cv_saveWindowParameters_String(window_name: *const c_char) -> cv_return_value_void;
        pub fn cv_setMouseCallback_String_MouseCallback_void_X(winname: *const c_char, on_mouse: crate::highgui::MouseCallbackExtern, userdata: *mut c_void) -> cv_return_value_void;
        pub fn cv_setOpenGlContext_String(winname: *const c_char) -> cv_return_value_void;
        pub fn cv_setOpenGlDrawCallback_String_OpenGlDrawCallback_void_X(winname: *const c_char, on_opengl_draw: crate::highgui::OpenGlDrawCallbackExtern, userdata: *mut c_void) -> cv_return_value_void;
        pub fn cv_setTrackbarMax_String_String_int(trackbarname: *const c_char, winname: *const c_char, maxval: i32) -> cv_return_value_void;
        pub fn cv_setTrackbarMin_String_String_int(trackbarname: *const c_char, winname: *const c_char, minval: i32) -> cv_return_value_void;
        pub fn cv_setTrackbarPos_String_String_int(trackbarname: *const c_char, winname: *const c_char, pos: i32) -> cv_return_value_void;
        pub fn cv_setWindowProperty_String_int_double(winname: *const c_char, prop_id: i32, prop_value: f64) -> cv_return_value_void;
        pub fn cv_setWindowTitle_String_String(winname: *const c_char, title: *const c_char) -> cv_return_value_void;
        pub fn cv_startWindowThread() -> cv_return_value_int;
        pub fn cv_stopLoop() -> cv_return_value_void;
        pub fn cv_updateWindow_String(winname: *const c_char) -> cv_return_value_void;
        pub fn cv_waitKeyEx_int(delay: i32) -> cv_return_value_int;
        pub fn cv_waitKey_int(delay: i32) -> cv_return_value_int;
        pub fn cv_QtFont_delete(ptr : *mut c_void);
    
    }
}
pub use highgui_sys::*;

mod imgcodecs_sys {
    use super::*;

    extern "C" {
        pub fn cv_imdecode__InputArray_int(buf: *mut c_void, flags: i32) -> cv_return_value_void_X;
        pub fn cv_imdecode__InputArray_int_Mat(buf: *mut c_void, flags: i32, dst: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_imencode_String__InputArray_VectorOfuchar_VectorOfint(ext: *const c_char, img: *mut c_void, buf: *mut c_void, params: *mut c_void) -> cv_return_value_bool;
        pub fn cv_imread_String_int(filename: *const c_char, flags: i32) -> cv_return_value_void_X;
        pub fn cv_imreadmulti_String_VectorOfMat_int(filename: *const c_char, mats: *mut c_void, flags: i32) -> cv_return_value_bool;
        pub fn cv_imwrite_String__InputArray_VectorOfint(filename: *const c_char, img: *mut c_void, params: *mut c_void) -> cv_return_value_bool;
    
    }
}
pub use imgcodecs_sys::*;

mod imgproc_sys {
    use super::*;

    extern "C" {
        pub fn cv_Canny__InputArray__InputArray__OutputArray_double_double_bool(dx: *mut c_void, dy: *mut c_void, edges: *mut c_void, threshold1: f64, threshold2: f64, l2gradient: bool) -> cv_return_value_void;
        pub fn cv_Canny__InputArray__OutputArray_double_double_int_bool(image: *mut c_void, edges: *mut c_void, threshold1: f64, threshold2: f64, aperture_size: i32, l2gradient: bool) -> cv_return_value_void;
        pub fn cv_EMD__InputArray__InputArray_int__InputArray_float_X__OutputArray(signature1: *mut c_void, signature2: *mut c_void, dist_type: i32, cost: *mut c_void, lower_bound: *mut f32, flow: *mut c_void) -> cv_return_value_float;
        pub fn cv_GaussianBlur__InputArray__OutputArray_Size_double_double_int(src: *mut c_void, dst: *mut c_void, ksize: core::Size, sigma_x: f64, sigma_y: f64, border_type: i32) -> cv_return_value_void;
        pub fn cv_HoughCircles__InputArray__OutputArray_int_double_double_double_double_int_int(image: *mut c_void, circles: *mut c_void, method: i32, dp: f64, min_dist: f64, param1: f64, param2: f64, min_radius: i32, max_radius: i32) -> cv_return_value_void;
        pub fn cv_HoughLinesP__InputArray__OutputArray_double_double_int_double_double(image: *mut c_void, lines: *mut c_void, rho: f64, theta: f64, threshold: i32, min_line_length: f64, max_line_gap: f64) -> cv_return_value_void;
        pub fn cv_HoughLines__InputArray__OutputArray_double_double_int_double_double_double_double(image: *mut c_void, lines: *mut c_void, rho: f64, theta: f64, threshold: i32, srn: f64, stn: f64, min_theta: f64, max_theta: f64) -> cv_return_value_void;
        pub fn cv_Laplacian__InputArray__OutputArray_int_int_double_double_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, ksize: i32, scale: f64, delta: f64, border_type: i32) -> cv_return_value_void;
        pub fn cv_Scharr__InputArray__OutputArray_int_int_int_double_double_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, dx: i32, dy: i32, scale: f64, delta: f64, border_type: i32) -> cv_return_value_void;
        pub fn cv_Sobel__InputArray__OutputArray_int_int_int_int_double_double_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, dx: i32, dy: i32, ksize: i32, scale: f64, delta: f64, border_type: i32) -> cv_return_value_void;
        pub fn cv_accumulateProduct__InputArray__InputArray__InputOutputArray__InputArray(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_accumulateSquare__InputArray__InputOutputArray__InputArray(src: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_accumulateWeighted__InputArray__InputOutputArray_double__InputArray(src: *mut c_void, dst: *mut c_void, alpha: f64, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_accumulate__InputArray__InputOutputArray__InputArray(src: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_adaptiveThreshold__InputArray__OutputArray_double_int_int_int_double(src: *mut c_void, dst: *mut c_void, max_value: f64, adaptive_method: i32, threshold_type: i32, block_size: i32, c: f64) -> cv_return_value_void;
        pub fn cv_applyColorMap__InputArray__OutputArray_int(src: *mut c_void, dst: *mut c_void, colormap: i32) -> cv_return_value_void;
        pub fn cv_approxPolyDP__InputArray__OutputArray_double_bool(curve: *mut c_void, approx_curve: *mut c_void, epsilon: f64, closed: bool) -> cv_return_value_void;
        pub fn cv_arcLength__InputArray_bool(curve: *mut c_void, closed: bool) -> cv_return_value_double;
        pub fn cv_arrowedLine__InputOutputArray_Point_Point_Scalar_int_int_int_double(img: *mut c_void, pt1: core::Point, pt2: core::Point, color: core::Scalar, thickness: i32, line_type: i32, shift: i32, tip_length: f64) -> cv_return_value_void;
        pub fn cv_bilateralFilter__InputArray__OutputArray_int_double_double_int(src: *mut c_void, dst: *mut c_void, d: i32, sigma_color: f64, sigma_space: f64, border_type: i32) -> cv_return_value_void;
        pub fn cv_blendLinear__InputArray__InputArray__InputArray__InputArray__OutputArray(src1: *mut c_void, src2: *mut c_void, weights1: *mut c_void, weights2: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_blur__InputArray__OutputArray_Size_Point_int(src: *mut c_void, dst: *mut c_void, ksize: core::Size, anchor: core::Point, border_type: i32) -> cv_return_value_void;
        pub fn cv_boundingRect__InputArray(points: *mut c_void) -> cv_return_value_RectWrapper;
        pub fn cv_boxFilter__InputArray__OutputArray_int_Size_Point_bool_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, ksize: core::Size, anchor: core::Point, normalize: bool, border_type: i32) -> cv_return_value_void;
        pub fn cv_boxPoints_RotatedRect__OutputArray(_box: *mut c_void, points: *mut c_void) -> cv_return_value_void;
        pub fn cv_buildPyramid__InputArray__OutputArray_int_int(src: *mut c_void, dst: *mut c_void, maxlevel: i32, border_type: i32) -> cv_return_value_void;
        pub fn cv_calcBackProject__InputArray_VectorOfint__InputArray__OutputArray_VectorOffloat_double(images: *mut c_void, channels: *mut c_void, hist: *mut c_void, dst: *mut c_void, ranges: *mut c_void, scale: f64) -> cv_return_value_void;
        pub fn cv_calcHist__InputArray_VectorOfint__InputArray__OutputArray_VectorOfint_VectorOffloat_bool(images: *mut c_void, channels: *mut c_void, mask: *mut c_void, hist: *mut c_void, hist_size: *mut c_void, ranges: *mut c_void, accumulate: bool) -> cv_return_value_void;
        pub fn cv_circle__InputOutputArray_Point_int_Scalar_int_int_int(img: *mut c_void, center: core::Point, radius: i32, color: core::Scalar, thickness: i32, line_type: i32, shift: i32) -> cv_return_value_void;
        pub fn cv_clipLine_Rect_Point_Point(img_rect: core::Rect, pt1: *mut core::Point, pt2: *mut core::Point) -> cv_return_value_bool;
        pub fn cv_clipLine_Size2l_Point2l_Point2l(img_size: core::Size2l, pt1: *mut core::Point2l, pt2: *mut core::Point2l) -> cv_return_value_bool;
        pub fn cv_clipLine_Size_Point_Point(img_size: core::Size, pt1: *mut core::Point, pt2: *mut core::Point) -> cv_return_value_bool;
        pub fn cv_compareHist__InputArray__InputArray_int(h1: *mut c_void, h2: *mut c_void, method: i32) -> cv_return_value_double;
        pub fn cv_connectedComponentsWithStats__InputArray__OutputArray__OutputArray__OutputArray_int_int(image: *mut c_void, labels: *mut c_void, stats: *mut c_void, centroids: *mut c_void, connectivity: i32, ltype: i32) -> cv_return_value_int;
        pub fn cv_connectedComponentsWithStats__InputArray__OutputArray__OutputArray__OutputArray_int_int_int(image: *mut c_void, labels: *mut c_void, stats: *mut c_void, centroids: *mut c_void, connectivity: i32, ltype: i32, ccltype: i32) -> cv_return_value_int;
        pub fn cv_connectedComponents__InputArray__OutputArray_int_int(image: *mut c_void, labels: *mut c_void, connectivity: i32, ltype: i32) -> cv_return_value_int;
        pub fn cv_connectedComponents__InputArray__OutputArray_int_int_int(image: *mut c_void, labels: *mut c_void, connectivity: i32, ltype: i32, ccltype: i32) -> cv_return_value_int;
        pub fn cv_contourArea__InputArray_bool(contour: *mut c_void, oriented: bool) -> cv_return_value_double;
        pub fn cv_convertMaps__InputArray__InputArray__OutputArray__OutputArray_int_bool(map1: *mut c_void, map2: *mut c_void, dstmap1: *mut c_void, dstmap2: *mut c_void, dstmap1type: i32, nninterpolation: bool) -> cv_return_value_void;
        pub fn cv_convexHull__InputArray__OutputArray_bool_bool(points: *mut c_void, hull: *mut c_void, clockwise: bool, return_points: bool) -> cv_return_value_void;
        pub fn cv_convexityDefects__InputArray__InputArray__OutputArray(contour: *mut c_void, convexhull: *mut c_void, convexity_defects: *mut c_void) -> cv_return_value_void;
        pub fn cv_cornerEigenValsAndVecs__InputArray__OutputArray_int_int_int(src: *mut c_void, dst: *mut c_void, block_size: i32, ksize: i32, border_type: i32) -> cv_return_value_void;
        pub fn cv_cornerHarris__InputArray__OutputArray_int_int_double_int(src: *mut c_void, dst: *mut c_void, block_size: i32, ksize: i32, k: f64, border_type: i32) -> cv_return_value_void;
        pub fn cv_cornerMinEigenVal__InputArray__OutputArray_int_int_int(src: *mut c_void, dst: *mut c_void, block_size: i32, ksize: i32, border_type: i32) -> cv_return_value_void;
        pub fn cv_cornerSubPix__InputArray__InputOutputArray_Size_Size_TermCriteria(image: *mut c_void, corners: *mut c_void, win_size: core::Size, zero_zone: core::Size, criteria: *mut c_void) -> cv_return_value_void;
        pub fn cv_createCLAHE_double_Size(clip_limit: f64, tile_grid_size: core::Size) -> cv_return_value_void_X;
        pub fn cv_createGeneralizedHoughBallard() -> cv_return_value_void_X;
        pub fn cv_createGeneralizedHoughGuil() -> cv_return_value_void_X;
        pub fn cv_createHanningWindow__OutputArray_Size_int(dst: *mut c_void, win_size: core::Size, _type: i32) -> cv_return_value_void;
        pub fn cv_createLineSegmentDetector_int_double_double_double_double_double_double_int(_refine: i32, _scale: f64, _sigma_scale: f64, _quant: f64, _ang_th: f64, _log_eps: f64, _density_th: f64, _n_bins: i32) -> cv_return_value_void_X;
        pub fn cv_cvtColor__InputArray__OutputArray_int_int(src: *mut c_void, dst: *mut c_void, code: i32, dst_cn: i32) -> cv_return_value_void;
        pub fn cv_demosaicing__InputArray__OutputArray_int_int(_src: *mut c_void, _dst: *mut c_void, code: i32, dcn: i32) -> cv_return_value_void;
        pub fn cv_dilate__InputArray__OutputArray__InputArray_Point_int_int_Scalar(src: *mut c_void, dst: *mut c_void, kernel: *mut c_void, anchor: core::Point, iterations: i32, border_type: i32, border_value: core::Scalar) -> cv_return_value_void;
        pub fn cv_distanceTransform__InputArray__OutputArray__OutputArray_int_int_int(src: *mut c_void, dst: *mut c_void, labels: *mut c_void, distance_type: i32, mask_size: i32, label_type: i32) -> cv_return_value_void;
        pub fn cv_distanceTransform__InputArray__OutputArray_int_int_int(src: *mut c_void, dst: *mut c_void, distance_type: i32, mask_size: i32, dst_type: i32) -> cv_return_value_void;
        pub fn cv_drawContours__InputOutputArray__InputArray_int_Scalar_int_int__InputArray_int_Point(image: *mut c_void, contours: *mut c_void, contour_idx: i32, color: core::Scalar, thickness: i32, line_type: i32, hierarchy: *mut c_void, max_level: i32, offset: core::Point) -> cv_return_value_void;
        pub fn cv_drawMarker_Mat_Point_Scalar_int_int_int_int(img: *mut c_void, position: core::Point, color: core::Scalar, marker_type: i32, marker_size: i32, thickness: i32, line_type: i32) -> cv_return_value_void;
        pub fn cv_ellipse2Poly_Point2d_Size2d_int_int_int_int_VectorOfPoint2d(center: core::Point2d, axes: core::Size2d, angle: i32, arc_start: i32, arc_end: i32, delta: i32, pts: *mut c_void) -> cv_return_value_void;
        pub fn cv_ellipse2Poly_Point_Size_int_int_int_int_VectorOfPoint(center: core::Point, axes: core::Size, angle: i32, arc_start: i32, arc_end: i32, delta: i32, pts: *mut c_void) -> cv_return_value_void;
        pub fn cv_ellipse__InputOutputArray_Point_Size_double_double_double_Scalar_int_int_int(img: *mut c_void, center: core::Point, axes: core::Size, angle: f64, start_angle: f64, end_angle: f64, color: core::Scalar, thickness: i32, line_type: i32, shift: i32) -> cv_return_value_void;
        pub fn cv_ellipse__InputOutputArray_RotatedRect_Scalar_int_int(img: *mut c_void, _box: *mut c_void, color: core::Scalar, thickness: i32, line_type: i32) -> cv_return_value_void;
        pub fn cv_equalizeHist__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_erode__InputArray__OutputArray__InputArray_Point_int_int_Scalar(src: *mut c_void, dst: *mut c_void, kernel: *mut c_void, anchor: core::Point, iterations: i32, border_type: i32, border_value: core::Scalar) -> cv_return_value_void;
        pub fn cv_fillConvexPoly__InputOutputArray__InputArray_Scalar_int_int(img: *mut c_void, points: *mut c_void, color: core::Scalar, line_type: i32, shift: i32) -> cv_return_value_void;
        pub fn cv_fillPoly__InputOutputArray__InputArray_Scalar_int_int_Point(img: *mut c_void, pts: *mut c_void, color: core::Scalar, line_type: i32, shift: i32, offset: core::Point) -> cv_return_value_void;
        pub fn cv_filter2D__InputArray__OutputArray_int__InputArray_Point_double_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, kernel: *mut c_void, anchor: core::Point, delta: f64, border_type: i32) -> cv_return_value_void;
        pub fn cv_findContours__InputOutputArray__OutputArray__OutputArray_int_int_Point(image: *mut c_void, contours: *mut c_void, hierarchy: *mut c_void, mode: i32, method: i32, offset: core::Point) -> cv_return_value_void;
        pub fn cv_findContours__InputOutputArray__OutputArray_int_int_Point(image: *mut c_void, contours: *mut c_void, mode: i32, method: i32, offset: core::Point) -> cv_return_value_void;
        pub fn cv_fitEllipse__InputArray(points: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_fitLine__InputArray__OutputArray_int_double_double_double(points: *mut c_void, line: *mut c_void, dist_type: i32, param: f64, reps: f64, aeps: f64) -> cv_return_value_void;
        pub fn cv_floodFill__InputOutputArray_Point_Scalar_Rect_X_Scalar_Scalar_int(image: *mut c_void, seed_point: core::Point, new_val: core::Scalar, rect: *mut core::Rect, lo_diff: core::Scalar, up_diff: core::Scalar, flags: i32) -> cv_return_value_int;
        pub fn cv_floodFill__InputOutputArray__InputOutputArray_Point_Scalar_Rect_X_Scalar_Scalar_int(image: *mut c_void, mask: *mut c_void, seed_point: core::Point, new_val: core::Scalar, rect: *mut core::Rect, lo_diff: core::Scalar, up_diff: core::Scalar, flags: i32) -> cv_return_value_int;
        pub fn cv_getAffineTransform__InputArray__InputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_getAffineTransform_const_Point2f_X_const_Point2f_X(src: *const core::Point2f, dst: *const core::Point2f) -> cv_return_value_void_X;
        pub fn cv_getDefaultNewCameraMatrix__InputArray_Size_bool(camera_matrix: *mut c_void, imgsize: core::Size, center_principal_point: bool) -> cv_return_value_void_X;
        pub fn cv_getDerivKernels__OutputArray__OutputArray_int_int_int_bool_int(kx: *mut c_void, ky: *mut c_void, dx: i32, dy: i32, ksize: i32, normalize: bool, ktype: i32) -> cv_return_value_void;
        pub fn cv_getGaborKernel_Size_double_double_double_double_double_int(ksize: core::Size, sigma: f64, theta: f64, lambd: f64, gamma: f64, psi: f64, ktype: i32) -> cv_return_value_void_X;
        pub fn cv_getGaussianKernel_int_double_int(ksize: i32, sigma: f64, ktype: i32) -> cv_return_value_void_X;
        pub fn cv_getPerspectiveTransform__InputArray__InputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_getPerspectiveTransform_const_Point2f_X_const_Point2f_X(src: *const core::Point2f, dst: *const core::Point2f) -> cv_return_value_void_X;
        pub fn cv_getRectSubPix__InputArray_Size_Point2f__OutputArray_int(image: *mut c_void, patch_size: core::Size, center: core::Point2f, patch: *mut c_void, patch_type: i32) -> cv_return_value_void;
        pub fn cv_getRotationMatrix2D_Point2f_double_double(center: core::Point2f, angle: f64, scale: f64) -> cv_return_value_void_X;
        pub fn cv_getStructuringElement_int_Size_Point(shape: i32, ksize: core::Size, anchor: core::Point) -> cv_return_value_void_X;
        pub fn cv_getTextSize_String_int_double_int_int_X(text: *const c_char, font_face: i32, font_scale: f64, thickness: i32, base_line: *mut i32) -> cv_return_value_SizeWrapper;
        pub fn cv_goodFeaturesToTrack__InputArray__OutputArray_int_double_double__InputArray_int_bool_double(image: *mut c_void, corners: *mut c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *mut c_void, block_size: i32, use_harris_detector: bool, k: f64) -> cv_return_value_void;
        pub fn cv_grabCut__InputArray__InputOutputArray_Rect__InputOutputArray__InputOutputArray_int_int(img: *mut c_void, mask: *mut c_void, rect: core::Rect, bgd_model: *mut c_void, fgd_model: *mut c_void, iter_count: i32, mode: i32) -> cv_return_value_void;
        pub fn cv_initUndistortRectifyMap__InputArray__InputArray__InputArray__InputArray_Size_int__OutputArray__OutputArray(camera_matrix: *mut c_void, dist_coeffs: *mut c_void, r: *mut c_void, new_camera_matrix: *mut c_void, size: core::Size, m1type: i32, map1: *mut c_void, map2: *mut c_void) -> cv_return_value_void;
        pub fn cv_initWideAngleProjMap__InputArray__InputArray_Size_int_int__OutputArray__OutputArray_int_double(camera_matrix: *mut c_void, dist_coeffs: *mut c_void, image_size: core::Size, dest_image_width: i32, m1type: i32, map1: *mut c_void, map2: *mut c_void, proj_type: i32, alpha: f64) -> cv_return_value_float;
        pub fn cv_integral__InputArray__OutputArray__OutputArray__OutputArray_int_int(src: *mut c_void, sum: *mut c_void, sqsum: *mut c_void, tilted: *mut c_void, sdepth: i32, sqdepth: i32) -> cv_return_value_void;
        pub fn cv_integral__InputArray__OutputArray__OutputArray_int_int(src: *mut c_void, sum: *mut c_void, sqsum: *mut c_void, sdepth: i32, sqdepth: i32) -> cv_return_value_void;
        pub fn cv_integral__InputArray__OutputArray_int(src: *mut c_void, sum: *mut c_void, sdepth: i32) -> cv_return_value_void;
        pub fn cv_intersectConvexConvex__InputArray__InputArray__OutputArray_bool(_p1: *mut c_void, _p2: *mut c_void, _p12: *mut c_void, handle_nested: bool) -> cv_return_value_float;
        pub fn cv_invertAffineTransform__InputArray__OutputArray(m: *mut c_void, i_m: *mut c_void) -> cv_return_value_void;
        pub fn cv_isContourConvex__InputArray(contour: *mut c_void) -> cv_return_value_bool;
        pub fn cv_line__InputOutputArray_Point_Point_Scalar_int_int_int(img: *mut c_void, pt1: core::Point, pt2: core::Point, color: core::Scalar, thickness: i32, line_type: i32, shift: i32) -> cv_return_value_void;
        pub fn cv_linearPolar__InputArray__OutputArray_Point2f_double_int(src: *mut c_void, dst: *mut c_void, center: core::Point2f, max_radius: f64, flags: i32) -> cv_return_value_void;
        pub fn cv_logPolar__InputArray__OutputArray_Point2f_double_int(src: *mut c_void, dst: *mut c_void, center: core::Point2f, m: f64, flags: i32) -> cv_return_value_void;
        pub fn cv_matchShapes__InputArray__InputArray_int_double(contour1: *mut c_void, contour2: *mut c_void, method: i32, parameter: f64) -> cv_return_value_double;
        pub fn cv_matchTemplate__InputArray__InputArray__OutputArray_int__InputArray(image: *mut c_void, templ: *mut c_void, result: *mut c_void, method: i32, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_medianBlur__InputArray__OutputArray_int(src: *mut c_void, dst: *mut c_void, ksize: i32) -> cv_return_value_void;
        pub fn cv_minAreaRect__InputArray(points: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_minEnclosingCircle__InputArray_Point2f_float(points: *mut c_void, center: *mut core::Point2f, radius: *mut f32) -> cv_return_value_void;
        pub fn cv_minEnclosingTriangle__InputArray__OutputArray(points: *mut c_void, triangle: *mut c_void) -> cv_return_value_double;
        pub fn cv_morphologyDefaultBorderValue() -> cv_return_value_ScalarWrapper;
        pub fn cv_morphologyEx__InputArray__OutputArray_int__InputArray_Point_int_int_Scalar(src: *mut c_void, dst: *mut c_void, op: i32, kernel: *mut c_void, anchor: core::Point, iterations: i32, border_type: i32, border_value: core::Scalar) -> cv_return_value_void;
        pub fn cv_phaseCorrelate__InputArray__InputArray__InputArray_double_X(src1: *mut c_void, src2: *mut c_void, window: *mut c_void, response: *mut f64) -> cv_return_value_Point2dWrapper;
        pub fn cv_pointPolygonTest__InputArray_Point2f_bool(contour: *mut c_void, pt: core::Point2f, measure_dist: bool) -> cv_return_value_double;
        pub fn cv_polylines__InputOutputArray__InputArray_bool_Scalar_int_int_int(img: *mut c_void, pts: *mut c_void, is_closed: bool, color: core::Scalar, thickness: i32, line_type: i32, shift: i32) -> cv_return_value_void;
        pub fn cv_preCornerDetect__InputArray__OutputArray_int_int(src: *mut c_void, dst: *mut c_void, ksize: i32, border_type: i32) -> cv_return_value_void;
        pub fn cv_putText__InputOutputArray_String_Point_int_double_Scalar_int_int_bool(img: *mut c_void, text: *const c_char, org: core::Point, font_face: i32, font_scale: f64, color: core::Scalar, thickness: i32, line_type: i32, bottom_left_origin: bool) -> cv_return_value_void;
        pub fn cv_pyrDown__InputArray__OutputArray_Size_int(src: *mut c_void, dst: *mut c_void, dstsize: core::Size, border_type: i32) -> cv_return_value_void;
        pub fn cv_pyrMeanShiftFiltering__InputArray__OutputArray_double_double_int_TermCriteria(src: *mut c_void, dst: *mut c_void, sp: f64, sr: f64, max_level: i32, termcrit: *mut c_void) -> cv_return_value_void;
        pub fn cv_pyrUp__InputArray__OutputArray_Size_int(src: *mut c_void, dst: *mut c_void, dstsize: core::Size, border_type: i32) -> cv_return_value_void;
        pub fn cv_rectangle_Mat_Rect_Scalar_int_int_int(img: *mut c_void, rec: core::Rect, color: core::Scalar, thickness: i32, line_type: i32, shift: i32) -> cv_return_value_void;
        pub fn cv_rectangle__InputOutputArray_Point_Point_Scalar_int_int_int(img: *mut c_void, pt1: core::Point, pt2: core::Point, color: core::Scalar, thickness: i32, line_type: i32, shift: i32) -> cv_return_value_void;
        pub fn cv_remap__InputArray__OutputArray__InputArray__InputArray_int_int_Scalar(src: *mut c_void, dst: *mut c_void, map1: *mut c_void, map2: *mut c_void, interpolation: i32, border_mode: i32, border_value: core::Scalar) -> cv_return_value_void;
        pub fn cv_resize__InputArray__OutputArray_Size_double_double_int(src: *mut c_void, dst: *mut c_void, dsize: core::Size, fx: f64, fy: f64, interpolation: i32) -> cv_return_value_void;
        pub fn cv_rotatedRectangleIntersection_RotatedRect_RotatedRect__OutputArray(rect1: *mut c_void, rect2: *mut c_void, intersecting_region: *mut c_void) -> cv_return_value_int;
        pub fn cv_sepFilter2D__InputArray__OutputArray_int__InputArray__InputArray_Point_double_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, kernel_x: *mut c_void, kernel_y: *mut c_void, anchor: core::Point, delta: f64, border_type: i32) -> cv_return_value_void;
        pub fn cv_spatialGradient__InputArray__OutputArray__OutputArray_int_int(src: *mut c_void, dx: *mut c_void, dy: *mut c_void, ksize: i32, border_type: i32) -> cv_return_value_void;
        pub fn cv_sqrBoxFilter__InputArray__OutputArray_int_Size_Point_bool_int(_src: *mut c_void, _dst: *mut c_void, ddepth: i32, ksize: core::Size, anchor: core::Point, normalize: bool, border_type: i32) -> cv_return_value_void;
        pub fn cv_threshold__InputArray__OutputArray_double_double_int(src: *mut c_void, dst: *mut c_void, thresh: f64, maxval: f64, _type: i32) -> cv_return_value_double;
        pub fn cv_undistortPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray(src: *mut c_void, dst: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, r: *mut c_void, p: *mut c_void) -> cv_return_value_void;
        pub fn cv_undistort__InputArray__OutputArray__InputArray__InputArray__InputArray(src: *mut c_void, dst: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, new_camera_matrix: *mut c_void) -> cv_return_value_void;
        pub fn cv_warpAffine__InputArray__OutputArray__InputArray_Size_int_int_Scalar(src: *mut c_void, dst: *mut c_void, m: *mut c_void, dsize: core::Size, flags: i32, border_mode: i32, border_value: core::Scalar) -> cv_return_value_void;
        pub fn cv_warpPerspective__InputArray__OutputArray__InputArray_Size_int_int_Scalar(src: *mut c_void, dst: *mut c_void, m: *mut c_void, dsize: core::Size, flags: i32, border_mode: i32, border_value: core::Scalar) -> cv_return_value_void;
        pub fn cv_watershed__InputArray__InputOutputArray(image: *mut c_void, markers: *mut c_void) -> cv_return_value_void;
        pub fn cv_CLAHE_apply__InputArray__OutputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_CLAHE_setClipLimit_double(instance: *mut c_void, clip_limit: f64) -> cv_return_value_void;
        pub fn cv_CLAHE_getClipLimit_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_CLAHE_setTilesGridSize_Size(instance: *mut c_void, tile_grid_size: core::Size) -> cv_return_value_void;
        pub fn cv_CLAHE_getTilesGridSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_CLAHE_collectGarbage(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_GeneralizedHough_setTemplate__InputArray_Point(instance: *mut c_void, templ: *mut c_void, templ_center: core::Point) -> cv_return_value_void;
        pub fn cv_GeneralizedHough_setTemplate__InputArray__InputArray__InputArray_Point(instance: *mut c_void, edges: *mut c_void, dx: *mut c_void, dy: *mut c_void, templ_center: core::Point) -> cv_return_value_void;
        pub fn cv_GeneralizedHough_detect__InputArray__OutputArray__OutputArray(instance: *mut c_void, image: *mut c_void, positions: *mut c_void, votes: *mut c_void) -> cv_return_value_void;
        pub fn cv_GeneralizedHough_detect__InputArray__InputArray__InputArray__OutputArray__OutputArray(instance: *mut c_void, edges: *mut c_void, dx: *mut c_void, dy: *mut c_void, positions: *mut c_void, votes: *mut c_void) -> cv_return_value_void;
        pub fn cv_GeneralizedHough_setCannyLowThresh_int(instance: *mut c_void, canny_low_thresh: i32) -> cv_return_value_void;
        pub fn cv_GeneralizedHough_getCannyLowThresh_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_GeneralizedHough_setCannyHighThresh_int(instance: *mut c_void, canny_high_thresh: i32) -> cv_return_value_void;
        pub fn cv_GeneralizedHough_getCannyHighThresh_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_GeneralizedHough_setMinDist_double(instance: *mut c_void, min_dist: f64) -> cv_return_value_void;
        pub fn cv_GeneralizedHough_getMinDist_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GeneralizedHough_setDp_double(instance: *mut c_void, dp: f64) -> cv_return_value_void;
        pub fn cv_GeneralizedHough_getDp_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GeneralizedHough_setMaxBufferSize_int(instance: *mut c_void, max_buffer_size: i32) -> cv_return_value_void;
        pub fn cv_GeneralizedHough_getMaxBufferSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_GeneralizedHoughBallard_setLevels_int(instance: *mut c_void, levels: i32) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughBallard_getLevels_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_GeneralizedHoughBallard_setVotesThreshold_int(instance: *mut c_void, votes_threshold: i32) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughBallard_getVotesThreshold_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_GeneralizedHoughGuil_setXi_double(instance: *mut c_void, xi: f64) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getXi_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GeneralizedHoughGuil_setLevels_int(instance: *mut c_void, levels: i32) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getLevels_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_GeneralizedHoughGuil_setAngleEpsilon_double(instance: *mut c_void, angle_epsilon: f64) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getAngleEpsilon_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GeneralizedHoughGuil_setMinAngle_double(instance: *mut c_void, min_angle: f64) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getMinAngle_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GeneralizedHoughGuil_setMaxAngle_double(instance: *mut c_void, max_angle: f64) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getMaxAngle_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GeneralizedHoughGuil_setAngleStep_double(instance: *mut c_void, angle_step: f64) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getAngleStep_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GeneralizedHoughGuil_setAngleThresh_int(instance: *mut c_void, angle_thresh: i32) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getAngleThresh_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_GeneralizedHoughGuil_setMinScale_double(instance: *mut c_void, min_scale: f64) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getMinScale_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GeneralizedHoughGuil_setMaxScale_double(instance: *mut c_void, max_scale: f64) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getMaxScale_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GeneralizedHoughGuil_setScaleStep_double(instance: *mut c_void, scale_step: f64) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getScaleStep_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_GeneralizedHoughGuil_setScaleThresh_int(instance: *mut c_void, scale_thresh: i32) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getScaleThresh_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_GeneralizedHoughGuil_setPosThresh_int(instance: *mut c_void, pos_thresh: i32) -> cv_return_value_void;
        pub fn cv_GeneralizedHoughGuil_getPosThresh_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_LineIterator_delete(ptr : *mut c_void);
        pub fn cv_LineIterator_LineIterator_Mat_Point_Point_int_bool(img: *mut c_void, pt1: core::Point, pt2: core::Point, connectivity: i32, left_to_right: bool) -> cv_return_value_void_X;
        pub fn cv_LineIterator_pos_const(instance: *const c_void) -> cv_return_value_PointWrapper;
        pub fn cv_LineSegmentDetector_detect__InputArray__OutputArray__OutputArray__OutputArray__OutputArray(instance: *mut c_void, _image: *mut c_void, _lines: *mut c_void, width: *mut c_void, prec: *mut c_void, nfa: *mut c_void) -> cv_return_value_void;
        pub fn cv_LineSegmentDetector_drawSegments__InputOutputArray__InputArray(instance: *mut c_void, _image: *mut c_void, lines: *mut c_void) -> cv_return_value_void;
        pub fn cv_LineSegmentDetector_compareSegments_Size__InputArray__InputArray__InputOutputArray(instance: *mut c_void, size: core::Size, lines1: *mut c_void, lines2: *mut c_void, _image: *mut c_void) -> cv_return_value_int;
        pub fn cv_Subdiv2D_delete(ptr : *mut c_void);
        pub fn cv_Subdiv2D_Subdiv2D() -> cv_return_value_void_X;
        pub fn cv_Subdiv2D_Subdiv2D_Rect(rect: core::Rect) -> cv_return_value_void_X;
        pub fn cv_Subdiv2D_initDelaunay_Rect(instance: *mut c_void, rect: core::Rect) -> cv_return_value_void;
        pub fn cv_Subdiv2D_insert_Point2f(instance: *mut c_void, pt: core::Point2f) -> cv_return_value_int;
        pub fn cv_Subdiv2D_insert_VectorOfPoint2f(instance: *mut c_void, ptvec: *mut c_void) -> cv_return_value_void;
        pub fn cv_Subdiv2D_locate_Point2f_int_int(instance: *mut c_void, pt: core::Point2f, edge: *mut i32, vertex: *mut i32) -> cv_return_value_int;
        pub fn cv_Subdiv2D_findNearest_Point2f_Point2f_X(instance: *mut c_void, pt: core::Point2f, nearest_pt: *mut core::Point2f) -> cv_return_value_int;
        pub fn cv_Subdiv2D_getEdgeList_const_VectorOfVec4f(instance: *const c_void, edge_list: *mut c_void) -> cv_return_value_void;
        pub fn cv_Subdiv2D_getLeadingEdgeList_const_VectorOfint(instance: *const c_void, leading_edge_list: *mut c_void) -> cv_return_value_void;
        pub fn cv_Subdiv2D_getTriangleList_const_VectorOfVec6f(instance: *const c_void, triangle_list: *mut c_void) -> cv_return_value_void;
        pub fn cv_Subdiv2D_getVoronoiFacetList_VectorOfint_VectorOfVectorOfPoint2f_VectorOfPoint2f(instance: *mut c_void, idx: *mut c_void, facet_list: *mut c_void, facet_centers: *mut c_void) -> cv_return_value_void;
        pub fn cv_Subdiv2D_getVertex_const_int_int_X(instance: *const c_void, vertex: i32, first_edge: *mut i32) -> cv_return_value_Point2fWrapper;
        pub fn cv_Subdiv2D_getEdge_const_int_int(instance: *const c_void, edge: i32, next_edge_type: i32) -> cv_return_value_int;
        pub fn cv_Subdiv2D_nextEdge_const_int(instance: *const c_void, edge: i32) -> cv_return_value_int;
        pub fn cv_Subdiv2D_rotateEdge_const_int_int(instance: *const c_void, edge: i32, rotate: i32) -> cv_return_value_int;
        pub fn cv_Subdiv2D_symEdge_const_int(instance: *const c_void, edge: i32) -> cv_return_value_int;
        pub fn cv_Subdiv2D_edgeOrg_const_int_Point2f_X(instance: *const c_void, edge: i32, orgpt: *mut core::Point2f) -> cv_return_value_int;
        pub fn cv_Subdiv2D_edgeDst_const_int_Point2f_X(instance: *const c_void, edge: i32, dstpt: *mut core::Point2f) -> cv_return_value_int;
    
    }
}
pub use imgproc_sys::*;

#[cfg(feature = "contrib")]
mod line_descriptor_sys {
    use super::*;

    extern "C" {
        pub fn cv_line_descriptor_drawKeylines_Mat_VectorOfKeyLine_Mat_Scalar_int(image: *mut c_void, keylines: *mut c_void, out_image: *mut c_void, color: core::Scalar, flags: i32) -> cv_return_value_void;
        pub fn cv_line_descriptor_drawLineMatches_Mat_VectorOfKeyLine_Mat_VectorOfKeyLine_VectorOfDMatch_Mat_Scalar_Scalar_VectorOfchar_int(img1: *mut c_void, keylines1: *mut c_void, img2: *mut c_void, keylines2: *mut c_void, matches1to2: *mut c_void, out_img: *mut c_void, match_color: core::Scalar, single_line_color: core::Scalar, matches_mask: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_BinaryDescriptor_delete(ptr : *mut c_void);
        pub fn cv_line_descriptor_BinaryDescriptor_BinaryDescriptor_Params(parameters: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_line_descriptor_BinaryDescriptor_createBinaryDescriptor() -> cv_return_value_void_X;
        pub fn cv_line_descriptor_BinaryDescriptor_createBinaryDescriptor_Params(parameters: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_line_descriptor_BinaryDescriptor_getNumOfOctaves(instance: *mut c_void) -> cv_return_value_int;
        pub fn cv_line_descriptor_BinaryDescriptor_setNumOfOctaves_int(instance: *mut c_void, octaves: i32) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptor_getWidthOfBand(instance: *mut c_void) -> cv_return_value_int;
        pub fn cv_line_descriptor_BinaryDescriptor_setWidthOfBand_int(instance: *mut c_void, width: i32) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptor_getReductionRatio(instance: *mut c_void) -> cv_return_value_int;
        pub fn cv_line_descriptor_BinaryDescriptor_setReductionRatio_int(instance: *mut c_void, r_ratio: i32) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptor_read_FileNode(instance: *mut c_void, _fn: *mut c_void) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptor_write_const_FileStorage(instance: *const c_void, fs: *mut c_void) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptor_detect_Mat_VectorOfKeyLine_Mat(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptor_detect_const_VectorOfMat_VectorOfVectorOfKeyLine_VectorOfMat(instance: *const c_void, images: *mut c_void, keylines: *mut c_void, masks: *mut c_void) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptor_compute_const_Mat_VectorOfKeyLine_Mat_bool(instance: *const c_void, image: *mut c_void, keylines: *mut c_void, descriptors: *mut c_void, return_float_descr: bool) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptor_compute_const_VectorOfMat_VectorOfVectorOfKeyLine_VectorOfMat_bool(instance: *const c_void, images: *mut c_void, keylines: *mut c_void, descriptors: *mut c_void, return_float_descr: bool) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptor_descriptorSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_line_descriptor_BinaryDescriptor_descriptorType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_line_descriptor_BinaryDescriptor_defaultNorm_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BinaryDescriptor_Params_delete(ptr : *mut c_void);
        pub fn cv_line_descriptor_BinaryDescriptor_Params_Params() -> cv_return_value_void_X;
        pub fn cv_line_descriptor_BinaryDescriptor_Params_read_FileNode(instance: *mut c_void, _fn: *mut c_void) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptor_Params_write_const_FileStorage(instance: *const c_void, fs: *mut c_void) -> cv_return_value_void;
        pub fn cv_BinaryDescriptorMatcher_delete(ptr : *mut c_void);
        pub fn cv_line_descriptor_BinaryDescriptorMatcher_match_const_Mat_Mat_VectorOfDMatch_Mat(instance: *const c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptorMatcher_match_Mat_VectorOfDMatch_VectorOfMat(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, masks: *mut c_void) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptorMatcher_knnMatch_const_Mat_Mat_VectorOfVectorOfDMatch_int_Mat_bool(instance: *const c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, k: i32, mask: *mut c_void, compact_result: bool) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptorMatcher_knnMatch_Mat_VectorOfVectorOfDMatch_int_VectorOfMat_bool(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, k: i32, masks: *mut c_void, compact_result: bool) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptorMatcher_radiusMatch_const_Mat_Mat_VectorOfVectorOfDMatch_float_Mat_bool(instance: *const c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, max_distance: f32, mask: *mut c_void, compact_result: bool) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptorMatcher_radiusMatch_Mat_VectorOfVectorOfDMatch_float_VectorOfMat_bool(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, max_distance: f32, masks: *mut c_void, compact_result: bool) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptorMatcher_add_VectorOfMat(instance: *mut c_void, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptorMatcher_train(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptorMatcher_createBinaryDescriptorMatcher() -> cv_return_value_void_X;
        pub fn cv_line_descriptor_BinaryDescriptorMatcher_clear(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_line_descriptor_BinaryDescriptorMatcher_BinaryDescriptorMatcher() -> cv_return_value_void_X;
        pub fn cv_DrawLinesMatchesFlags_delete(ptr : *mut c_void);
        pub fn cv_KeyLine_delete(ptr : *mut c_void);
        pub fn cv_line_descriptor_KeyLine_getStartPoint_const(instance: *const c_void) -> cv_return_value_Point2fWrapper;
        pub fn cv_line_descriptor_KeyLine_getEndPoint_const(instance: *const c_void) -> cv_return_value_Point2fWrapper;
        pub fn cv_line_descriptor_KeyLine_getStartPointInOctave_const(instance: *const c_void) -> cv_return_value_Point2fWrapper;
        pub fn cv_line_descriptor_KeyLine_getEndPointInOctave_const(instance: *const c_void) -> cv_return_value_Point2fWrapper;
        pub fn cv_line_descriptor_KeyLine_KeyLine() -> cv_return_value_void_X;
        pub fn cv_LSDDetector_delete(ptr : *mut c_void);
        pub fn cv_line_descriptor_LSDDetector_LSDDetector() -> cv_return_value_void_X;
        pub fn cv_line_descriptor_LSDDetector_createLSDDetector() -> cv_return_value_void_X;
        pub fn cv_line_descriptor_LSDDetector_detect_Mat_VectorOfKeyLine_int_int_Mat(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, scale: i32, num_octaves: i32, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_line_descriptor_LSDDetector_detect_const_VectorOfMat_VectorOfVectorOfKeyLine_int_int_VectorOfMat(instance: *const c_void, images: *mut c_void, keylines: *mut c_void, scale: i32, num_octaves: i32, masks: *mut c_void) -> cv_return_value_void;
    
    }
}
#[cfg(feature = "contrib")]
pub use line_descriptor_sys::*;

mod ml_sys {
    use super::*;

    extern "C" {
        pub fn cv_ml_createConcentricSpheresTestSet_int_int_int__OutputArray__OutputArray(nsamples: i32, nfeatures: i32, nclasses: i32, samples: *mut c_void, responses: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_randMVNormal__InputArray__InputArray_int__OutputArray(mean: *mut c_void, cov: *mut c_void, nsamples: i32, samples: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_setTrainMethod_int_double_double(instance: *mut c_void, method: i32, param1: f64, param2: f64) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_getTrainMethod_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_ANN_MLP_setActivationFunction_int_double_double(instance: *mut c_void, _type: i32, param1: f64, param2: f64) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_setLayerSizes__InputArray(instance: *mut c_void, _layer_sizes: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_getLayerSizes_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_ANN_MLP_getTermCriteria_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_ANN_MLP_setTermCriteria_TermCriteria(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_getBackpropWeightScale_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_ANN_MLP_setBackpropWeightScale_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_getBackpropMomentumScale_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_ANN_MLP_setBackpropMomentumScale_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_getRpropDW0_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_ANN_MLP_setRpropDW0_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_getRpropDWPlus_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_ANN_MLP_setRpropDWPlus_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_getRpropDWMinus_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_ANN_MLP_setRpropDWMinus_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_getRpropDWMin_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_ANN_MLP_setRpropDWMin_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_getRpropDWMax_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_ANN_MLP_setRpropDWMax_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_ANN_MLP_getWeights_const_int(instance: *const c_void, layer_idx: i32) -> cv_return_value_void_X;
        pub fn cv_ml_ANN_MLP_create() -> cv_return_value_void_X;
        pub fn cv_ml_ANN_MLP_load_String(filepath: *const c_char) -> cv_return_value_void_X;
        pub fn cv_ml_Boost_getBoostType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_Boost_setBoostType_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_Boost_getWeakCount_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_Boost_setWeakCount_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_Boost_getWeightTrimRate_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_Boost_setWeightTrimRate_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_Boost_create() -> cv_return_value_void_X;
        pub fn cv_ml_DTrees_getMaxCategories_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_DTrees_setMaxCategories_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_DTrees_getMaxDepth_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_DTrees_setMaxDepth_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_DTrees_getMinSampleCount_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_DTrees_setMinSampleCount_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_DTrees_getCVFolds_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_DTrees_setCVFolds_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_DTrees_getUseSurrogates_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ml_DTrees_setUseSurrogates_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_ml_DTrees_getUse1SERule_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ml_DTrees_setUse1SERule_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_ml_DTrees_getTruncatePrunedTree_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ml_DTrees_setTruncatePrunedTree_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_ml_DTrees_getRegressionAccuracy_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_ml_DTrees_setRegressionAccuracy_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_ml_DTrees_getPriors_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_DTrees_setPriors_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_DTrees_getRoots_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_DTrees_getNodes_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_DTrees_getSplits_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_DTrees_getSubsets_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_DTrees_create() -> cv_return_value_void_X;
        pub fn cv_DTrees_Node_delete(ptr : *mut c_void);
        pub fn cv_ml_DTrees_Node_Node() -> cv_return_value_void_X;
        pub fn cv_DTrees_Split_delete(ptr : *mut c_void);
        pub fn cv_ml_DTrees_Split_Split() -> cv_return_value_void_X;
        pub fn cv_ml_EM_getClustersNumber_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_EM_setClustersNumber_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_EM_getCovarianceMatrixType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_EM_setCovarianceMatrixType_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_EM_getTermCriteria_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_EM_setTermCriteria_TermCriteria(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_EM_getWeights_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_EM_getMeans_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_EM_getCovs_const_VectorOfMat(instance: *const c_void, covs: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_EM_predict2_const__InputArray__OutputArray(instance: *const c_void, sample: *mut c_void, probs: *mut c_void) -> cv_return_value_Vec2dWrapper;
        pub fn cv_ml_EM_trainEM__InputArray__OutputArray__OutputArray__OutputArray(instance: *mut c_void, samples: *mut c_void, log_likelihoods: *mut c_void, labels: *mut c_void, probs: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ml_EM_trainE__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__OutputArray(instance: *mut c_void, samples: *mut c_void, means0: *mut c_void, covs0: *mut c_void, weights0: *mut c_void, log_likelihoods: *mut c_void, labels: *mut c_void, probs: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ml_EM_trainM__InputArray__InputArray__OutputArray__OutputArray__OutputArray(instance: *mut c_void, samples: *mut c_void, probs0: *mut c_void, log_likelihoods: *mut c_void, labels: *mut c_void, probs: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ml_EM_create() -> cv_return_value_void_X;
        pub fn cv_ml_KNearest_getDefaultK_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_KNearest_setDefaultK_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_KNearest_getIsClassifier_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ml_KNearest_setIsClassifier_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_ml_KNearest_getEmax_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_KNearest_setEmax_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_KNearest_getAlgorithmType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_KNearest_setAlgorithmType_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_KNearest_findNearest_const__InputArray_int__OutputArray__OutputArray__OutputArray(instance: *const c_void, samples: *mut c_void, k: i32, results: *mut c_void, neighbor_responses: *mut c_void, dist: *mut c_void) -> cv_return_value_float;
        pub fn cv_ml_KNearest_create() -> cv_return_value_void_X;
        pub fn cv_ml_LogisticRegression_getLearningRate_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_LogisticRegression_setLearningRate_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_LogisticRegression_getIterations_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_LogisticRegression_setIterations_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_LogisticRegression_getRegularization_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_LogisticRegression_setRegularization_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_LogisticRegression_getTrainMethod_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_LogisticRegression_setTrainMethod_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_LogisticRegression_getMiniBatchSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_LogisticRegression_setMiniBatchSize_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_LogisticRegression_getTermCriteria_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_LogisticRegression_setTermCriteria_TermCriteria(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_LogisticRegression_predict_const__InputArray__OutputArray_int(instance: *const c_void, samples: *mut c_void, results: *mut c_void, flags: i32) -> cv_return_value_float;
        pub fn cv_ml_LogisticRegression_get_learnt_thetas_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_LogisticRegression_create() -> cv_return_value_void_X;
        pub fn cv_ml_NormalBayesClassifier_predictProb_const__InputArray__OutputArray__OutputArray_int(instance: *const c_void, inputs: *mut c_void, outputs: *mut c_void, output_probs: *mut c_void, flags: i32) -> cv_return_value_float;
        pub fn cv_ml_NormalBayesClassifier_create() -> cv_return_value_void_X;
        pub fn cv_ParamGrid_delete(ptr : *mut c_void);
        pub fn cv_ml_ParamGrid_ParamGrid() -> cv_return_value_void_X;
        pub fn cv_ml_ParamGrid_ParamGrid_double_double_double(_min_val: f64, _max_val: f64, _log_step: f64) -> cv_return_value_void_X;
        pub fn cv_ml_RTrees_getCalculateVarImportance_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ml_RTrees_setCalculateVarImportance_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_ml_RTrees_getActiveVarCount_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_RTrees_setActiveVarCount_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_RTrees_getTermCriteria_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_RTrees_setTermCriteria_TermCriteria(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_RTrees_getVarImportance_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_RTrees_create() -> cv_return_value_void_X;
        pub fn cv_ml_SVM_getType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_SVM_setType_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_ml_SVM_getGamma_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_SVM_setGamma_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_SVM_getCoef0_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_SVM_setCoef0_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_SVM_getDegree_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_SVM_setDegree_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_SVM_getC_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_SVM_setC_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_SVM_getNu_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_SVM_setNu_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_SVM_getP_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_ml_SVM_setP_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_ml_SVM_getClassWeights_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_SVM_setClassWeights_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_SVM_getTermCriteria_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_SVM_setTermCriteria_TermCriteria(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_SVM_getKernelType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_SVM_setKernel_int(instance: *mut c_void, kernel_type: i32) -> cv_return_value_void;
        pub fn cv_ml_SVM_setCustomKernel_PtrOfKernel(instance: *mut c_void, _kernel: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_SVM_trainAuto_PtrOfTrainData_int_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_bool(instance: *mut c_void, data: *mut c_void, k_fold: i32, cgrid: *mut c_void, gamma_grid: *mut c_void, p_grid: *mut c_void, nu_grid: *mut c_void, coeff_grid: *mut c_void, degree_grid: *mut c_void, balanced: bool) -> cv_return_value_bool;
        pub fn cv_ml_SVM_getSupportVectors_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_SVM_getUncompressedSupportVectors_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_SVM_getDecisionFunction_const_int__OutputArray__OutputArray(instance: *const c_void, i: i32, alpha: *mut c_void, svidx: *mut c_void) -> cv_return_value_double;
        pub fn cv_ml_SVM_getDefaultGrid_int(param_id: i32) -> cv_return_value_void_X;
        pub fn cv_ml_SVM_create() -> cv_return_value_void_X;
        pub fn cv_ml_SVM_load_String(filepath: *const c_char) -> cv_return_value_void_X;
        pub fn cv_ml_SVM_Kernel_getType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_SVM_Kernel_calc_int_int_const_float_X_const_float_X_float_X(instance: *mut c_void, vcount: i32, n: i32, vecs: *const f32, another: *const f32, results: *mut f32) -> cv_return_value_void;
        pub fn cv_ml_SVMSGD_getWeights(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ml_SVMSGD_getShift(instance: *mut c_void) -> cv_return_value_float;
        pub fn cv_ml_SVMSGD_setOptimalParameters_int_int(instance: *mut c_void, svmsgd_type: i32, margin_type: i32) -> cv_return_value_void;
        pub fn cv_ml_SVMSGD_getSvmsgdType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_SVMSGD_setSvmsgdType_int(instance: *mut c_void, svmsgd_type: i32) -> cv_return_value_void;
        pub fn cv_ml_SVMSGD_getMarginType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_SVMSGD_setMarginType_int(instance: *mut c_void, margin_type: i32) -> cv_return_value_void;
        pub fn cv_ml_SVMSGD_getMarginRegularization_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_ml_SVMSGD_setMarginRegularization_float(instance: *mut c_void, margin_regularization: f32) -> cv_return_value_void;
        pub fn cv_ml_SVMSGD_getInitialStepSize_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_ml_SVMSGD_setInitialStepSize_float(instance: *mut c_void, initial_step_size: f32) -> cv_return_value_void;
        pub fn cv_ml_SVMSGD_getStepDecreasingPower_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_ml_SVMSGD_setStepDecreasingPower_float(instance: *mut c_void, step_decreasing_power: f32) -> cv_return_value_void;
        pub fn cv_ml_SVMSGD_getTermCriteria_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_SVMSGD_setTermCriteria_TermCriteria(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_SVMSGD_create() -> cv_return_value_void_X;
        pub fn cv_ml_StatModel_getVarCount_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_StatModel_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ml_StatModel_isTrained_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ml_StatModel_isClassifier_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ml_StatModel_train_PtrOfTrainData_int(instance: *mut c_void, train_data: *mut c_void, flags: i32) -> cv_return_value_bool;
        pub fn cv_ml_StatModel_train__InputArray_int__InputArray(instance: *mut c_void, samples: *mut c_void, layout: i32, responses: *mut c_void) -> cv_return_value_bool;
        pub fn cv_ml_StatModel_calcError_const_PtrOfTrainData_bool__OutputArray(instance: *const c_void, data: *mut c_void, test: bool, resp: *mut c_void) -> cv_return_value_float;
        pub fn cv_ml_StatModel_predict_const__InputArray__OutputArray_int(instance: *const c_void, samples: *mut c_void, results: *mut c_void, flags: i32) -> cv_return_value_float;
        pub fn cv_ml_TrainData_missingValue(instance: *mut c_void) -> cv_return_value_float;
        pub fn cv_ml_TrainData_getLayout_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_TrainData_getNTrainSamples_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_TrainData_getNTestSamples_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_TrainData_getNSamples_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_TrainData_getNVars_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_TrainData_getNAllVars_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_TrainData_getSample_const__InputArray_int_float_X(instance: *const c_void, var_idx: *mut c_void, sidx: i32, buf: *mut f32) -> cv_return_value_void;
        pub fn cv_ml_TrainData_getSamples_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getMissing_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getTrainSamples_const_int_bool_bool(instance: *const c_void, layout: i32, compress_samples: bool, compress_vars: bool) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getTrainResponses_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getTrainNormCatResponses_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getTestResponses_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getTestNormCatResponses_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getResponses_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getNormCatResponses_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getSampleWeights_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getTrainSampleWeights_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getTestSampleWeights_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getVarIdx_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getVarType_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getVarSymbolFlags_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getResponseType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ml_TrainData_getTrainSampleIdx_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getTestSampleIdx_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getValues_const_int__InputArray_float_X(instance: *const c_void, vi: i32, sidx: *mut c_void, values: *mut f32) -> cv_return_value_void;
        pub fn cv_ml_TrainData_getNormCatValues_const_int__InputArray_int_X(instance: *const c_void, vi: i32, sidx: *mut c_void, values: *mut i32) -> cv_return_value_void;
        pub fn cv_ml_TrainData_getDefaultSubstValues_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getCatCount_const_int(instance: *const c_void, vi: i32) -> cv_return_value_int;
        pub fn cv_ml_TrainData_getClassLabels_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getCatOfs_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getCatMap_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_setTrainTestSplit_int_bool(instance: *mut c_void, count: i32, shuffle: bool) -> cv_return_value_void;
        pub fn cv_ml_TrainData_setTrainTestSplitRatio_double_bool(instance: *mut c_void, ratio: f64, shuffle: bool) -> cv_return_value_void;
        pub fn cv_ml_TrainData_shuffleTrainTest(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_TrainData_getTestSamples_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_getNames_const_VectorOfString(instance: *const c_void, names: *mut c_void) -> cv_return_value_void;
        pub fn cv_ml_TrainData_getSubVector_Mat_Mat(vec: *mut c_void, idx: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_loadFromCSV_String_int_int_int_String_char_char(filename: *const c_char, header_line_count: i32, response_start_idx: i32, response_end_idx: i32, var_type_spec: *const c_char, delimiter: i8, missch: i8) -> cv_return_value_void_X;
        pub fn cv_ml_TrainData_create__InputArray_int__InputArray__InputArray__InputArray__InputArray__InputArray(samples: *mut c_void, layout: i32, responses: *mut c_void, var_idx: *mut c_void, sample_idx: *mut c_void, sample_weights: *mut c_void, var_type: *mut c_void) -> cv_return_value_void_X;
    
    }
}
pub use ml_sys::*;

mod objdetect_sys {
    use super::*;

    extern "C" {
        pub fn cv_createFaceDetectionMaskGenerator() -> cv_return_value_void_X;
        pub fn cv_groupRectangles_VectorOfRect_VectorOfint_VectorOfdouble_int_double(rect_list: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, group_threshold: i32, eps: f64) -> cv_return_value_void;
        pub fn cv_groupRectangles_VectorOfRect_VectorOfint_int_double(rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, eps: f64) -> cv_return_value_void;
        pub fn cv_groupRectangles_VectorOfRect_int_double(rect_list: *mut c_void, group_threshold: i32, eps: f64) -> cv_return_value_void;
        pub fn cv_groupRectangles_VectorOfRect_int_double_VectorOfint_VectorOfdouble(rect_list: *mut c_void, group_threshold: i32, eps: f64, weights: *mut c_void, level_weights: *mut c_void) -> cv_return_value_void;
        pub fn cv_groupRectangles_meanshift_VectorOfRect_VectorOfdouble_VectorOfdouble_double_Size(rect_list: *mut c_void, found_weights: *mut c_void, found_scales: *mut c_void, detect_threshold: f64, win_det_size: core::Size) -> cv_return_value_void;
        pub fn cv_BaseCascadeClassifier_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_BaseCascadeClassifier_load_String(instance: *mut c_void, filename: *const c_char) -> cv_return_value_bool;
        pub fn cv_BaseCascadeClassifier_detectMultiScale__InputArray_VectorOfRect_double_int_int_Size_Size(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: core::Size, max_size: core::Size) -> cv_return_value_void;
        pub fn cv_BaseCascadeClassifier_detectMultiScale__InputArray_VectorOfRect_VectorOfint_double_int_int_Size_Size(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, num_detections: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: core::Size, max_size: core::Size) -> cv_return_value_void;
        pub fn cv_BaseCascadeClassifier_detectMultiScale__InputArray_VectorOfRect_VectorOfint_VectorOfdouble_double_int_int_Size_Size_bool(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: core::Size, max_size: core::Size, output_reject_levels: bool) -> cv_return_value_void;
        pub fn cv_BaseCascadeClassifier_isOldFormatCascade_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_BaseCascadeClassifier_getOriginalWindowSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_BaseCascadeClassifier_getFeatureType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BaseCascadeClassifier_getOldCascade(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_BaseCascadeClassifier_setMaskGenerator_PtrOfMaskGenerator(instance: *mut c_void, mask_generator: *mut c_void) -> cv_return_value_void;
        pub fn cv_BaseCascadeClassifier_getMaskGenerator(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_BaseCascadeClassifier_MaskGenerator_generateMask_Mat(instance: *mut c_void, src: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_BaseCascadeClassifier_MaskGenerator_initializeMask_Mat(instance: *mut c_void, unnamed_arg: *mut c_void) -> cv_return_value_void;
        pub fn cv_CascadeClassifier_delete(ptr : *mut c_void);
        pub fn cv_CascadeClassifier_CascadeClassifier() -> cv_return_value_void_X;
        pub fn cv_CascadeClassifier_CascadeClassifier_String(filename: *const c_char) -> cv_return_value_void_X;
        pub fn cv_CascadeClassifier_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_CascadeClassifier_load_String(instance: *mut c_void, filename: *const c_char) -> cv_return_value_bool;
        pub fn cv_CascadeClassifier_read_FileNode(instance: *mut c_void, node: *mut c_void) -> cv_return_value_bool;
        pub fn cv_CascadeClassifier_detectMultiScale__InputArray_VectorOfRect_double_int_int_Size_Size(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: core::Size, max_size: core::Size) -> cv_return_value_void;
        pub fn cv_CascadeClassifier_detectMultiScale__InputArray_VectorOfRect_VectorOfint_double_int_int_Size_Size(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, num_detections: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: core::Size, max_size: core::Size) -> cv_return_value_void;
        pub fn cv_CascadeClassifier_detectMultiScale__InputArray_VectorOfRect_VectorOfint_VectorOfdouble_double_int_int_Size_Size_bool(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: core::Size, max_size: core::Size, output_reject_levels: bool) -> cv_return_value_void;
        pub fn cv_CascadeClassifier_isOldFormatCascade_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_CascadeClassifier_getOriginalWindowSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_CascadeClassifier_getFeatureType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_CascadeClassifier_getOldCascade(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_CascadeClassifier_convert_String_String(oldcascade: *const c_char, newcascade: *const c_char) -> cv_return_value_bool;
        pub fn cv_CascadeClassifier_setMaskGenerator_PtrOfMaskGenerator(instance: *mut c_void, mask_generator: *mut c_void) -> cv_return_value_void;
        pub fn cv_CascadeClassifier_getMaskGenerator(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_DetectionBasedTracker_delete(ptr : *mut c_void);
        pub fn cv_DetectionBasedTracker_run(instance: *mut c_void) -> cv_return_value_bool;
        pub fn cv_DetectionBasedTracker_stop(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_DetectionBasedTracker_resetTracking(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_DetectionBasedTracker_process_Mat(instance: *mut c_void, image_gray: *mut c_void) -> cv_return_value_void;
        pub fn cv_DetectionBasedTracker_setParameters_Parameters(instance: *mut c_void, params: *mut c_void) -> cv_return_value_bool;
        pub fn cv_DetectionBasedTracker_getParameters_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_DetectionBasedTracker_getObjects_const_VectorOfRect(instance: *const c_void, result: *mut c_void) -> cv_return_value_void;
        pub fn cv_DetectionBasedTracker_getObjects_const_VectorOfExtObject(instance: *const c_void, result: *mut c_void) -> cv_return_value_void;
        pub fn cv_DetectionBasedTracker_addObject_Rect(instance: *mut c_void, location: core::Rect) -> cv_return_value_int;
        pub fn cv_DetectionBasedTracker_ExtObject_delete(ptr : *mut c_void);
        pub fn cv_DetectionBasedTracker_ExtObject_ExtObject_int_Rect_DetectionBasedTracker_ObjectStatus(_id: i32, _location: core::Rect, _status: crate::objdetect::DetectionBasedTracker_ObjectStatus) -> cv_return_value_void_X;
        pub fn cv_DetectionBasedTracker_IDetector_detect_Mat_VectorOfRect(instance: *mut c_void, image: *mut c_void, objects: *mut c_void) -> cv_return_value_void;
        pub fn cv_DetectionBasedTracker_IDetector_setMinObjectSize_Size(instance: *mut c_void, min: core::Size) -> cv_return_value_void;
        pub fn cv_DetectionBasedTracker_IDetector_setMaxObjectSize_Size(instance: *mut c_void, max: core::Size) -> cv_return_value_void;
        pub fn cv_DetectionBasedTracker_IDetector_getMinObjectSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_DetectionBasedTracker_IDetector_getMaxObjectSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_DetectionBasedTracker_IDetector_getScaleFactor(instance: *mut c_void) -> cv_return_value_float;
        pub fn cv_DetectionBasedTracker_IDetector_setScaleFactor_float(instance: *mut c_void, value: f32) -> cv_return_value_void;
        pub fn cv_DetectionBasedTracker_IDetector_getMinNeighbours(instance: *mut c_void) -> cv_return_value_int;
        pub fn cv_DetectionBasedTracker_IDetector_setMinNeighbours_int(instance: *mut c_void, value: i32) -> cv_return_value_void;
        pub fn cv_DetectionBasedTracker_Parameters_delete(ptr : *mut c_void);
        pub fn cv_DetectionBasedTracker_Parameters_Parameters() -> cv_return_value_void_X;
        pub fn cv_DetectionROI_delete(ptr : *mut c_void);
        pub fn cv_HOGDescriptor_delete(ptr : *mut c_void);
        pub fn cv_HOGDescriptor_winSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_HOGDescriptor_set_winSize_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_blockSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_HOGDescriptor_set_blockSize_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_blockStride_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_HOGDescriptor_set_blockStride_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_cellSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_HOGDescriptor_set_cellSize_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_nbins_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_HOGDescriptor_set_nbins_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_derivAperture_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_HOGDescriptor_set_derivAperture_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_winSigma_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_HOGDescriptor_set_winSigma_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_histogramNormType_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_HOGDescriptor_set_histogramNormType_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_L2HysThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_HOGDescriptor_set_L2HysThreshold_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_gammaCorrection_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_HOGDescriptor_set_gammaCorrection_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_svmDetector(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_HOGDescriptor_set_svmDetector_VectorOffloat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_nlevels_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_HOGDescriptor_set_nlevels_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_signedGradient_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_HOGDescriptor_set_signedGradient_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_HOGDescriptor() -> cv_return_value_void_X;
        pub fn cv_HOGDescriptor_HOGDescriptor_Size_Size_Size_Size_int_int_double_int_double_bool_int_bool(_win_size: core::Size, _block_size: core::Size, _block_stride: core::Size, _cell_size: core::Size, _nbins: i32, _deriv_aperture: i32, _win_sigma: f64, _histogram_norm_type: i32, _l2_hys_threshold: f64, _gamma_correction: bool, _nlevels: i32, _signed_gradient: bool) -> cv_return_value_void_X;
        pub fn cv_HOGDescriptor_HOGDescriptor_String(filename: *const c_char) -> cv_return_value_void_X;
        pub fn cv_HOGDescriptor_HOGDescriptor_HOGDescriptor(d: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_HOGDescriptor_getDescriptorSize_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_HOGDescriptor_checkDetectorSize_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_HOGDescriptor_getWinSigma_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_HOGDescriptor_setSVMDetector__InputArray(instance: *mut c_void, _svmdetector: *mut c_void) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_read_FileNode(instance: *mut c_void, _fn: *mut c_void) -> cv_return_value_bool;
        pub fn cv_HOGDescriptor_write_const_FileStorage_String(instance: *const c_void, fs: *mut c_void, objname: *const c_char) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_load_String_String(instance: *mut c_void, filename: *const c_char, objname: *const c_char) -> cv_return_value_bool;
        pub fn cv_HOGDescriptor_save_const_String_String(instance: *const c_void, filename: *const c_char, objname: *const c_char) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_copyTo_const_HOGDescriptor(instance: *const c_void, c: *mut c_void) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_compute_const__InputArray_VectorOffloat_Size_Size_VectorOfPoint(instance: *const c_void, img: *mut c_void, descriptors: *mut c_void, win_stride: core::Size, padding: core::Size, locations: *mut c_void) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_detect_const_Mat_VectorOfPoint_VectorOfdouble_double_Size_Size_VectorOfPoint(instance: *const c_void, img: *mut c_void, found_locations: *mut c_void, weights: *mut c_void, hit_threshold: f64, win_stride: core::Size, padding: core::Size, search_locations: *mut c_void) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_detect_const_Mat_VectorOfPoint_double_Size_Size_VectorOfPoint(instance: *const c_void, img: *mut c_void, found_locations: *mut c_void, hit_threshold: f64, win_stride: core::Size, padding: core::Size, search_locations: *mut c_void) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_detectMultiScale_const__InputArray_VectorOfRect_VectorOfdouble_double_Size_Size_double_double_bool(instance: *const c_void, img: *mut c_void, found_locations: *mut c_void, found_weights: *mut c_void, hit_threshold: f64, win_stride: core::Size, padding: core::Size, scale: f64, final_threshold: f64, use_meanshift_grouping: bool) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_detectMultiScale_const__InputArray_VectorOfRect_double_Size_Size_double_double_bool(instance: *const c_void, img: *mut c_void, found_locations: *mut c_void, hit_threshold: f64, win_stride: core::Size, padding: core::Size, scale: f64, final_threshold: f64, use_meanshift_grouping: bool) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_computeGradient_const_Mat_Mat_Mat_Size_Size(instance: *const c_void, img: *mut c_void, grad: *mut c_void, angle_ofs: *mut c_void, padding_tl: core::Size, padding_br: core::Size) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_getDefaultPeopleDetector() -> cv_return_value_void_X;
        pub fn cv_HOGDescriptor_getDaimlerPeopleDetector() -> cv_return_value_void_X;
        pub fn cv_HOGDescriptor_detectROI_const_Mat_VectorOfPoint_VectorOfPoint_VectorOfdouble_double_Size_Size(instance: *const c_void, img: *mut c_void, locations: *mut c_void, found_locations: *mut c_void, confidences: *mut c_void, hit_threshold: f64, win_stride: core::Size, padding: core::Size) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_detectMultiScaleROI_const_Mat_VectorOfRect_VectorOfDetectionROI_double_int(instance: *const c_void, img: *mut c_void, found_locations: *mut c_void, locations: *mut c_void, hit_threshold: f64, group_threshold: i32) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_readALTModel_String(instance: *mut c_void, modelfile: *mut c_char) -> cv_return_value_void;
        pub fn cv_HOGDescriptor_groupRectangles_const_VectorOfRect_VectorOfdouble_int_double(instance: *const c_void, rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, eps: f64) -> cv_return_value_void;
        pub fn cv_SimilarRects_delete(ptr : *mut c_void);
        pub fn cv_SimilarRects_SimilarRects_double(_eps: f64) -> cv_return_value_void_X;
    
    }
}
pub use objdetect_sys::*;

#[cfg(feature = "contrib")]
mod phase_unwrapping_sys {
    use super::*;

    extern "C" {
        pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_getInverseReliabilityMap__OutputArray(instance: *mut c_void, reliability_map: *mut c_void) -> cv_return_value_void;
        pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_create_Params(parameters: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_HistogramPhaseUnwrapping_Params_delete(ptr : *mut c_void);
        pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_Params() -> cv_return_value_void_X;
        pub fn cv_phase_unwrapping_PhaseUnwrapping_unwrapPhaseMap__InputArray__OutputArray__InputArray(instance: *mut c_void, wrapped_phase_map: *mut c_void, unwrapped_phase_map: *mut c_void, shadow_mask: *mut c_void) -> cv_return_value_void;
    
    }
}
#[cfg(feature = "contrib")]
pub use phase_unwrapping_sys::*;

mod photo_sys {
    use super::*;

    extern "C" {
        pub fn cv_colorChange__InputArray__InputArray__OutputArray_float_float_float(src: *mut c_void, mask: *mut c_void, dst: *mut c_void, red_mul: f32, green_mul: f32, blue_mul: f32) -> cv_return_value_void;
        pub fn cv_createAlignMTB_int_int_bool(max_bits: i32, exclude_range: i32, cut: bool) -> cv_return_value_void_X;
        pub fn cv_createCalibrateDebevec_int_float_bool(samples: i32, lambda: f32, random: bool) -> cv_return_value_void_X;
        pub fn cv_createCalibrateRobertson_int_float(max_iter: i32, threshold: f32) -> cv_return_value_void_X;
        pub fn cv_createMergeDebevec() -> cv_return_value_void_X;
        pub fn cv_createMergeMertens_float_float_float(contrast_weight: f32, saturation_weight: f32, exposure_weight: f32) -> cv_return_value_void_X;
        pub fn cv_createMergeRobertson() -> cv_return_value_void_X;
        pub fn cv_createTonemapDrago_float_float_float(gamma: f32, saturation: f32, bias: f32) -> cv_return_value_void_X;
        pub fn cv_createTonemapDurand_float_float_float_float_float(gamma: f32, contrast: f32, saturation: f32, sigma_space: f32, sigma_color: f32) -> cv_return_value_void_X;
        pub fn cv_createTonemapMantiuk_float_float_float(gamma: f32, scale: f32, saturation: f32) -> cv_return_value_void_X;
        pub fn cv_createTonemapReinhard_float_float_float_float(gamma: f32, intensity: f32, light_adapt: f32, color_adapt: f32) -> cv_return_value_void_X;
        pub fn cv_createTonemap_float(gamma: f32) -> cv_return_value_void_X;
        pub fn cv_decolor__InputArray__OutputArray__OutputArray(src: *mut c_void, grayscale: *mut c_void, color_boost: *mut c_void) -> cv_return_value_void;
        pub fn cv_denoise_TVL1_VectorOfMat_Mat_double_int(observations: *mut c_void, result: *mut c_void, lambda: f64, niters: i32) -> cv_return_value_void;
        pub fn cv_detailEnhance__InputArray__OutputArray_float_float(src: *mut c_void, dst: *mut c_void, sigma_s: f32, sigma_r: f32) -> cv_return_value_void;
        pub fn cv_edgePreservingFilter__InputArray__OutputArray_int_float_float(src: *mut c_void, dst: *mut c_void, flags: i32, sigma_s: f32, sigma_r: f32) -> cv_return_value_void;
        pub fn cv_fastNlMeansDenoisingColoredMulti__InputArray__OutputArray_int_int_float_float_int_int(src_imgs: *mut c_void, dst: *mut c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: f32, h_color: f32, template_window_size: i32, search_window_size: i32) -> cv_return_value_void;
        pub fn cv_fastNlMeansDenoisingColored__InputArray__OutputArray_float_float_int_int(src: *mut c_void, dst: *mut c_void, h: f32, h_color: f32, template_window_size: i32, search_window_size: i32) -> cv_return_value_void;
        pub fn cv_fastNlMeansDenoisingMulti__InputArray__OutputArray_int_int_VectorOffloat_int_int_int(src_imgs: *mut c_void, dst: *mut c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: *mut c_void, template_window_size: i32, search_window_size: i32, norm_type: i32) -> cv_return_value_void;
        pub fn cv_fastNlMeansDenoisingMulti__InputArray__OutputArray_int_int_float_int_int(src_imgs: *mut c_void, dst: *mut c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: f32, template_window_size: i32, search_window_size: i32) -> cv_return_value_void;
        pub fn cv_fastNlMeansDenoising__InputArray__OutputArray_VectorOffloat_int_int_int(src: *mut c_void, dst: *mut c_void, h: *mut c_void, template_window_size: i32, search_window_size: i32, norm_type: i32) -> cv_return_value_void;
        pub fn cv_fastNlMeansDenoising__InputArray__OutputArray_float_int_int(src: *mut c_void, dst: *mut c_void, h: f32, template_window_size: i32, search_window_size: i32) -> cv_return_value_void;
        pub fn cv_illuminationChange__InputArray__InputArray__OutputArray_float_float(src: *mut c_void, mask: *mut c_void, dst: *mut c_void, alpha: f32, beta: f32) -> cv_return_value_void;
        pub fn cv_inpaint__InputArray__InputArray__OutputArray_double_int(src: *mut c_void, inpaint_mask: *mut c_void, dst: *mut c_void, inpaint_radius: f64, flags: i32) -> cv_return_value_void;
        pub fn cv_pencilSketch__InputArray__OutputArray__OutputArray_float_float_float(src: *mut c_void, dst1: *mut c_void, dst2: *mut c_void, sigma_s: f32, sigma_r: f32, shade_factor: f32) -> cv_return_value_void;
        pub fn cv_seamlessClone__InputArray__InputArray__InputArray_Point__OutputArray_int(src: *mut c_void, dst: *mut c_void, mask: *mut c_void, p: core::Point, blend: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_stylization__InputArray__OutputArray_float_float(src: *mut c_void, dst: *mut c_void, sigma_s: f32, sigma_r: f32) -> cv_return_value_void;
        pub fn cv_textureFlattening__InputArray__InputArray__OutputArray_float_float_int(src: *mut c_void, mask: *mut c_void, dst: *mut c_void, low_threshold: f32, high_threshold: f32, kernel_size: i32) -> cv_return_value_void;
        pub fn cv_AlignExposures_process__InputArray_VectorOfMat__InputArray__InputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> cv_return_value_void;
        pub fn cv_AlignMTB_process__InputArray_VectorOfMat__InputArray__InputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> cv_return_value_void;
        pub fn cv_AlignMTB_process__InputArray_VectorOfMat(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_AlignMTB_calculateShift__InputArray__InputArray(instance: *mut c_void, img0: *mut c_void, img1: *mut c_void) -> cv_return_value_PointWrapper;
        pub fn cv_AlignMTB_shiftMat__InputArray__OutputArray_Point(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, shift: core::Point) -> cv_return_value_void;
        pub fn cv_AlignMTB_computeBitmaps__InputArray__OutputArray__OutputArray(instance: *mut c_void, img: *mut c_void, tb: *mut c_void, eb: *mut c_void) -> cv_return_value_void;
        pub fn cv_AlignMTB_getMaxBits_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_AlignMTB_setMaxBits_int(instance: *mut c_void, max_bits: i32) -> cv_return_value_void;
        pub fn cv_AlignMTB_getExcludeRange_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_AlignMTB_setExcludeRange_int(instance: *mut c_void, exclude_range: i32) -> cv_return_value_void;
        pub fn cv_AlignMTB_getCut_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_AlignMTB_setCut_bool(instance: *mut c_void, value: bool) -> cv_return_value_void;
        pub fn cv_CalibrateCRF_process__InputArray__OutputArray__InputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void) -> cv_return_value_void;
        pub fn cv_CalibrateDebevec_getLambda_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_CalibrateDebevec_setLambda_float(instance: *mut c_void, lambda: f32) -> cv_return_value_void;
        pub fn cv_CalibrateDebevec_getSamples_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_CalibrateDebevec_setSamples_int(instance: *mut c_void, samples: i32) -> cv_return_value_void;
        pub fn cv_CalibrateDebevec_getRandom_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_CalibrateDebevec_setRandom_bool(instance: *mut c_void, random: bool) -> cv_return_value_void;
        pub fn cv_CalibrateRobertson_getMaxIter_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_CalibrateRobertson_setMaxIter_int(instance: *mut c_void, max_iter: i32) -> cv_return_value_void;
        pub fn cv_CalibrateRobertson_getThreshold_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_CalibrateRobertson_setThreshold_float(instance: *mut c_void, threshold: f32) -> cv_return_value_void;
        pub fn cv_CalibrateRobertson_getRadiance_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_MergeDebevec_process__InputArray__OutputArray__InputArray__InputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> cv_return_value_void;
        pub fn cv_MergeDebevec_process__InputArray__OutputArray__InputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void) -> cv_return_value_void;
        pub fn cv_MergeExposures_process__InputArray__OutputArray__InputArray__InputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> cv_return_value_void;
        pub fn cv_MergeMertens_process__InputArray__OutputArray__InputArray__InputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> cv_return_value_void;
        pub fn cv_MergeMertens_process__InputArray__OutputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_MergeMertens_getContrastWeight_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_MergeMertens_setContrastWeight_float(instance: *mut c_void, contrast_weiht: f32) -> cv_return_value_void;
        pub fn cv_MergeMertens_getSaturationWeight_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_MergeMertens_setSaturationWeight_float(instance: *mut c_void, saturation_weight: f32) -> cv_return_value_void;
        pub fn cv_MergeMertens_getExposureWeight_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_MergeMertens_setExposureWeight_float(instance: *mut c_void, exposure_weight: f32) -> cv_return_value_void;
        pub fn cv_MergeRobertson_process__InputArray__OutputArray__InputArray__InputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> cv_return_value_void;
        pub fn cv_MergeRobertson_process__InputArray__OutputArray__InputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void) -> cv_return_value_void;
        pub fn cv_Tonemap_process__InputArray__OutputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_Tonemap_getGamma_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_Tonemap_setGamma_float(instance: *mut c_void, gamma: f32) -> cv_return_value_void;
        pub fn cv_TonemapDrago_getSaturation_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_TonemapDrago_setSaturation_float(instance: *mut c_void, saturation: f32) -> cv_return_value_void;
        pub fn cv_TonemapDrago_getBias_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_TonemapDrago_setBias_float(instance: *mut c_void, bias: f32) -> cv_return_value_void;
        pub fn cv_TonemapDurand_getSaturation_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_TonemapDurand_setSaturation_float(instance: *mut c_void, saturation: f32) -> cv_return_value_void;
        pub fn cv_TonemapDurand_getContrast_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_TonemapDurand_setContrast_float(instance: *mut c_void, contrast: f32) -> cv_return_value_void;
        pub fn cv_TonemapDurand_getSigmaSpace_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_TonemapDurand_setSigmaSpace_float(instance: *mut c_void, sigma_space: f32) -> cv_return_value_void;
        pub fn cv_TonemapDurand_getSigmaColor_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_TonemapDurand_setSigmaColor_float(instance: *mut c_void, sigma_color: f32) -> cv_return_value_void;
        pub fn cv_TonemapMantiuk_getScale_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_TonemapMantiuk_setScale_float(instance: *mut c_void, scale: f32) -> cv_return_value_void;
        pub fn cv_TonemapMantiuk_getSaturation_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_TonemapMantiuk_setSaturation_float(instance: *mut c_void, saturation: f32) -> cv_return_value_void;
        pub fn cv_TonemapReinhard_getIntensity_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_TonemapReinhard_setIntensity_float(instance: *mut c_void, intensity: f32) -> cv_return_value_void;
        pub fn cv_TonemapReinhard_getLightAdaptation_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_TonemapReinhard_setLightAdaptation_float(instance: *mut c_void, light_adapt: f32) -> cv_return_value_void;
        pub fn cv_TonemapReinhard_getColorAdaptation_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_TonemapReinhard_setColorAdaptation_float(instance: *mut c_void, color_adapt: f32) -> cv_return_value_void;
    
    }
}
pub use photo_sys::*;

#[cfg(feature = "contrib")]
mod plot_sys {
    use super::*;

    extern "C" {
        pub fn cv_plot_createPlot2d__InputArray(data: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_plot_createPlot2d__InputArray__InputArray(data_x: *mut c_void, data_y: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_plot_Plot2d_setMinX_double(instance: *mut c_void, _plot_min_x: f64) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_setMinY_double(instance: *mut c_void, _plot_min_y: f64) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_setMaxX_double(instance: *mut c_void, _plot_max_x: f64) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_setMaxY_double(instance: *mut c_void, _plot_max_y: f64) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_setPlotLineWidth_int(instance: *mut c_void, _plot_line_width: i32) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_setNeedPlotLine_bool(instance: *mut c_void, _need_plot_line: bool) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_setPlotLineColor_Scalar(instance: *mut c_void, _plot_line_color: core::Scalar) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_setPlotBackgroundColor_Scalar(instance: *mut c_void, _plot_background_color: core::Scalar) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_setPlotAxisColor_Scalar(instance: *mut c_void, _plot_axis_color: core::Scalar) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_setPlotGridColor_Scalar(instance: *mut c_void, _plot_grid_color: core::Scalar) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_setPlotTextColor_Scalar(instance: *mut c_void, _plot_text_color: core::Scalar) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_setPlotSize_int_int(instance: *mut c_void, _plot_size_width: i32, _plot_size_height: i32) -> cv_return_value_void;
        pub fn cv_plot_Plot2d_render__OutputArray(instance: *mut c_void, _plot_result: *mut c_void) -> cv_return_value_void;
    
    }
}
#[cfg(feature = "contrib")]
pub use plot_sys::*;

#[cfg(feature = "contrib")]
mod sfm_sys {
    use super::*;

    pub type cv_return_value_libmv_CameraIntrinsicsOptions = cv_return_value<crate::sfm::libmv_CameraIntrinsicsOptions>;
    pub type cv_return_value_libmv_ReconstructionOptions = cv_return_value<crate::sfm::libmv_ReconstructionOptions>;
    extern "C" {
        pub fn cv_sfm_KRtFromProjection__InputArray__OutputArray__OutputArray__OutputArray(p: *mut c_void, k: *mut c_void, r: *mut c_void, t: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_applyTransformationToPoints__InputArray__InputArray__OutputArray(points: *mut c_void, t: *mut c_void, transformed_points: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_computeOrientation__InputArray__InputArray__OutputArray__OutputArray_double(x1: *mut c_void, x2: *mut c_void, r: *mut c_void, t: *mut c_void, s: f64) -> cv_return_value_void;
        pub fn cv_sfm_depth__InputArray__InputArray__InputArray(r: *mut c_void, t: *mut c_void, x: *mut c_void) -> cv_return_value_double;
        pub fn cv_sfm_essentialFromFundamental__InputArray__InputArray__InputArray__OutputArray(f: *mut c_void, k1: *mut c_void, k2: *mut c_void, e: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_essentialFromRt__InputArray__InputArray__InputArray__InputArray__OutputArray(r1: *mut c_void, t1: *mut c_void, r2: *mut c_void, t2: *mut c_void, e: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_euclideanToHomogeneous__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_fundamentalFromCorrespondences7PointRobust__InputArray__InputArray_double__OutputArray__OutputArray_double(x1: *mut c_void, x2: *mut c_void, max_error: f64, f: *mut c_void, inliers: *mut c_void, outliers_probability: f64) -> cv_return_value_double;
        pub fn cv_sfm_fundamentalFromCorrespondences8PointRobust__InputArray__InputArray_double__OutputArray__OutputArray_double(x1: *mut c_void, x2: *mut c_void, max_error: f64, f: *mut c_void, inliers: *mut c_void, outliers_probability: f64) -> cv_return_value_double;
        pub fn cv_sfm_fundamentalFromEssential__InputArray__InputArray__InputArray__OutputArray(e: *mut c_void, k1: *mut c_void, k2: *mut c_void, f: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_fundamentalFromProjections__InputArray__InputArray__OutputArray(p1: *mut c_void, p2: *mut c_void, f: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_homogeneousToEuclidean__InputArray__OutputArray(src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_importReconstruction_String__OutputArray__OutputArray__OutputArray__OutputArray_int(file: *const c_char, rs: *mut c_void, ts: *mut c_void, ks: *mut c_void, points3d: *mut c_void, file_format: i32) -> cv_return_value_void;
        pub fn cv_sfm_isotropicPreconditionerFromPoints__InputArray__OutputArray(points: *mut c_void, t: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_meanAndVarianceAlongRows__InputArray__OutputArray__OutputArray(a: *mut c_void, mean: *mut c_void, variance: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_motionFromEssentialChooseSolution__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray(rs: *mut c_void, ts: *mut c_void, k1: *mut c_void, x1: *mut c_void, k2: *mut c_void, x2: *mut c_void) -> cv_return_value_int;
        pub fn cv_sfm_motionFromEssential__InputArray__OutputArray__OutputArray(e: *mut c_void, rs: *mut c_void, ts: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_normalizeFundamental__InputArray__OutputArray(f: *mut c_void, f_normalized: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_normalizeIsotropicPoints__InputArray__OutputArray__OutputArray(points: *mut c_void, normalized_points: *mut c_void, t: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_normalizePoints__InputArray__OutputArray__OutputArray(points: *mut c_void, normalized_points: *mut c_void, t: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_normalizedEightPointSolver__InputArray__InputArray__OutputArray(x1: *mut c_void, x2: *mut c_void, f: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_preconditionerFromPoints__InputArray__OutputArray(points: *mut c_void, t: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_projectionFromKRt__InputArray__InputArray__InputArray__OutputArray(k: *mut c_void, r: *mut c_void, t: *mut c_void, p: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_projectionsFromFundamental__InputArray__OutputArray__OutputArray(f: *mut c_void, p1: *mut c_void, p2: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_reconstruct_VectorOfstd_string__OutputArray__OutputArray__InputOutputArray__OutputArray_bool(images: *mut c_void, rs: *mut c_void, ts: *mut c_void, k: *mut c_void, points3d: *mut c_void, is_projective: bool) -> cv_return_value_void;
        pub fn cv_sfm_reconstruct_VectorOfstd_string__OutputArray__OutputArray__InputOutputArray_bool(images: *mut c_void, ps: *mut c_void, points3d: *mut c_void, k: *mut c_void, is_projective: bool) -> cv_return_value_void;
        pub fn cv_sfm_reconstruct__InputArray__OutputArray__OutputArray__InputOutputArray__OutputArray_bool(points2d: *mut c_void, rs: *mut c_void, ts: *mut c_void, k: *mut c_void, points3d: *mut c_void, is_projective: bool) -> cv_return_value_void;
        pub fn cv_sfm_reconstruct__InputArray__OutputArray__OutputArray__InputOutputArray_bool(points2d: *mut c_void, ps: *mut c_void, points3d: *mut c_void, k: *mut c_void, is_projective: bool) -> cv_return_value_void;
        pub fn cv_sfm_relativeCameraMotion__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray(r1: *mut c_void, t1: *mut c_void, r2: *mut c_void, t2: *mut c_void, r: *mut c_void, t: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_skew__InputArray(x: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_sfm_triangulatePoints__InputArray__InputArray__OutputArray(points2d: *mut c_void, projection_matrices: *mut c_void, points3d: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_BaseSFM_run__InputArray(instance: *mut c_void, points2d: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_BaseSFM_run__InputArray__InputOutputArray__OutputArray__OutputArray__OutputArray(instance: *mut c_void, points2d: *mut c_void, k: *mut c_void, rs: *mut c_void, ts: *mut c_void, points3d: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_BaseSFM_run_VectorOfstd_string(instance: *mut c_void, images: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_BaseSFM_run_VectorOfstd_string__InputOutputArray__OutputArray__OutputArray__OutputArray(instance: *mut c_void, images: *mut c_void, k: *mut c_void, rs: *mut c_void, ts: *mut c_void, points3d: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_BaseSFM_getError_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_sfm_BaseSFM_getPoints__OutputArray(instance: *mut c_void, points3d: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_BaseSFM_getIntrinsics_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_sfm_BaseSFM_getCameras__OutputArray__OutputArray(instance: *mut c_void, rs: *mut c_void, ts: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_BaseSFM_setReconstructionOptions_libmv_ReconstructionOptions(instance: *mut c_void, libmv_reconstruction_options: crate::sfm::libmv_ReconstructionOptions) -> cv_return_value_void;
        pub fn cv_sfm_BaseSFM_setCameraIntrinsicOptions_libmv_CameraIntrinsicsOptions(instance: *mut c_void, libmv_camera_intrinsics_options: crate::sfm::libmv_CameraIntrinsicsOptions) -> cv_return_value_void;
        pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run__InputArray(instance: *mut c_void, points2d: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run__InputArray__InputOutputArray__OutputArray__OutputArray__OutputArray(instance: *mut c_void, points2d: *mut c_void, k: *mut c_void, rs: *mut c_void, ts: *mut c_void, points3d: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run_VectorOfstd_string(instance: *mut c_void, images: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run_VectorOfstd_string__InputOutputArray__OutputArray__OutputArray__OutputArray(instance: *mut c_void, images: *mut c_void, k: *mut c_void, rs: *mut c_void, ts: *mut c_void, points3d: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getError_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getPoints__OutputArray(instance: *mut c_void, points3d: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getIntrinsics_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getCameras__OutputArray__OutputArray(instance: *mut c_void, rs: *mut c_void, ts: *mut c_void) -> cv_return_value_void;
        pub fn cv_sfm_SFMLibmvEuclideanReconstruction_setReconstructionOptions_libmv_ReconstructionOptions(instance: *mut c_void, libmv_reconstruction_options: crate::sfm::libmv_ReconstructionOptions) -> cv_return_value_void;
        pub fn cv_sfm_SFMLibmvEuclideanReconstruction_setCameraIntrinsicOptions_libmv_CameraIntrinsicsOptions(instance: *mut c_void, libmv_camera_intrinsics_options: crate::sfm::libmv_CameraIntrinsicsOptions) -> cv_return_value_void;
        pub fn cv_sfm_SFMLibmvEuclideanReconstruction_create_libmv_CameraIntrinsicsOptions_libmv_ReconstructionOptions(camera_instrinsic_options: crate::sfm::libmv_CameraIntrinsicsOptions, reconstruction_options: crate::sfm::libmv_ReconstructionOptions) -> cv_return_value_void_X;
        pub fn cv_sfm_libmv_CameraIntrinsicsOptions_libmv_CameraIntrinsicsOptions_int_double_double_double_double_double_double_double_double(_distortion_model: i32, _focal_length: f64, _principal_point_x: f64, _principal_point_y: f64, _polynomial_k1: f64, _polynomial_k2: f64, _polynomial_k3: f64, _polynomial_p1: f64, _polynomial_p2: f64) -> cv_return_value_libmv_CameraIntrinsicsOptions;
        pub fn cv_sfm_libmv_ReconstructionOptions_libmv_ReconstructionOptions_int_int_int_int_int(_keyframe1: i32, _keyframe2: i32, _refine_intrinsics: i32, _select_keyframes: i32, _verbosity_level: i32) -> cv_return_value_libmv_ReconstructionOptions;
    
    }
}
#[cfg(feature = "contrib")]
pub use sfm_sys::*;

mod shape_sys {
    use super::*;

    extern "C" {
        pub fn cv_EMDL1__InputArray__InputArray(signature1: *mut c_void, signature2: *mut c_void) -> cv_return_value_float;
        pub fn cv_createAffineTransformer_bool(full_affine: bool) -> cv_return_value_void_X;
        pub fn cv_createChiHistogramCostExtractor_int_float(n_dummies: i32, default_cost: f32) -> cv_return_value_void_X;
        pub fn cv_createEMDHistogramCostExtractor_int_int_float(flag: i32, n_dummies: i32, default_cost: f32) -> cv_return_value_void_X;
        pub fn cv_createEMDL1HistogramCostExtractor_int_float(n_dummies: i32, default_cost: f32) -> cv_return_value_void_X;
        pub fn cv_createHausdorffDistanceExtractor_int_float(distance_flag: i32, rank_prop: f32) -> cv_return_value_void_X;
        pub fn cv_createNormHistogramCostExtractor_int_int_float(flag: i32, n_dummies: i32, default_cost: f32) -> cv_return_value_void_X;
        pub fn cv_createThinPlateSplineShapeTransformer_double(regularization_parameter: f64) -> cv_return_value_void_X;
        pub fn cv_AffineTransformer_setFullAffine_bool(instance: *mut c_void, full_affine: bool) -> cv_return_value_void;
        pub fn cv_AffineTransformer_getFullAffine_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ChiHistogramCostExtractor_delete(ptr : *mut c_void);
        pub fn cv_EMDHistogramCostExtractor_setNormFlag_int(instance: *mut c_void, flag: i32) -> cv_return_value_void;
        pub fn cv_EMDHistogramCostExtractor_getNormFlag_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_EMDL1HistogramCostExtractor_delete(ptr : *mut c_void);
        pub fn cv_HausdorffDistanceExtractor_setDistanceFlag_int(instance: *mut c_void, distance_flag: i32) -> cv_return_value_void;
        pub fn cv_HausdorffDistanceExtractor_getDistanceFlag_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_HausdorffDistanceExtractor_setRankProportion_float(instance: *mut c_void, rank_proportion: f32) -> cv_return_value_void;
        pub fn cv_HausdorffDistanceExtractor_getRankProportion_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_HistogramCostExtractor_buildCostMatrix__InputArray__InputArray__OutputArray(instance: *mut c_void, descriptors1: *mut c_void, descriptors2: *mut c_void, cost_matrix: *mut c_void) -> cv_return_value_void;
        pub fn cv_HistogramCostExtractor_setNDummies_int(instance: *mut c_void, n_dummies: i32) -> cv_return_value_void;
        pub fn cv_HistogramCostExtractor_getNDummies_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_HistogramCostExtractor_setDefaultCost_float(instance: *mut c_void, default_cost: f32) -> cv_return_value_void;
        pub fn cv_HistogramCostExtractor_getDefaultCost_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_NormHistogramCostExtractor_setNormFlag_int(instance: *mut c_void, flag: i32) -> cv_return_value_void;
        pub fn cv_NormHistogramCostExtractor_getNormFlag_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ShapeContextDistanceExtractor_setAngularBins_int(instance: *mut c_void, n_angular_bins: i32) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getAngularBins_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ShapeContextDistanceExtractor_setRadialBins_int(instance: *mut c_void, n_radial_bins: i32) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getRadialBins_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ShapeContextDistanceExtractor_setInnerRadius_float(instance: *mut c_void, inner_radius: f32) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getInnerRadius_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_ShapeContextDistanceExtractor_setOuterRadius_float(instance: *mut c_void, outer_radius: f32) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getOuterRadius_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_ShapeContextDistanceExtractor_setRotationInvariant_bool(instance: *mut c_void, rotation_invariant: bool) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getRotationInvariant_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_ShapeContextDistanceExtractor_setShapeContextWeight_float(instance: *mut c_void, shape_context_weight: f32) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getShapeContextWeight_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_ShapeContextDistanceExtractor_setImageAppearanceWeight_float(instance: *mut c_void, image_appearance_weight: f32) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getImageAppearanceWeight_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_ShapeContextDistanceExtractor_setBendingEnergyWeight_float(instance: *mut c_void, bending_energy_weight: f32) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getBendingEnergyWeight_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_ShapeContextDistanceExtractor_setImages__InputArray__InputArray(instance: *mut c_void, image1: *mut c_void, image2: *mut c_void) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getImages_const__OutputArray__OutputArray(instance: *const c_void, image1: *mut c_void, image2: *mut c_void) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_setIterations_int(instance: *mut c_void, iterations: i32) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getIterations_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_ShapeContextDistanceExtractor_setCostExtractor_PtrOfHistogramCostExtractor(instance: *mut c_void, comparer: *mut c_void) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getCostExtractor_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ShapeContextDistanceExtractor_setStdDev_float(instance: *mut c_void, sigma: f32) -> cv_return_value_void;
        pub fn cv_ShapeContextDistanceExtractor_getStdDev_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_ShapeDistanceExtractor_computeDistance__InputArray__InputArray(instance: *mut c_void, contour1: *mut c_void, contour2: *mut c_void) -> cv_return_value_float;
        pub fn cv_ShapeTransformer_estimateTransformation__InputArray__InputArray_VectorOfDMatch(instance: *mut c_void, transforming_shape: *mut c_void, target_shape: *mut c_void, matches: *mut c_void) -> cv_return_value_void;
        pub fn cv_ShapeTransformer_applyTransformation__InputArray__OutputArray(instance: *mut c_void, input: *mut c_void, output: *mut c_void) -> cv_return_value_float;
        pub fn cv_ShapeTransformer_warpImage_const__InputArray__OutputArray_int_int_Scalar(instance: *const c_void, transforming_image: *mut c_void, output: *mut c_void, flags: i32, border_mode: i32, border_value: core::Scalar) -> cv_return_value_void;
        pub fn cv_ThinPlateSplineShapeTransformer_setRegularizationParameter_double(instance: *mut c_void, beta: f64) -> cv_return_value_void;
        pub fn cv_ThinPlateSplineShapeTransformer_getRegularizationParameter_const(instance: *const c_void) -> cv_return_value_double;
    
    }
}
pub use shape_sys::*;

mod stitching_sys {
    use super::*;

    extern "C" {
        pub fn cv_createStitcher_bool(try_use_gpu: bool) -> cv_return_value_void_X;
        pub fn cv_AffineWarper_delete(ptr : *mut c_void);
        pub fn cv_CompressedRectilinearPortraitWarper_delete(ptr : *mut c_void);
        pub fn cv_CompressedRectilinearPortraitWarper_CompressedRectilinearPortraitWarper_float_float(a: f32, b: f32) -> cv_return_value_void_X;
        pub fn cv_CompressedRectilinearWarper_delete(ptr : *mut c_void);
        pub fn cv_CompressedRectilinearWarper_CompressedRectilinearWarper_float_float(a: f32, b: f32) -> cv_return_value_void_X;
        pub fn cv_CylindricalWarper_delete(ptr : *mut c_void);
        pub fn cv_FisheyeWarper_delete(ptr : *mut c_void);
        pub fn cv_MercatorWarper_delete(ptr : *mut c_void);
        pub fn cv_PaniniPortraitWarper_delete(ptr : *mut c_void);
        pub fn cv_PaniniPortraitWarper_PaniniPortraitWarper_float_float(a: f32, b: f32) -> cv_return_value_void_X;
        pub fn cv_PaniniWarper_delete(ptr : *mut c_void);
        pub fn cv_PaniniWarper_PaniniWarper_float_float(a: f32, b: f32) -> cv_return_value_void_X;
        pub fn cv_PlaneWarper_delete(ptr : *mut c_void);
        pub fn cv_SphericalWarper_delete(ptr : *mut c_void);
        pub fn cv_StereographicWarper_delete(ptr : *mut c_void);
        pub fn cv_Stitcher_delete(ptr : *mut c_void);
        pub fn cv_Stitcher_createDefault_bool(try_use_gpu: bool) -> cv_return_value_void_X;
        pub fn cv_Stitcher_create_Stitcher_Mode_bool(mode: crate::stitching::Stitcher_Mode, try_use_gpu: bool) -> cv_return_value_void_X;
        pub fn cv_Stitcher_registrationResol_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_Stitcher_setRegistrationResol_double(instance: *mut c_void, resol_mpx: f64) -> cv_return_value_void;
        pub fn cv_Stitcher_seamEstimationResol_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_Stitcher_setSeamEstimationResol_double(instance: *mut c_void, resol_mpx: f64) -> cv_return_value_void;
        pub fn cv_Stitcher_compositingResol_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_Stitcher_setCompositingResol_double(instance: *mut c_void, resol_mpx: f64) -> cv_return_value_void;
        pub fn cv_Stitcher_panoConfidenceThresh_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_Stitcher_setPanoConfidenceThresh_double(instance: *mut c_void, conf_thresh: f64) -> cv_return_value_void;
        pub fn cv_Stitcher_waveCorrection_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_Stitcher_setWaveCorrection_bool(instance: *mut c_void, flag: bool) -> cv_return_value_void;
        pub fn cv_Stitcher_matchingMask_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_Stitcher_setMatchingMask_UMat(instance: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_Stitcher_estimateTransform__InputArray(instance: *mut c_void, images: *mut c_void) -> cv_return_value_Stitcher_Status;
        pub fn cv_Stitcher_estimateTransform__InputArray_VectorOfVectorOfRect(instance: *mut c_void, images: *mut c_void, rois: *mut c_void) -> cv_return_value_Stitcher_Status;
        pub fn cv_Stitcher_composePanorama__OutputArray(instance: *mut c_void, pano: *mut c_void) -> cv_return_value_Stitcher_Status;
        pub fn cv_Stitcher_composePanorama__InputArray__OutputArray(instance: *mut c_void, images: *mut c_void, pano: *mut c_void) -> cv_return_value_Stitcher_Status;
        pub fn cv_Stitcher_stitch__InputArray__OutputArray(instance: *mut c_void, images: *mut c_void, pano: *mut c_void) -> cv_return_value_Stitcher_Status;
        pub fn cv_Stitcher_stitch__InputArray_VectorOfVectorOfRect__OutputArray(instance: *mut c_void, images: *mut c_void, rois: *mut c_void, pano: *mut c_void) -> cv_return_value_Stitcher_Status;
        pub fn cv_Stitcher_component_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_Stitcher_workScale_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_TransverseMercatorWarper_delete(ptr : *mut c_void);
    
    }
}
pub use stitching_sys::*;

#[cfg(feature = "contrib")]
mod structured_light_sys {
    use super::*;

    extern "C" {
        pub fn cv_structured_light_GrayCodePattern_getNumberOfPatternImages_const(instance: *const c_void) -> cv_return_value_std_size_t;
        pub fn cv_structured_light_GrayCodePattern_setWhiteThreshold_size_t(instance: *mut c_void, value: size_t) -> cv_return_value_void;
        pub fn cv_structured_light_GrayCodePattern_setBlackThreshold_size_t(instance: *mut c_void, value: size_t) -> cv_return_value_void;
        pub fn cv_structured_light_GrayCodePattern_getImagesForShadowMasks_const__InputOutputArray__InputOutputArray(instance: *const c_void, black_image: *mut c_void, white_image: *mut c_void) -> cv_return_value_void;
        pub fn cv_structured_light_GrayCodePattern_getProjPixel_const__InputArray_int_int_Point(instance: *const c_void, pattern_images: *mut c_void, x: i32, y: i32, proj_pix: *mut core::Point) -> cv_return_value_bool;
        pub fn cv_structured_light_GrayCodePattern_create_Params(parameters: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_structured_light_GrayCodePattern_create_int_int(width: i32, height: i32) -> cv_return_value_void_X;
        pub fn cv_GrayCodePattern_Params_delete(ptr : *mut c_void);
        pub fn cv_structured_light_GrayCodePattern_Params_Params() -> cv_return_value_void_X;
        pub fn cv_structured_light_SinusoidalPattern_computePhaseMap__InputArray__OutputArray__OutputArray__InputArray(instance: *mut c_void, pattern_images: *mut c_void, wrapped_phase_map: *mut c_void, shadow_mask: *mut c_void, fundamental: *mut c_void) -> cv_return_value_void;
        pub fn cv_structured_light_SinusoidalPattern_unwrapPhaseMap__InputArray__OutputArray_Size__InputArray(instance: *mut c_void, wrapped_phase_map: *mut c_void, unwrapped_phase_map: *mut c_void, cam_size: core::Size, shadow_mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_structured_light_SinusoidalPattern_findProCamMatches__InputArray__InputArray__OutputArray(instance: *mut c_void, proj_unwrapped_phase_map: *mut c_void, cam_unwrapped_phase_map: *mut c_void, matches: *mut c_void) -> cv_return_value_void;
        pub fn cv_structured_light_SinusoidalPattern_computeDataModulationTerm__InputArray__OutputArray__InputArray(instance: *mut c_void, pattern_images: *mut c_void, data_modulation_term: *mut c_void, shadow_mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_structured_light_SinusoidalPattern_create_Params(parameters: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_SinusoidalPattern_Params_delete(ptr : *mut c_void);
        pub fn cv_structured_light_SinusoidalPattern_Params_Params() -> cv_return_value_void_X;
        pub fn cv_structured_light_StructuredLightPattern_generate__OutputArray(instance: *mut c_void, pattern_images: *mut c_void) -> cv_return_value_bool;
        pub fn cv_structured_light_StructuredLightPattern_decode_const__InputArray__OutputArray__InputArray__InputArray_int(instance: *const c_void, pattern_images: *mut c_void, disparity_map: *mut c_void, black_images: *mut c_void, white_images: *mut c_void, flags: i32) -> cv_return_value_bool;
    
    }
}
#[cfg(feature = "contrib")]
pub use structured_light_sys::*;

mod superres_sys {
    use super::*;

    extern "C" {
        pub fn cv_superres_createFrameSource_Camera_int(device_id: i32) -> cv_return_value_void_X;
        pub fn cv_superres_createFrameSource_Empty() -> cv_return_value_void_X;
        pub fn cv_superres_createFrameSource_Video_CUDA_String(file_name: *const c_char) -> cv_return_value_void_X;
        pub fn cv_superres_createFrameSource_Video_String(file_name: *const c_char) -> cv_return_value_void_X;
        pub fn cv_superres_createSuperResolution_BTVL1() -> cv_return_value_void_X;
        pub fn cv_superres_createSuperResolution_BTVL1_CUDA() -> cv_return_value_void_X;
        pub fn cv_superres_FrameSource_nextFrame__OutputArray(instance: *mut c_void, frame: *mut c_void) -> cv_return_value_void;
        pub fn cv_superres_FrameSource_reset(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_setInput_PtrOfFrameSource(instance: *mut c_void, frame_source: *mut c_void) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_nextFrame__OutputArray(instance: *mut c_void, frame: *mut c_void) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_reset(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_collectGarbage(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_getScale_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_superres_SuperResolution_setScale_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_getIterations_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_superres_SuperResolution_setIterations_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_getTau_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_superres_SuperResolution_setTau_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_getLabmda_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_superres_SuperResolution_setLabmda_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_getAlpha_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_superres_SuperResolution_setAlpha_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_getKernelSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_superres_SuperResolution_setKernelSize_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_getBlurKernelSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_superres_SuperResolution_setBlurKernelSize_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_getBlurSigma_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_superres_SuperResolution_setBlurSigma_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_superres_SuperResolution_getTemporalAreaRadius_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_superres_SuperResolution_setTemporalAreaRadius_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
    
    }
}
pub use superres_sys::*;

mod video_sys {
    use super::*;

    extern "C" {
        pub fn cv_CamShift__InputArray_Rect_TermCriteria(prob_image: *mut c_void, window: *mut core::Rect, criteria: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_buildOpticalFlowPyramid__InputArray__OutputArray_Size_int_bool_int_int_bool(img: *mut c_void, pyramid: *mut c_void, win_size: core::Size, max_level: i32, with_derivatives: bool, pyr_border: i32, deriv_border: i32, try_reuse_input_image: bool) -> cv_return_value_int;
        pub fn cv_calcOpticalFlowFarneback__InputArray__InputArray__InputOutputArray_double_int_int_int_int_double_int(prev: *mut c_void, next: *mut c_void, flow: *mut c_void, pyr_scale: f64, levels: i32, winsize: i32, iterations: i32, poly_n: i32, poly_sigma: f64, flags: i32) -> cv_return_value_void;
        pub fn cv_calcOpticalFlowPyrLK__InputArray__InputArray__InputArray__InputOutputArray__OutputArray__OutputArray_Size_int_TermCriteria_int_double(prev_img: *mut c_void, next_img: *mut c_void, prev_pts: *mut c_void, next_pts: *mut c_void, status: *mut c_void, err: *mut c_void, win_size: core::Size, max_level: i32, criteria: *mut c_void, flags: i32, min_eig_threshold: f64) -> cv_return_value_void;
        pub fn cv_createBackgroundSubtractorKNN_int_double_bool(history: i32, dist2_threshold: f64, detect_shadows: bool) -> cv_return_value_void_X;
        pub fn cv_createBackgroundSubtractorMOG2_int_double_bool(history: i32, var_threshold: f64, detect_shadows: bool) -> cv_return_value_void_X;
        pub fn cv_createOptFlow_DualTVL1() -> cv_return_value_void_X;
        pub fn cv_estimateRigidTransform__InputArray__InputArray_bool(src: *mut c_void, dst: *mut c_void, full_affine: bool) -> cv_return_value_void_X;
        pub fn cv_findTransformECC__InputArray__InputArray__InputOutputArray_int_TermCriteria__InputArray(template_image: *mut c_void, input_image: *mut c_void, warp_matrix: *mut c_void, motion_type: i32, criteria: *mut c_void, input_mask: *mut c_void) -> cv_return_value_double;
        pub fn cv_meanShift__InputArray_Rect_TermCriteria(prob_image: *mut c_void, window: *mut core::Rect, criteria: *mut c_void) -> cv_return_value_int;
        pub fn cv_BackgroundSubtractor_apply__InputArray__OutputArray_double(instance: *mut c_void, image: *mut c_void, fgmask: *mut c_void, learning_rate: f64) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractor_getBackgroundImage_const__OutputArray(instance: *const c_void, background_image: *mut c_void) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorKNN_getHistory_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BackgroundSubtractorKNN_setHistory_int(instance: *mut c_void, history: i32) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorKNN_getNSamples_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BackgroundSubtractorKNN_setNSamples_int(instance: *mut c_void, _n_n: i32) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorKNN_getDist2Threshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_BackgroundSubtractorKNN_setDist2Threshold_double(instance: *mut c_void, _dist2_threshold: f64) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorKNN_getkNNSamples_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BackgroundSubtractorKNN_setkNNSamples_int(instance: *mut c_void, _nk_nn: i32) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorKNN_getDetectShadows_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_BackgroundSubtractorKNN_setDetectShadows_bool(instance: *mut c_void, detect_shadows: bool) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorKNN_getShadowValue_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BackgroundSubtractorKNN_setShadowValue_int(instance: *mut c_void, value: i32) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorKNN_getShadowThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_BackgroundSubtractorKNN_setShadowThreshold_double(instance: *mut c_void, threshold: f64) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getHistory_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BackgroundSubtractorMOG2_setHistory_int(instance: *mut c_void, history: i32) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getNMixtures_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BackgroundSubtractorMOG2_setNMixtures_int(instance: *mut c_void, nmixtures: i32) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getBackgroundRatio_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_BackgroundSubtractorMOG2_setBackgroundRatio_double(instance: *mut c_void, ratio: f64) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getVarThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_BackgroundSubtractorMOG2_setVarThreshold_double(instance: *mut c_void, var_threshold: f64) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getVarThresholdGen_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_BackgroundSubtractorMOG2_setVarThresholdGen_double(instance: *mut c_void, var_threshold_gen: f64) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getVarInit_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_BackgroundSubtractorMOG2_setVarInit_double(instance: *mut c_void, var_init: f64) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getVarMin_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_BackgroundSubtractorMOG2_setVarMin_double(instance: *mut c_void, var_min: f64) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getVarMax_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_BackgroundSubtractorMOG2_setVarMax_double(instance: *mut c_void, var_max: f64) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getComplexityReductionThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_BackgroundSubtractorMOG2_setComplexityReductionThreshold_double(instance: *mut c_void, ct: f64) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getDetectShadows_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_BackgroundSubtractorMOG2_setDetectShadows_bool(instance: *mut c_void, detect_shadows: bool) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getShadowValue_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_BackgroundSubtractorMOG2_setShadowValue_int(instance: *mut c_void, value: i32) -> cv_return_value_void;
        pub fn cv_BackgroundSubtractorMOG2_getShadowThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_BackgroundSubtractorMOG2_setShadowThreshold_double(instance: *mut c_void, threshold: f64) -> cv_return_value_void;
        pub fn cv_DenseOpticalFlow_calc__InputArray__InputArray__InputOutputArray(instance: *mut c_void, i0: *mut c_void, i1: *mut c_void, flow: *mut c_void) -> cv_return_value_void;
        pub fn cv_DenseOpticalFlow_collectGarbage(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getTau_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_DualTVL1OpticalFlow_setTau_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getLambda_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_DualTVL1OpticalFlow_setLambda_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getTheta_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_DualTVL1OpticalFlow_setTheta_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getGamma_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_DualTVL1OpticalFlow_setGamma_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getScalesNumber_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_DualTVL1OpticalFlow_setScalesNumber_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getWarpingsNumber_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_DualTVL1OpticalFlow_setWarpingsNumber_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getEpsilon_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_DualTVL1OpticalFlow_setEpsilon_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getInnerIterations_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_DualTVL1OpticalFlow_setInnerIterations_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getOuterIterations_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_DualTVL1OpticalFlow_setOuterIterations_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getUseInitialFlow_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_DualTVL1OpticalFlow_setUseInitialFlow_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getScaleStep_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_DualTVL1OpticalFlow_setScaleStep_double(instance: *mut c_void, val: f64) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_getMedianFiltering_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_DualTVL1OpticalFlow_setMedianFiltering_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_DualTVL1OpticalFlow_create_double_double_double_int_int_double_int_int_double_double_int_bool(tau: f64, lambda: f64, theta: f64, nscales: i32, warps: i32, epsilon: f64, innner_iterations: i32, outer_iterations: i32, scale_step: f64, gamma: f64, median_filtering: i32, use_initial_flow: bool) -> cv_return_value_void_X;
        pub fn cv_FarnebackOpticalFlow_getNumLevels_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_FarnebackOpticalFlow_setNumLevels_int(instance: *mut c_void, num_levels: i32) -> cv_return_value_void;
        pub fn cv_FarnebackOpticalFlow_getPyrScale_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_FarnebackOpticalFlow_setPyrScale_double(instance: *mut c_void, pyr_scale: f64) -> cv_return_value_void;
        pub fn cv_FarnebackOpticalFlow_getFastPyramids_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_FarnebackOpticalFlow_setFastPyramids_bool(instance: *mut c_void, fast_pyramids: bool) -> cv_return_value_void;
        pub fn cv_FarnebackOpticalFlow_getWinSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_FarnebackOpticalFlow_setWinSize_int(instance: *mut c_void, win_size: i32) -> cv_return_value_void;
        pub fn cv_FarnebackOpticalFlow_getNumIters_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_FarnebackOpticalFlow_setNumIters_int(instance: *mut c_void, num_iters: i32) -> cv_return_value_void;
        pub fn cv_FarnebackOpticalFlow_getPolyN_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_FarnebackOpticalFlow_setPolyN_int(instance: *mut c_void, poly_n: i32) -> cv_return_value_void;
        pub fn cv_FarnebackOpticalFlow_getPolySigma_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_FarnebackOpticalFlow_setPolySigma_double(instance: *mut c_void, poly_sigma: f64) -> cv_return_value_void;
        pub fn cv_FarnebackOpticalFlow_getFlags_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_FarnebackOpticalFlow_setFlags_int(instance: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_FarnebackOpticalFlow_create_int_double_bool_int_int_int_double_int(num_levels: i32, pyr_scale: f64, fast_pyramids: bool, win_size: i32, num_iters: i32, poly_n: i32, poly_sigma: f64, flags: i32) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_delete(ptr : *mut c_void);
        pub fn cv_KalmanFilter_statePre(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_set_statePre_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_KalmanFilter_statePost(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_set_statePost_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_KalmanFilter_transitionMatrix(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_set_transitionMatrix_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_KalmanFilter_controlMatrix(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_set_controlMatrix_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_KalmanFilter_measurementMatrix(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_set_measurementMatrix_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_KalmanFilter_processNoiseCov(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_set_processNoiseCov_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_KalmanFilter_measurementNoiseCov(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_set_measurementNoiseCov_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_KalmanFilter_errorCovPre(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_set_errorCovPre_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_KalmanFilter_gain(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_set_gain_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_KalmanFilter_errorCovPost(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_set_errorCovPost_Mat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_KalmanFilter_KalmanFilter() -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_KalmanFilter_int_int_int_int(dynam_params: i32, measure_params: i32, control_params: i32, _type: i32) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_init_int_int_int_int(instance: *mut c_void, dynam_params: i32, measure_params: i32, control_params: i32, _type: i32) -> cv_return_value_void;
        pub fn cv_KalmanFilter_predict_Mat(instance: *mut c_void, control: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_KalmanFilter_correct_Mat(instance: *mut c_void, measurement: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_SparseOpticalFlow_calc__InputArray__InputArray__InputArray__InputOutputArray__OutputArray__OutputArray(instance: *mut c_void, prev_img: *mut c_void, next_img: *mut c_void, prev_pts: *mut c_void, next_pts: *mut c_void, status: *mut c_void, err: *mut c_void) -> cv_return_value_void;
        pub fn cv_SparsePyrLKOpticalFlow_getWinSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_SparsePyrLKOpticalFlow_setWinSize_Size(instance: *mut c_void, win_size: core::Size) -> cv_return_value_void;
        pub fn cv_SparsePyrLKOpticalFlow_getMaxLevel_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_SparsePyrLKOpticalFlow_setMaxLevel_int(instance: *mut c_void, max_level: i32) -> cv_return_value_void;
        pub fn cv_SparsePyrLKOpticalFlow_getTermCriteria_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_SparsePyrLKOpticalFlow_setTermCriteria_TermCriteria(instance: *mut c_void, crit: *mut c_void) -> cv_return_value_void;
        pub fn cv_SparsePyrLKOpticalFlow_getFlags_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_SparsePyrLKOpticalFlow_setFlags_int(instance: *mut c_void, flags: i32) -> cv_return_value_void;
        pub fn cv_SparsePyrLKOpticalFlow_getMinEigThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_SparsePyrLKOpticalFlow_setMinEigThreshold_double(instance: *mut c_void, min_eig_threshold: f64) -> cv_return_value_void;
        pub fn cv_SparsePyrLKOpticalFlow_create_Size_int_TermCriteria_int_double(win_size: core::Size, max_level: i32, crit: *mut c_void, flags: i32, min_eig_threshold: f64) -> cv_return_value_void_X;
    
    }
}
pub use video_sys::*;

mod videoio_sys {
    use super::*;

    extern "C" {
        pub fn cv_VideoCapture_delete(ptr : *mut c_void);
        pub fn cv_VideoCapture_VideoCapture() -> cv_return_value_void_X;
        pub fn cv_VideoCapture_VideoCapture_String(filename: *const c_char) -> cv_return_value_void_X;
        pub fn cv_VideoCapture_VideoCapture_String_int(filename: *const c_char, api_preference: i32) -> cv_return_value_void_X;
        pub fn cv_VideoCapture_VideoCapture_int(index: i32) -> cv_return_value_void_X;
        pub fn cv_VideoCapture_open_String(instance: *mut c_void, filename: *const c_char) -> cv_return_value_bool;
        pub fn cv_VideoCapture_open_int(instance: *mut c_void, index: i32) -> cv_return_value_bool;
        pub fn cv_VideoCapture_open_int_int(instance: *mut c_void, camera_num: i32, api_preference: i32) -> cv_return_value_bool;
        pub fn cv_VideoCapture_isOpened_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_VideoCapture_release(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_VideoCapture_grab(instance: *mut c_void) -> cv_return_value_bool;
        pub fn cv_VideoCapture_retrieve__OutputArray_int(instance: *mut c_void, image: *mut c_void, flag: i32) -> cv_return_value_bool;
        pub fn cv_VideoCapture_read__OutputArray(instance: *mut c_void, image: *mut c_void) -> cv_return_value_bool;
        pub fn cv_VideoCapture_set_int_double(instance: *mut c_void, prop_id: i32, value: f64) -> cv_return_value_bool;
        pub fn cv_VideoCapture_get_const_int(instance: *const c_void, prop_id: i32) -> cv_return_value_double;
        pub fn cv_VideoCapture_open_String_int(instance: *mut c_void, filename: *const c_char, api_preference: i32) -> cv_return_value_bool;
        pub fn cv_VideoWriter_delete(ptr : *mut c_void);
        pub fn cv_VideoWriter_VideoWriter() -> cv_return_value_void_X;
        pub fn cv_VideoWriter_VideoWriter_String_int_double_Size_bool(filename: *const c_char, fourcc: i32, fps: f64, frame_size: core::Size, is_color: bool) -> cv_return_value_void_X;
        pub fn cv_VideoWriter_open_String_int_double_Size_bool(instance: *mut c_void, filename: *const c_char, fourcc: i32, fps: f64, frame_size: core::Size, is_color: bool) -> cv_return_value_bool;
        pub fn cv_VideoWriter_isOpened_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_VideoWriter_release(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_VideoWriter_write_Mat(instance: *mut c_void, image: *mut c_void) -> cv_return_value_void;
        pub fn cv_VideoWriter_set_int_double(instance: *mut c_void, prop_id: i32, value: f64) -> cv_return_value_bool;
        pub fn cv_VideoWriter_get_const_int(instance: *const c_void, prop_id: i32) -> cv_return_value_double;
        pub fn cv_VideoWriter_fourcc_char_char_char_char(c1: i8, c2: i8, c3: i8, c4: i8) -> cv_return_value_int;
    
    }
}
pub use videoio_sys::*;

mod videostab_sys {
    use super::*;

    extern "C" {
        pub fn cv_videostab_calcBlurriness_Mat(frame: *mut c_void) -> cv_return_value_float;
        pub fn cv_videostab_calcFlowMask_Mat_Mat_Mat_float_Mat_Mat_Mat(flow_x: *mut c_void, flow_y: *mut c_void, errors: *mut c_void, max_error: f32, mask0: *mut c_void, mask1: *mut c_void, flow_mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_completeFrameAccordingToFlow_Mat_Mat_Mat_Mat_Mat_float_Mat_Mat(flow_mask: *mut c_void, flow_x: *mut c_void, flow_y: *mut c_void, frame1: *mut c_void, mask1: *mut c_void, dist_thresh: f32, frame0: *mut c_void, mask0: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_ensureInclusionConstraint_Mat_Size_float(m: *mut c_void, size: core::Size, trim_ratio: f32) -> cv_return_value_void_X;
        pub fn cv_videostab_estimateGlobalMotionLeastSquares__InputOutputArray__InputOutputArray_int_float_X(points0: *mut c_void, points1: *mut c_void, model: i32, rmse: *mut f32) -> cv_return_value_void_X;
        pub fn cv_videostab_estimateOptimalTrimRatio_Mat_Size(m: *mut c_void, size: core::Size) -> cv_return_value_float;
        pub fn cv_videostab_getMotion_int_int_VectorOfMat(from: i32, to: i32, motions: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_ColorAverageInpainter_delete(ptr : *mut c_void);
        pub fn cv_videostab_ColorAverageInpainter_inpaint_int_Mat_Mat(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_ColorInpainter_delete(ptr : *mut c_void);
        pub fn cv_videostab_ColorInpainter_ColorInpainter_int_double(method: i32, radius: f64) -> cv_return_value_void_X;
        pub fn cv_videostab_ColorInpainter_inpaint_int_Mat_Mat(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_ConsistentMosaicInpainter_delete(ptr : *mut c_void);
        pub fn cv_videostab_ConsistentMosaicInpainter_ConsistentMosaicInpainter() -> cv_return_value_void_X;
        pub fn cv_videostab_ConsistentMosaicInpainter_setStdevThresh_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_videostab_ConsistentMosaicInpainter_stdevThresh_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_videostab_ConsistentMosaicInpainter_inpaint_int_Mat_Mat(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_DeblurerBase_setRadius_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_videostab_DeblurerBase_radius_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_videostab_DeblurerBase_deblur_int_Mat(instance: *mut c_void, idx: i32, frame: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_DeblurerBase_setFrames_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_DeblurerBase_frames_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_DeblurerBase_setMotions_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_DeblurerBase_motions_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_DeblurerBase_setBlurrinessRates_VectorOffloat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_DeblurerBase_blurrinessRates_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_FastMarchingMethod_delete(ptr : *mut c_void);
        pub fn cv_videostab_FastMarchingMethod_FastMarchingMethod() -> cv_return_value_void_X;
        pub fn cv_videostab_FastMarchingMethod_distanceMap_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_FromFileMotionReader_delete(ptr : *mut c_void);
        pub fn cv_videostab_FromFileMotionReader_FromFileMotionReader_String(path: *const c_char) -> cv_return_value_void_X;
        pub fn cv_videostab_FromFileMotionReader_estimate_Mat_Mat_bool_X(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, ok: *mut bool) -> cv_return_value_void_X;
        pub fn cv_GaussianMotionFilter_delete(ptr : *mut c_void);
        pub fn cv_videostab_GaussianMotionFilter_GaussianMotionFilter_int_float(radius: i32, stdev: f32) -> cv_return_value_void_X;
        pub fn cv_videostab_GaussianMotionFilter_setParams_int_float(instance: *mut c_void, radius: i32, stdev: f32) -> cv_return_value_void;
        pub fn cv_videostab_GaussianMotionFilter_radius_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_videostab_GaussianMotionFilter_stdev_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_videostab_IDenseOptFlowEstimator_run__InputArray__InputArray__InputOutputArray__InputOutputArray__OutputArray(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, flow_x: *mut c_void, flow_y: *mut c_void, errors: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_IFrameSource_reset(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_IFrameSource_nextFrame(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_IOutlierRejector_process_Size__InputArray__InputArray__OutputArray(instance: *mut c_void, frame_size: core::Size, points0: *mut c_void, points1: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_ISparseOptFlowEstimator_run__InputArray__InputArray__InputArray__InputOutputArray__OutputArray__OutputArray(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, points0: *mut c_void, points1: *mut c_void, status: *mut c_void, errors: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_ImageMotionEstimatorBase_estimate_Mat_Mat_bool_X(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, ok: *mut bool) -> cv_return_value_void_X;
        pub fn cv_videostab_InpainterBase_setRadius_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_videostab_InpainterBase_radius_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_videostab_InpainterBase_inpaint_int_Mat_Mat(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_InpainterBase_setFrames_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_InpainterBase_frames_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_InpainterBase_setMotions_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_InpainterBase_motions_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_InpainterBase_setStabilizedFrames_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_InpainterBase_stabilizedFrames_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_InpainterBase_setStabilizationMotions_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_InpainterBase_stabilizationMotions_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_InpaintingPipeline_delete(ptr : *mut c_void);
        pub fn cv_videostab_InpaintingPipeline_pushBack_PtrOfInpainterBase(instance: *mut c_void, inpainter: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_InpaintingPipeline_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_videostab_InpaintingPipeline_setRadius_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_videostab_InpaintingPipeline_setFrames_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_InpaintingPipeline_setMotions_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_InpaintingPipeline_setStabilizedFrames_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_InpaintingPipeline_setStabilizationMotions_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_InpaintingPipeline_inpaint_int_Mat_Mat(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_KeypointBasedMotionEstimator_delete(ptr : *mut c_void);
        pub fn cv_videostab_KeypointBasedMotionEstimator_KeypointBasedMotionEstimator_PtrOfMotionEstimatorBase(estimator: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_KeypointBasedMotionEstimator_setDetector_PtrOfFeature2D(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_KeypointBasedMotionEstimator_detector_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_KeypointBasedMotionEstimator_estimate_Mat_Mat_bool_X(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, ok: *mut bool) -> cv_return_value_void_X;
        pub fn cv_LogToStdout_delete(ptr : *mut c_void);
        pub fn cv_LpMotionStabilizer_delete(ptr : *mut c_void);
        pub fn cv_videostab_LpMotionStabilizer_setFrameSize_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_videostab_LpMotionStabilizer_frameSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_videostab_LpMotionStabilizer_setTrimRatio_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_videostab_LpMotionStabilizer_trimRatio_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_videostab_LpMotionStabilizer_setWeight1_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_videostab_LpMotionStabilizer_weight1_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_videostab_LpMotionStabilizer_setWeight2_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_videostab_LpMotionStabilizer_weight2_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_videostab_LpMotionStabilizer_setWeight3_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_videostab_LpMotionStabilizer_weight3_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_videostab_LpMotionStabilizer_setWeight4_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_videostab_LpMotionStabilizer_weight4_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_MoreAccurateMotionWobbleSuppressor_delete(ptr : *mut c_void);
        pub fn cv_videostab_MoreAccurateMotionWobbleSuppressor_suppress_int_Mat_Mat(instance: *mut c_void, idx: i32, frame: *mut c_void, result: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorBase_setPeriod_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorBase_period_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_MoreAccurateMotionWobbleSuppressorBase_delete(ptr : *mut c_void);
        pub fn cv_videostab_MotionEstimatorBase_estimate__InputArray__InputArray_bool_X(instance: *mut c_void, points0: *mut c_void, points1: *mut c_void, ok: *mut bool) -> cv_return_value_void_X;
        pub fn cv_MotionEstimatorL1_delete(ptr : *mut c_void);
        pub fn cv_videostab_MotionEstimatorL1_estimate__InputArray__InputArray_bool_X(instance: *mut c_void, points0: *mut c_void, points1: *mut c_void, ok: *mut bool) -> cv_return_value_void_X;
        pub fn cv_MotionEstimatorRansacL2_delete(ptr : *mut c_void);
        pub fn cv_videostab_MotionEstimatorRansacL2_setMinInlierRatio_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_videostab_MotionEstimatorRansacL2_minInlierRatio_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_videostab_MotionEstimatorRansacL2_estimate__InputArray__InputArray_bool_X(instance: *mut c_void, points0: *mut c_void, points1: *mut c_void, ok: *mut bool) -> cv_return_value_void_X;
        pub fn cv_MotionInpainter_delete(ptr : *mut c_void);
        pub fn cv_videostab_MotionInpainter_MotionInpainter() -> cv_return_value_void_X;
        pub fn cv_videostab_MotionInpainter_setFlowErrorThreshold_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_videostab_MotionInpainter_flowErrorThreshold_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_videostab_MotionInpainter_setDistThreshold_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_videostab_MotionInpainter_distThresh_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_videostab_MotionInpainter_setBorderMode_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_videostab_MotionInpainter_borderMode_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_videostab_MotionInpainter_inpaint_int_Mat_Mat(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_MotionStabilizationPipeline_delete(ptr : *mut c_void);
        pub fn cv_videostab_MotionStabilizationPipeline_pushBack_PtrOfIMotionStabilizer(instance: *mut c_void, stabilizer: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_MotionStabilizationPipeline_empty_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_NullDeblurer_delete(ptr : *mut c_void);
        pub fn cv_videostab_NullDeblurer_deblur_int_Mat(instance: *mut c_void, unnamed_arg: i32, unnamed_arg_1: *mut c_void) -> cv_return_value_void;
        pub fn cv_NullFrameSource_delete(ptr : *mut c_void);
        pub fn cv_videostab_NullFrameSource_reset(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_NullFrameSource_nextFrame(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_NullInpainter_delete(ptr : *mut c_void);
        pub fn cv_videostab_NullInpainter_inpaint_int_Mat_Mat(instance: *mut c_void, unnamed_arg: i32, unnamed_arg_1: *mut c_void, unnamed_arg_2: *mut c_void) -> cv_return_value_void;
        pub fn cv_NullLog_delete(ptr : *mut c_void);
        pub fn cv_NullOutlierRejector_delete(ptr : *mut c_void);
        pub fn cv_videostab_NullOutlierRejector_process_Size__InputArray__InputArray__OutputArray(instance: *mut c_void, frame_size: core::Size, points0: *mut c_void, points1: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_NullWobbleSuppressor_delete(ptr : *mut c_void);
        pub fn cv_videostab_NullWobbleSuppressor_suppress_int_Mat_Mat(instance: *mut c_void, idx: i32, frame: *mut c_void, result: *mut c_void) -> cv_return_value_void;
        pub fn cv_OnePassStabilizer_delete(ptr : *mut c_void);
        pub fn cv_videostab_OnePassStabilizer_OnePassStabilizer() -> cv_return_value_void_X;
        pub fn cv_videostab_OnePassStabilizer_setMotionFilter_PtrOfMotionFilterBase(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_OnePassStabilizer_motionFilter_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_OnePassStabilizer_reset(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_OnePassStabilizer_nextFrame(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_PyrLkOptFlowEstimatorBase_setWinSize_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_videostab_PyrLkOptFlowEstimatorBase_winSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_videostab_PyrLkOptFlowEstimatorBase_setMaxLevel_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_videostab_PyrLkOptFlowEstimatorBase_maxLevel_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_PyrLkOptFlowEstimatorBase_delete(ptr : *mut c_void);
        pub fn cv_videostab_PyrLkOptFlowEstimatorBase_PyrLkOptFlowEstimatorBase() -> cv_return_value_void_X;
        pub fn cv_RansacParams_delete(ptr : *mut c_void);
        pub fn cv_videostab_RansacParams_niters_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_SparsePyrLkOptFlowEstimator_delete(ptr : *mut c_void);
        pub fn cv_videostab_SparsePyrLkOptFlowEstimator_run__InputArray__InputArray__InputArray__InputOutputArray__OutputArray__OutputArray(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, points0: *mut c_void, points1: *mut c_void, status: *mut c_void, errors: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_StabilizerBase_setLog_PtrOfILog(instance: *mut c_void, ilog: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_StabilizerBase_log_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_StabilizerBase_setRadius_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_videostab_StabilizerBase_radius_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_videostab_StabilizerBase_setFrameSource_PtrOfIFrameSource(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_StabilizerBase_frameSource_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_StabilizerBase_setMotionEstimator_PtrOfImageMotionEstimatorBase(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_StabilizerBase_motionEstimator_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_StabilizerBase_setDeblurer_PtrOfDeblurerBase(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_StabilizerBase_deblurrer_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_StabilizerBase_setTrimRatio_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_videostab_StabilizerBase_trimRatio_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_videostab_StabilizerBase_setCorrectionForInclusion_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_videostab_StabilizerBase_doCorrectionForInclusion_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_videostab_StabilizerBase_setBorderMode_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_videostab_StabilizerBase_borderMode_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_videostab_StabilizerBase_setInpainter_PtrOfInpainterBase(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_StabilizerBase_inpainter_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_ToFileMotionWriter_delete(ptr : *mut c_void);
        pub fn cv_videostab_ToFileMotionWriter_ToFileMotionWriter_String_PtrOfImageMotionEstimatorBase(path: *const c_char, estimator: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_ToFileMotionWriter_estimate_Mat_Mat_bool_X(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, ok: *mut bool) -> cv_return_value_void_X;
        pub fn cv_TranslationBasedLocalOutlierRejector_delete(ptr : *mut c_void);
        pub fn cv_videostab_TranslationBasedLocalOutlierRejector_TranslationBasedLocalOutlierRejector() -> cv_return_value_void_X;
        pub fn cv_videostab_TranslationBasedLocalOutlierRejector_setCellSize_Size(instance: *mut c_void, val: core::Size) -> cv_return_value_void;
        pub fn cv_videostab_TranslationBasedLocalOutlierRejector_cellSize_const(instance: *const c_void) -> cv_return_value_SizeWrapper;
        pub fn cv_videostab_TranslationBasedLocalOutlierRejector_process_Size__InputArray__InputArray__OutputArray(instance: *mut c_void, frame_size: core::Size, points0: *mut c_void, points1: *mut c_void, mask: *mut c_void) -> cv_return_value_void;
        pub fn cv_TwoPassStabilizer_delete(ptr : *mut c_void);
        pub fn cv_videostab_TwoPassStabilizer_TwoPassStabilizer() -> cv_return_value_void_X;
        pub fn cv_videostab_TwoPassStabilizer_setMotionStabilizer_PtrOfIMotionStabilizer(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_TwoPassStabilizer_motionStabilizer_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_TwoPassStabilizer_setEstimateTrimRatio_bool(instance: *mut c_void, val: bool) -> cv_return_value_void;
        pub fn cv_videostab_TwoPassStabilizer_mustEstimateTrimaRatio_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_videostab_TwoPassStabilizer_reset(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_TwoPassStabilizer_nextFrame(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_VideoFileSource_delete(ptr : *mut c_void);
        pub fn cv_videostab_VideoFileSource_VideoFileSource_String_bool(path: *const c_char, volatile_frame: bool) -> cv_return_value_void_X;
        pub fn cv_videostab_VideoFileSource_reset(instance: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_VideoFileSource_nextFrame(instance: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_VideoFileSource_width(instance: *mut c_void) -> cv_return_value_int;
        pub fn cv_videostab_VideoFileSource_height(instance: *mut c_void) -> cv_return_value_int;
        pub fn cv_videostab_VideoFileSource_count(instance: *mut c_void) -> cv_return_value_int;
        pub fn cv_videostab_VideoFileSource_fps(instance: *mut c_void) -> cv_return_value_double;
        pub fn cv_WeightingDeblurer_delete(ptr : *mut c_void);
        pub fn cv_videostab_WeightingDeblurer_WeightingDeblurer() -> cv_return_value_void_X;
        pub fn cv_videostab_WeightingDeblurer_setSensitivity_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_videostab_WeightingDeblurer_sensitivity_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_videostab_WeightingDeblurer_deblur_int_Mat(instance: *mut c_void, idx: i32, frame: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_WobbleSuppressorBase_setMotionEstimator_PtrOfImageMotionEstimatorBase(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_WobbleSuppressorBase_motionEstimator_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_WobbleSuppressorBase_suppress_int_Mat_Mat(instance: *mut c_void, idx: i32, frame: *mut c_void, result: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_WobbleSuppressorBase_setFrameCount_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_videostab_WobbleSuppressorBase_frameCount_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_videostab_WobbleSuppressorBase_setMotions_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_WobbleSuppressorBase_motions_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_WobbleSuppressorBase_setMotions2_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_WobbleSuppressorBase_motions2_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_videostab_WobbleSuppressorBase_setStabilizationMotions_VectorOfMat(instance: *mut c_void, val: *mut c_void) -> cv_return_value_void;
        pub fn cv_videostab_WobbleSuppressorBase_stabilizationMotions_const(instance: *const c_void) -> cv_return_value_void_X;
    
    }
}
pub use videostab_sys::*;

#[cfg(feature = "contrib")]
mod xfeatures2d_sys {
    use super::*;

    extern "C" {
        pub fn cv_BoostDesc_delete(ptr : *mut c_void);
        pub fn cv_xfeatures2d_BoostDesc_create_int_bool_float(desc: i32, use_scale_orientation: bool, scale_factor: f32) -> cv_return_value_void_X;
        pub fn cv_BriefDescriptorExtractor_delete(ptr : *mut c_void);
        pub fn cv_xfeatures2d_BriefDescriptorExtractor_create_int_bool(bytes: i32, use_orientation: bool) -> cv_return_value_void_X;
        pub fn cv_xfeatures2d_DAISY_compute__InputArray_VectorOfKeyPoint__OutputArray(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_DAISY_compute__InputArray_VectorOfVectorOfKeyPoint__OutputArray(instance: *mut c_void, images: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_DAISY_compute__InputArray_Rect__OutputArray(instance: *mut c_void, image: *mut c_void, roi: core::Rect, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_DAISY_compute__InputArray__OutputArray(instance: *mut c_void, image: *mut c_void, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_DAISY_GetDescriptor_const_double_double_int_float_X(instance: *const c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_DAISY_GetDescriptor_const_double_double_int_float_X_double_X(instance: *const c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32, h: *mut f64) -> cv_return_value_bool;
        pub fn cv_xfeatures2d_DAISY_GetUnnormalizedDescriptor_const_double_double_int_float_X(instance: *const c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_DAISY_GetUnnormalizedDescriptor_const_double_double_int_float_X_double_X(instance: *const c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32, h: *mut f64) -> cv_return_value_bool;
        pub fn cv_xfeatures2d_DAISY_create_float_int_int_int_int__InputArray_bool_bool(radius: f32, q_radius: i32, q_theta: i32, q_hist: i32, norm: i32, h: *mut c_void, interpolation: bool, use_orientation: bool) -> cv_return_value_void_X;
        pub fn cv_FREAK_delete(ptr : *mut c_void);
        pub fn cv_xfeatures2d_FREAK_create_bool_bool_float_int_VectorOfint(orientation_normalized: bool, scale_normalized: bool, pattern_scale: f32, n_octaves: i32, selected_pairs: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_LATCH_delete(ptr : *mut c_void);
        pub fn cv_xfeatures2d_LATCH_create_int_bool_int(bytes: i32, rotation_invariance: bool, half_ssd_size: i32) -> cv_return_value_void_X;
        pub fn cv_LUCID_delete(ptr : *mut c_void);
        pub fn cv_xfeatures2d_LUCID_create_int_int(lucid_kernel: i32, blur_kernel: i32) -> cv_return_value_void_X;
        pub fn cv_MSDDetector_delete(ptr : *mut c_void);
        pub fn cv_xfeatures2d_MSDDetector_create_int_int_int_int_float_int_float_int_bool(m_patch_radius: i32, m_search_area_radius: i32, m_nms_radius: i32, m_nms_scale_radius: i32, m_th_saliency: f32, m_k_nn: i32, m_scale_factor: f32, m_n_scales: i32, m_compute_orientation: bool) -> cv_return_value_void_X;
        pub fn cv_xfeatures2d_PCTSignatures_computeSignature_const__InputArray__OutputArray(instance: *const c_void, image: *mut c_void, signature: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_computeSignatures_const_VectorOfMat_VectorOfMat(instance: *const c_void, images: *mut c_void, signatures: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getSampleCount_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xfeatures2d_PCTSignatures_getGrayscaleBits_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xfeatures2d_PCTSignatures_setGrayscaleBits_int(instance: *mut c_void, grayscale_bits: i32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getWindowRadius_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xfeatures2d_PCTSignatures_setWindowRadius_int(instance: *mut c_void, radius: i32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getWeightX_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xfeatures2d_PCTSignatures_setWeightX_float(instance: *mut c_void, weight: f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getWeightY_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xfeatures2d_PCTSignatures_setWeightY_float(instance: *mut c_void, weight: f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getWeightL_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xfeatures2d_PCTSignatures_setWeightL_float(instance: *mut c_void, weight: f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getWeightA_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xfeatures2d_PCTSignatures_setWeightA_float(instance: *mut c_void, weight: f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getWeightB_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xfeatures2d_PCTSignatures_setWeightB_float(instance: *mut c_void, weight: f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getWeightConstrast_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xfeatures2d_PCTSignatures_setWeightContrast_float(instance: *mut c_void, weight: f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getWeightEntropy_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xfeatures2d_PCTSignatures_setWeightEntropy_float(instance: *mut c_void, weight: f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getSamplingPoints_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_xfeatures2d_PCTSignatures_setWeight_int_float(instance: *mut c_void, idx: i32, value: f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_setWeights_VectorOffloat(instance: *mut c_void, weights: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_setTranslation_int_float(instance: *mut c_void, idx: i32, value: f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_setTranslations_VectorOffloat(instance: *mut c_void, translations: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_setSamplingPoints_VectorOfPoint2f(instance: *mut c_void, sampling_points: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getInitSeedIndexes_const(instance: *const c_void) -> cv_return_value_void_X;
        pub fn cv_xfeatures2d_PCTSignatures_setInitSeedIndexes_VectorOfint(instance: *mut c_void, init_seed_indexes: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getInitSeedCount_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xfeatures2d_PCTSignatures_getIterationCount_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xfeatures2d_PCTSignatures_setIterationCount_int(instance: *mut c_void, iteration_count: i32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getMaxClustersCount_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xfeatures2d_PCTSignatures_setMaxClustersCount_int(instance: *mut c_void, max_clusters_count: i32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getClusterMinSize_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xfeatures2d_PCTSignatures_setClusterMinSize_int(instance: *mut c_void, cluster_min_size: i32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getJoiningDistance_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xfeatures2d_PCTSignatures_setJoiningDistance_float(instance: *mut c_void, joining_distance: f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getDropThreshold_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xfeatures2d_PCTSignatures_setDropThreshold_float(instance: *mut c_void, drop_threshold: f32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_getDistanceFunction_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xfeatures2d_PCTSignatures_setDistanceFunction_int(instance: *mut c_void, distance_function: i32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_create_int_int_int(init_sample_count: i32, init_seed_count: i32, point_distribution: i32) -> cv_return_value_void_X;
        pub fn cv_xfeatures2d_PCTSignatures_create_VectorOfPoint2f_int(init_sampling_points: *mut c_void, init_seed_count: i32) -> cv_return_value_void_X;
        pub fn cv_xfeatures2d_PCTSignatures_create_VectorOfPoint2f_VectorOfint(init_sampling_points: *mut c_void, init_cluster_seed_indexes: *mut c_void) -> cv_return_value_void_X;
        pub fn cv_xfeatures2d_PCTSignatures_drawSignature__InputArray__InputArray__OutputArray_float_int(source: *mut c_void, signature: *mut c_void, result: *mut c_void, radius_to_shorter_side_ratio: f32, border_thickness: i32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignatures_generateInitPoints_VectorOfPoint2f_int_int(init_points: *mut c_void, count: i32, point_distribution: i32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignaturesSQFD_computeQuadraticFormDistance_const__InputArray__InputArray(instance: *const c_void, _signature0: *mut c_void, _signature1: *mut c_void) -> cv_return_value_float;
        pub fn cv_xfeatures2d_PCTSignaturesSQFD_computeQuadraticFormDistances_const_Mat_VectorOfMat_VectorOffloat(instance: *const c_void, source_signature: *mut c_void, image_signatures: *mut c_void, distances: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_PCTSignaturesSQFD_create_int_int_float(distance_function: i32, similarity_function: i32, similarity_parameter: f32) -> cv_return_value_void_X;
        pub fn cv_SIFT_delete(ptr : *mut c_void);
        pub fn cv_xfeatures2d_SIFT_create_int_int_double_double_double(nfeatures: i32, n_octave_layers: i32, contrast_threshold: f64, edge_threshold: f64, sigma: f64) -> cv_return_value_void_X;
        pub fn cv_xfeatures2d_SURF_setHessianThreshold_double(instance: *mut c_void, hessian_threshold: f64) -> cv_return_value_void;
        pub fn cv_xfeatures2d_SURF_getHessianThreshold_const(instance: *const c_void) -> cv_return_value_double;
        pub fn cv_xfeatures2d_SURF_setNOctaves_int(instance: *mut c_void, n_octaves: i32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_SURF_getNOctaves_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xfeatures2d_SURF_setNOctaveLayers_int(instance: *mut c_void, n_octave_layers: i32) -> cv_return_value_void;
        pub fn cv_xfeatures2d_SURF_getNOctaveLayers_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xfeatures2d_SURF_setExtended_bool(instance: *mut c_void, extended: bool) -> cv_return_value_void;
        pub fn cv_xfeatures2d_SURF_getExtended_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_xfeatures2d_SURF_setUpright_bool(instance: *mut c_void, upright: bool) -> cv_return_value_void;
        pub fn cv_xfeatures2d_SURF_getUpright_const(instance: *const c_void) -> cv_return_value_bool;
        pub fn cv_xfeatures2d_SURF_create_double_int_int_bool_bool(hessian_threshold: f64, n_octaves: i32, n_octave_layers: i32, extended: bool, upright: bool) -> cv_return_value_void_X;
        pub fn cv_StarDetector_delete(ptr : *mut c_void);
        pub fn cv_xfeatures2d_StarDetector_create_int_int_int_int_int(max_size: i32, response_threshold: i32, line_threshold_projected: i32, line_threshold_binarized: i32, suppress_nonmax_size: i32) -> cv_return_value_void_X;
        pub fn cv_xfeatures2d_VGG_compute__InputArray_VectorOfKeyPoint__OutputArray(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void) -> cv_return_value_void;
        pub fn cv_xfeatures2d_VGG_create_int_float_bool_bool_float_bool(desc: i32, isigma: f32, img_normalize: bool, use_scale_orientation: bool, scale_factor: f32, dsc_normalize: bool) -> cv_return_value_void_X;
    
    }
}
#[cfg(feature = "contrib")]
pub use xfeatures2d_sys::*;

#[cfg(feature = "contrib")]
mod xobjdetect_sys {
    use super::*;

    extern "C" {
        pub fn cv_xobjdetect_WBDetector_read_FileNode(instance: *mut c_void, node: *mut c_void) -> cv_return_value_void;
        pub fn cv_xobjdetect_WBDetector_write_const_FileStorage(instance: *const c_void, fs: *mut c_void) -> cv_return_value_void;
        pub fn cv_xobjdetect_WBDetector_train_std_string_std_string(instance: *mut c_void, pos_samples: *const c_char, neg_imgs: *const c_char) -> cv_return_value_void;
        pub fn cv_xobjdetect_WBDetector_detect_Mat_VectorOfRect_VectorOfdouble(instance: *mut c_void, img: *mut c_void, bboxes: *mut c_void, confidences: *mut c_void) -> cv_return_value_void;
        pub fn cv_xobjdetect_WBDetector_create() -> cv_return_value_void_X;
    
    }
}
#[cfg(feature = "contrib")]
pub use xobjdetect_sys::*;

#[cfg(feature = "contrib")]
mod xphoto_sys {
    use super::*;

    extern "C" {
        pub fn cv_xphoto_applyChannelGains__InputArray__OutputArray_float_float_float(src: *mut c_void, dst: *mut c_void, gain_b: f32, gain_g: f32, gain_r: f32) -> cv_return_value_void;
        pub fn cv_xphoto_bm3dDenoising__InputArray__InputOutputArray__OutputArray_float_int_int_int_int_int_int_float_int_int_int(src: *mut c_void, dst_step1: *mut c_void, dst_step2: *mut c_void, h: f32, template_window_size: i32, search_window_size: i32, block_matching_step1: i32, block_matching_step2: i32, group_size: i32, sliding_step: i32, beta: f32, norm_type: i32, step: i32, transform_type: i32) -> cv_return_value_void;
        pub fn cv_xphoto_bm3dDenoising__InputArray__OutputArray_float_int_int_int_int_int_int_float_int_int_int(src: *mut c_void, dst: *mut c_void, h: f32, template_window_size: i32, search_window_size: i32, block_matching_step1: i32, block_matching_step2: i32, group_size: i32, sliding_step: i32, beta: f32, norm_type: i32, step: i32, transform_type: i32) -> cv_return_value_void;
        pub fn cv_xphoto_createGrayworldWB() -> cv_return_value_void_X;
        pub fn cv_xphoto_createLearningBasedWB_String(path_to_model: *const c_char) -> cv_return_value_void_X;
        pub fn cv_xphoto_createSimpleWB() -> cv_return_value_void_X;
        pub fn cv_xphoto_dctDenoising_Mat_Mat_double_int(src: *mut c_void, dst: *mut c_void, sigma: f64, psize: i32) -> cv_return_value_void;
        pub fn cv_xphoto_inpaint_Mat_Mat_Mat_int(src: *mut c_void, mask: *mut c_void, dst: *mut c_void, algorithm_type: i32) -> cv_return_value_void;
        pub fn cv_xphoto_GrayworldWB_getSaturationThreshold_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xphoto_GrayworldWB_setSaturationThreshold_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_xphoto_LearningBasedWB_extractSimpleFeatures__InputArray__OutputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
        pub fn cv_xphoto_LearningBasedWB_getRangeMaxVal_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xphoto_LearningBasedWB_setRangeMaxVal_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_xphoto_LearningBasedWB_getSaturationThreshold_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xphoto_LearningBasedWB_setSaturationThreshold_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_xphoto_LearningBasedWB_getHistBinNum_const(instance: *const c_void) -> cv_return_value_int;
        pub fn cv_xphoto_LearningBasedWB_setHistBinNum_int(instance: *mut c_void, val: i32) -> cv_return_value_void;
        pub fn cv_xphoto_SimpleWB_getInputMin_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xphoto_SimpleWB_setInputMin_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_xphoto_SimpleWB_getInputMax_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xphoto_SimpleWB_setInputMax_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_xphoto_SimpleWB_getOutputMin_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xphoto_SimpleWB_setOutputMin_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_xphoto_SimpleWB_getOutputMax_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xphoto_SimpleWB_setOutputMax_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_xphoto_SimpleWB_getP_const(instance: *const c_void) -> cv_return_value_float;
        pub fn cv_xphoto_SimpleWB_setP_float(instance: *mut c_void, val: f32) -> cv_return_value_void;
        pub fn cv_xphoto_WhiteBalancer_balanceWhite__InputArray__OutputArray(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> cv_return_value_void;
    
    }
}
#[cfg(feature = "contrib")]
pub use xphoto_sys::*;

pub use crate::manual::sys::*;
